<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[myql数据库MHA实现高可用（多实例间实现）]]></title>
    <url>%2F2019%2F09%2F27%2Fmyql%E6%95%B0%E6%8D%AE%E5%BA%93MHA%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%88%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%97%B4%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; MHA(master high availability)目前是MySQL高可用方面是一个相对成熟的解决方案。在切换过程中，mha能做到0-30s内自动完成数据库的切换，并且在切换过程中最大的保持数据的一致性，以达到真正意义上的高可用&emsp;&emsp; MHA的组成： &emsp;&emsp; MHA Manager(管理节点)和MHA Node(数据节点)。MHA Manager可以独立部署在一台独立的机器上，管理多个集群，也可以部署在从从库上。 &emsp;&emsp; 当Master出现故障的时候，它可以自动将最新的数据的Slave提升为新的Master，然后将所有的Slave重新指向新的Master，整个故障转移过程是完全透明的。&emsp;&emsp; 实验演示图如下：&emsp;&emsp; 操作如下：&emsp;&emsp; 1、在192.168.32.71主机和192.168.32.72主机上搭建好1主3从的主从配置服务器；&emsp;&emsp; 2、在192.168.32.7主机作为监控主机，安装mhamanager包和node包，192.168.32.71主机、192.168.32.72主机只安装node包；&emsp;&emsp; 3、将三台主机的ssh公钥信息互相储存（或公用一个公钥私钥对），设置好相互之间的基于key验证免密登录。（因为用的是多实例数据库，SSH连通性验证时还会检查各个数据库之间的连通性，这就包括3307、3308、3309端口数据库之间的SSH连接，所以一定要在192.168.32.72主机家目录的.ssh/authorized_keys文件中加入192.168.32.72本机的公钥，否则会报错，切记，已踩坑）&emsp;&emsp; 4、编写mha配置文件，路径随意。&emsp;&emsp; /etc/mha.cnf````123456789101112131415161718192021222324````[server default]user=mhauserpassword=mhusermanager_workdir=/data/mastermha/group1/manager_log=/data/mastermha/group1/manager.logremote_workdir=/data/mastermha/group1/ssh_user=rootrepl_user=repluserrepl_password=repluserping_interval=1master_binlog_dir=/data/mysql[server1]hostname=192.168.32.71[server2]hostname=192.168.32.72port=3307candidate_master=1[server3]hostname=192.168.32.72port=3308[server4]hostname=192.168.32.72port=3309 &emsp;&emsp; 5、在主数据库服务器也就是192.168.32.71主机上创建监控账号（user=mhauser password=mhauser）和复制帐号（repl_user=repluser repl_password=repluser）（要和配置文件相同,已有则无需创建，可以用现成的，权限符合即可） 12GRANT ALL ON *.* TO mhauser@&apos;192.168.32.7%&apos; IDENTIFIED BY &apos;mhauser&apos;;GRANT REPLICATION SLAVE ON *.* TO &apos;repluser&apos;@&apos;192.168.32.7%&apos; IDENTIFIED BY &apos;repluser&apos; &emsp;&emsp; 6、用MHA包自带工具进行测试&emsp;&emsp; --conf1234567891011121314151617181920````[root@CentOS7 ~]#/usr/bin/masterha_check_ssh --conf=/etc/mha.cnfFri Sep 27 11:17:25 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Sep 27 11:17:25 2019 - [info] Reading application default configuration from /etc/mha.cnf..Fri Sep 27 11:17:25 2019 - [info] Reading server configuration from /etc/mha.cnf..Fri Sep 27 11:17:25 2019 - [info] Starting SSH connection tests..Fri Sep 27 11:17:28 2019 - [debug] Fri Sep 27 11:17:25 2019 - [debug] Connecting via SSH from root@192.168.32.71(192.168.32.71:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:25 2019 - [debug] ok.Fri Sep 27 11:17:25 2019 - [debug] Connecting via SSH from root@192.168.32.71(192.168.32.71:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:26 2019 - [debug] ok.Fri Sep 27 11:17:26 2019 - [debug] Connecting via SSH from root@192.168.32.71(192.168.32.71:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:27 2019 - [debug] ok.Fri Sep 27 11:17:28 2019 - [debug] Fri Sep 27 11:17:26 2019 - [debug] Connecting via SSH from root@192.168.32.72(192.168.32.72:22) to root@192.168.32.71(192.168.32.71:22)..Fri Sep 27 11:17:27 2019 - [debug] ok.Fri Sep 27 11:17:27 2019 - [debug] Connecting via SSH from root@192.168.32.72(192.168.32.72:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:28 2019 - [debug] ok.Fri Sep 27 11:17:28 2019 - [debug] Connecting via SSH from root@192.168.32.72(192.168.32.72:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:29 2019 - [info] All SSH connection tests passed successfully. &emsp;&emsp; --conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788````[root@CentOS7 ~]#/usr/bin/masterha_check_repl --conf=/etc/mha.cnfFri Sep 27 11:18:12 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Sep 27 11:18:12 2019 - [info] Reading application default configuration from /etc/mha.cnf..Fri Sep 27 11:18:12 2019 - [info] Reading server configuration from /etc/mha.cnf..Fri Sep 27 11:18:12 2019 - [info] MHA::MasterMonitor version 0.56.Fri Sep 27 11:18:13 2019 - [info] GTID failover mode = 0Fri Sep 27 11:18:13 2019 - [info] Dead Servers:Fri Sep 27 11:18:13 2019 - [info] Alive Servers:Fri Sep 27 11:18:13 2019 - [info] 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3307)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3308)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3309)Fri Sep 27 11:18:13 2019 - [info] Alive Slaves:Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3307) Version=10.4.8-MariaDB-log (oldest major version between slaves) log-bin:enabledFri Sep 27 11:18:13 2019 - [info] Replicating from 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] Primary candidate for the new Master (candidate_master is set)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3308) Version=10.4.8-MariaDB-log (oldest major version between slaves) log-bin:enabledFri Sep 27 11:18:13 2019 - [info] Replicating from 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3309) Version=10.4.8-MariaDB-log (oldest major version between slaves) log-bin:enabledFri Sep 27 11:18:13 2019 - [info] Replicating from 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] Current Alive Master: 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] Checking slave configurations..Fri Sep 27 11:18:13 2019 - [info] Checking replication filtering settings..Fri Sep 27 11:18:13 2019 - [info] binlog_do_db= , binlog_ignore_db= Fri Sep 27 11:18:13 2019 - [info] Replication filtering check ok.Fri Sep 27 11:18:13 2019 - [info] GTID (with auto-pos) is not supportedFri Sep 27 11:18:13 2019 - [info] Starting SSH connection tests..Fri Sep 27 11:18:17 2019 - [info] All SSH connection tests passed successfully.Fri Sep 27 11:18:17 2019 - [info] Checking MHA Node version..Fri Sep 27 11:18:18 2019 - [info] Version check ok.Fri Sep 27 11:18:18 2019 - [info] Checking SSH publickey authentication settings on the current master..Fri Sep 27 11:18:18 2019 - [info] HealthCheck: SSH to 192.168.32.71 is reachable.Fri Sep 27 11:18:18 2019 - [info] Master MHA Node version is 0.56.Fri Sep 27 11:18:18 2019 - [info] Checking recovery script configurations on 192.168.32.71(192.168.32.71:3306)..Fri Sep 27 11:18:18 2019 - [info] Executing command: save_binary_logs --command=test --start_pos=4 --binlog_dir=/data/mysql --output_file=/data/mastermha/group1//save_binary_logs_test --manager_version=0.56 --start_file=master-bin.000012 Fri Sep 27 11:18:18 2019 - [info] Connecting to root@192.168.32.71(192.168.32.71:22).. Creating /data/mastermha/group1 if not exists.. ok. Checking output directory is accessible or not.. ok. Binlog found at /data/mysql, up to master-bin.000012Fri Sep 27 11:18:19 2019 - [info] Binlog setting check done.Fri Sep 27 11:18:19 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..Fri Sep 27 11:18:19 2019 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user=&apos;mhauser&apos; --slave_host=192.168.32.72 --slave_ip=192.168.32.72 --slave_port=3307 --workdir=/data/mastermha/group1/ --target_version=10.4.8-MariaDB-log --manager_version=0.56 --relay_log_info=/data/mysql3307/data/relay-log.info --relay_dir=/data/mysql3307/data/ --slave_pass=xxxFri Sep 27 11:18:19 2019 - [info] Connecting to root@192.168.32.72(192.168.32.72:22).. Checking slave recovery environment settings.. Opening /data/mysql3307/data/relay-log.info ... ok. Relay log found at /data/mysql3307/data, up to relay-log.000034 Temporary relay log file is /data/mysql3307/data/relay-log.000034 Testing mysql connection and privileges.. done. Testing mysqlbinlog output.. done. Cleaning up test file(s).. done.Fri Sep 27 11:18:19 2019 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user=&apos;mhauser&apos; --slave_host=192.168.32.72 --slave_ip=192.168.32.72 --slave_port=3308 --workdir=/data/mastermha/group1/ --target_version=10.4.8-MariaDB-log --manager_version=0.56 --relay_log_info=/data/mysql3308/data/relay-log.info --relay_dir=/data/mysql3308/data/ --slave_pass=xxxFri Sep 27 11:18:19 2019 - [info] Connecting to root@192.168.32.72(192.168.32.72:22).. Checking slave recovery environment settings.. Opening /data/mysql3308/data/relay-log.info ... ok. Relay log found at /data/mysql3308/data, up to relay-log.000009 Temporary relay log file is /data/mysql3308/data/relay-log.000009 Testing mysql connection and privileges.. done. Testing mysqlbinlog output.. done. Cleaning up test file(s).. done.Fri Sep 27 11:18:20 2019 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user=&apos;mhauser&apos; --slave_host=192.168.32.72 --slave_ip=192.168.32.72 --slave_port=3309 --workdir=/data/mastermha/group1/ --target_version=10.4.8-MariaDB-log --manager_version=0.56 --relay_log_info=/data/mysql3309/data/relay-log.info --relay_dir=/data/mysql3309/data/ --slave_pass=xxxFri Sep 27 11:18:20 2019 - [info] Connecting to root@192.168.32.72(192.168.32.72:22).. Checking slave recovery environment settings.. Opening /data/mysql3309/data/relay-log.info ... ok. Relay log found at /data/mysql3309/data, up to relay-log.000009 Temporary relay log file is /data/mysql3309/data/relay-log.000009 Testing mysql connection and privileges.. done. Testing mysqlbinlog output.. done. Cleaning up test file(s).. done.Fri Sep 27 11:18:20 2019 - [info] Slaves settings check done.Fri Sep 27 11:18:20 2019 - [info] 192.168.32.71(192.168.32.71:3306) (current master) +--192.168.32.72(192.168.32.72:3307) +--192.168.32.72(192.168.32.72:3308) +--192.168.32.72(192.168.32.72:3309)Fri Sep 27 11:18:20 2019 - [info] Checking replication health on 192.168.32.72..Fri Sep 27 11:18:20 2019 - [info] ok.Fri Sep 27 11:18:20 2019 - [info] Checking replication health on 192.168.32.72..Fri Sep 27 11:18:20 2019 - [info] ok.Fri Sep 27 11:18:20 2019 - [info] Checking replication health on 192.168.32.72..Fri Sep 27 11:18:20 2019 - [info] ok.Fri Sep 27 11:18:20 2019 - [warning] master_ip_failover_script is not defined.Fri Sep 27 11:18:20 2019 - [warning] shutdown_script is not defined.Fri Sep 27 11:18:20 2019 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK. &emsp;&emsp; 均显示测试成功~&emsp;&emsp; 可以启动MHAmanager了，注意这是一个前端程序，如果检测到主数据库宕机，则会自动切换从数据为新的主服务器并使其他的从服务器从新的主服务器数据库上面复制数据，此后程序自动终止。 1234[root@CentOS7 ~]#/usr/bin/masterha_manager --conf=/etc/mha.cnfFri Sep 27 11:35:37 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Sep 27 11:35:37 2019 - [info] Reading application default configuration from /etc/mha.cnf..Fri Sep 27 11:35:37 2019 - [info] Reading server configuration from /etc/mha.cnf.. &emsp;&emsp; 在主数据库上将mysql进程杀掉后，MHA进程自动结束。&emsp;&emsp; 在3307端口数据库上查询，已经没有从节点信息了。&emsp;&emsp; 在3308端口数据库以及3309端口数据上显示，主数据库已变为更为3307端口数据库，说明转换主从结构成功！&emsp;&emsp; PS：因为几个数据库都是源码编译安装，数据库路径和二进制文件储存位置都做出了调整，与默认位置不同，而yum安装的MHAmaster中如果配置文件中不写明master_binlog_dir的位置，则会默认去 /usr/bin/msyql/目录下找主机二进制文件（当然，mysql数据库也是yum安装的可忽略这些配置，一切默认就好，而配置文件中添加server主机时，如果端口号不是默认3306，一定要记得写明port端口号，如本文中多实例用的不同端口，标记清楚即可。）]]></content>
      <tags>
        <tag>MHA</tag>
        <tag>高可用</tag>
        <tag>mysql</tag>
        <tag>mariadb</tag>
        <tag>多实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql多实例实现主从级联复制及读写分离]]></title>
    <url>%2F2019%2F09%2F25%2Fmysql%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E7%BA%A7%E8%81%94%E5%A4%8D%E5%88%B6%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[一、多实例1、概述&emsp;&emsp; MySQL多实例就是在一台机器上开启多个不同的服务端口（如：3306,3307），运行多个MySQL服务进程，通过不同的socket监听不同的服务端口来提供各自的服务2.1、优点1）有效利用服务器资源&emsp;&emsp; 当单个服务器资源过剩时，可以充分利用剩余的资源来提供更多的服务；2）节约服务器资源 &emsp;&emsp; 当公司资金紧张，但数据库又需要数据库之间各自提供服务时，并且还想使用主从同步等技术，此时多实例就再好不过了；3）方便后期架构扩展 &emsp;&emsp; 当公司的某个项目才启动时，启动初期并不一定有很大的用户量，因此可以先用一组物理数据库服务器，在上面部署多个实例，方便后续架构扩展、迁移； 2.2、缺点 资源互相抢占问题 &emsp;&emsp; 当某个服务实例并发很高或者有慢查询时，整个实例会消耗更多的内存、CPU和IO资源，这将导致服务器上的其它实例提供服务的质量下降。这就比如说合租房的各个租客，每当早晨上班时，都会洗漱，此时卫生间的占用率就大，各个租客总会发生等待。 3、部署mysql多实例的两种方式 ① 基于多配置文件 &emsp;&emsp; 通过使用多个配置文件来启动不同的进程，以此来实现多实例。 &emsp;&emsp; 优点：逻辑简单，配置简单 &emsp;&emsp; 缺点：管理起来不方便 ② 基于mysqld_multi &emsp;&emsp; 通过官方自带的 mysqld_multi 工具，使用单独配置文件来实现多实例 &emsp;&emsp; 优点： 便于集中管理管理 &emsp;&emsp; 缺点： 不方便针对每个实例配置进行定制 4、同一开发环境下安装两个数据库，必须处理以下问题 &emsp;&emsp; （1） 配置文件安装路径不能相同 &emsp;&emsp; （2）数据库目录不能相同 &emsp;&emsp; （3）启动脚本不能同名 &emsp;&emsp; （4）端口不能相同 &emsp;&emsp; （5）socket文件的生成路径不能相同5、配置搭建&emsp;&emsp; 实现目标：&emsp;&emsp; 1、源码编译安装或者二进制安装或者yum安装mysql或mariadb客户端以及server端,若没有创建mysql用户、组则创建。&emsp;&emsp; 2、在指定路径下创建3个数据库目录&emsp;&emsp;-plink12&amp;emsp;&amp;emsp; 挂载在不同的三块硬盘上&amp;emsp;&amp;emsp; ````mount /dev/sdb /data/mysql3307 &emsp;&emsp; /dev/sdclink1&amp;emsp;&amp;emsp; ````mount /dev/sdd /data/mysql3309 &emsp;&emsp; 3、用server端带的初始化脚本生成三个数据库&emsp;&emsp; --datadir1&amp;emsp;&amp;emsp; ````scripts/mariadb-install-db --datadir=/data/mysql3308/ --user=mysql &emsp;&emsp; --datadir12&amp;emsp;&amp;emsp; 4、准备三个配置文件&amp;emsp;&amp;emsp; ````cp /etc/my.cnf /data/mysql3307/my.cnf &emsp;&emsp; /etc/my.cnflink1&amp;emsp;&amp;emsp; ````cp /etc/my.cnf /data/mysql3309/my.cnf &emsp;&emsp; 修改分别其中配置（以下以实例3307为例，3308、3309将下面所有数字对应改成自己的端口号） 12345678910111213141516171819[client]#password = your_passwordport = 3307socket = /data/mysql3307/mysql.sock[mysqld]datadir=/data/mysql3307/innodb_file_per-table=onskip_name_resolve=onport = 3307socket = /data/mysql3307/mysql.socklog-bin=mysql-binlog-slave-updatesserver-id = 3307 #每个数据库server-id全局唯一default-character-set=utf8read_only=ON #3307特有选项-开启中继日志relay_log=relay-log #3307特有选项relay_log_index=relay-log.index #3307特有选项 &emsp;&emsp; 5、编写服务启动脚本（并加执行权限和修改PATH路径）&emsp;&emsp; mysqld````12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758````#!/bin/bashport=$1mysql_user="root"mysql_pwd="password"cmd_path="/usr/local/mysql/bin"mysql_basedir="/data/mysql"mysql_sock="$&#123;mysql_basedir&#125;$&#123;port&#125;/mysql.sock"function_start_mysql()&#123; if [ ! -e "$mysql_sock" ];then printf "Starting MySQL...\n" $&#123;cmd_path&#125;/mysqld_safe --defaults-file=$&#123;mysql_basedir&#125;$&#123;port&#125;/my.cnf &amp;&gt; /dev/null &amp; else printf "MySQL is running...\n" exit fi&#125;function_stop_mysql()&#123; if [ ! -e "$mysql_sock" ];then printf "MySQL is stopped...\n" exit else printf "Stoping MySQL...\n" $&#123;cmd_path&#125;/mysqladmin -u $&#123;mysql_user&#125; -p$&#123;mysql_pwd&#125; -S $&#123;mysql_sock&#125; shutdown fi&#125;function_restart_mysql()&#123; printf "Restarting MySQL...\n" function_stop_mysql sleep 1 function_start_mysql&#125;if [ ! -n "$2" ];then printf "Usage: $&#123;mysql_basedir&#125;$&#123;port&#125;/bin/mysqld [PORT] &#123;start|stop|restart&#125;\n"else case $2 in start) function_start_mysql ;; stop) function_stop_mysql ;; restart) function_restart_mysql ;; *) printf "Usage: $&#123;mysql_basedir&#125;$&#123;port&#125;/bin/mysqld &#123;start|stop|restart&#125;\n" esacfi &emsp;&emsp; 6、现在就可以实现执行mysqld 3307 start启动数据库服务了。启动三台数据库后（可运行安全加固脚本去掉test数据库以及多余账户），在主机数据库及这3个数据库中分别增加主从配置。&emsp;&emsp; 192.168.32.71主机数据库: 12MariaDB [(none)]&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repluser&apos;@&apos;192.168.32.72&apos; IDENTIFIED BY &apos;replpasswd&apos;;MariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; show master status;+——————–+—————+—————–+———————+|&emsp;&emsp; &emsp;File&emsp;&emsp;&emsp;&emsp; | &emsp;Position &emsp;| Binlog_Do_DB | Binlog_Ignore_DB |+——————–+—————+—————–+———————+| mysql-bin.000026 | &emsp; 1136 &emsp;&emsp;|&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+——————–+—————+—————–+———————+ &emsp;&emsp; 查看并记录主机当前二进制日志文件信息及位置。&emsp;&emsp; 用mysqldump (或者物理备份)，并还原至3个从节点。&emsp;&emsp; 192.168.32.71主机:&emsp;&emsp; -uroot -ppassword -A --default-character-set1&amp;emsp;&amp;emsp; ````scp /data/fullbak_`date +%F`.sql 192.168.32.72:/data/ &emsp;&emsp; 192.168.32.72主机:&emsp;&emsp; 启动3个实例的服务3307 start；mysqld 3308 start；mysqld 3309 start````1&amp;emsp;&amp;emsp; 连接3307实例````mysql -S /data/mysql3307/mysql.sock 12MariaDB [(none)]&gt; source /data/fullbak_XXX.sqlMariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; show master status;+——————–+—————+—————–+———————+|&emsp;&emsp; &emsp;File&emsp;&emsp;&emsp;&emsp; | &emsp;Position &emsp;| Binlog_Do_DB | Binlog_Ignore_DB |+——————–+—————+—————–+———————+| mysql-bin.000006 | &emsp; 1167 &emsp;&emsp;|&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+——————–+—————+—————–+———————+ &emsp;&emsp; 记录3307实例的当前二进制日志文件信息及位置。 &emsp;&emsp; 在从节点3307添加主节点配置信息。 123456MariaDB [(none)]&gt; change master to master_host=&apos;192.168.32.71&apos;,master_user=&apos;repluser&apos;,master_password=&apos;replpasswd&apos;,master_port=3306,master_log_file=&apos;mysql-bin.000026&apos;,master_log_pos=1136;MariaDB [(none)]&gt;start slave; &emsp;&emsp; 连接3308实例mysql -S /data/mysql3308/mysql.sock&emsp;&emsp; 在从节点3308添加主节点配置信息。 1234567MariaDB [(none)]&gt; source /data/fullbak_XXX.sqlMariaDB [(none)]&gt; change master to master_host=&apos;192.168.32.72,master_user=&apos;repluser&apos;,master_password=&apos;replpasswd&apos;,master_port=3307,master_log_file=&apos;mysql-bin.000006&apos;,master_log_pos=1167;MariaDB [(none)]&gt;start slave; &emsp;&emsp; 连接3309实例mysql -S /data/mysql3309/mysql.sock&emsp;&emsp; 在从节点3309添加主节点配置信息。 1234567MariaDB [(none)]&gt; source /data/fullbak_XXX.sqlMariaDB [(none)]&gt; change master to master_host=&apos;192.168.32.72,master_user=&apos;repluser&apos;,master_password=&apos;replpasswd&apos;,master_port=3307,master_log_file=&apos;mysql-bin.000006&apos;,master_log_pos=1167;MariaDB [(none)]&gt;start slave; &emsp;&emsp; 三个从节点数据库依次slave status\G````查看主从状态信息，确认主从配置无误且均已启动，至此，多实例主从级联配置就完成了。123456789101112131415161718192021&amp;emsp;&amp;emsp; **二、读写分离**1、什么是读写分离？&amp;emsp;&amp;emsp; 读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。 2、为什么要实现读写分离？&amp;emsp;&amp;emsp; 因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。 &amp;emsp;&amp;emsp; 但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。 所以读写分离，解决的是，数据库的写入，影响了查询的效率。 3、什么时候要读写分离？ &amp;emsp;&amp;emsp; 数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。 4、部署读写分离&amp;emsp;&amp;emsp; 本次使用proxy实现读写分离，最终实现下图所示![在这里插入图片描述](https://img-blog.csdnimg.cn/20190925164049740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp; 1、部署代理机ip：192.168.32.70&amp;emsp;&amp;emsp; 安装proxy及mysql客户端 cat /etc/yum.repos.d/proxysql.repo &lt;&lt;EOF[proxysql_repo]name= ProxySQL YUM repositorybaseurl=http://repo.proxysql.com/ProxySQL/proxysql-1.4.x/centos/\$releasevergpgcheck=1gpgkey=http://repo.proxysql.com/ProxySQL/repo_pub_keyEOFyum install proxysql -yyum install mysql -y 12&amp;emsp;&amp;emsp; 修改代理机配置文件端口号 6033 改为 3306（方便客户机连接,其他保持默认）&amp;emsp;&amp;emsp;````sed -ri &apos;s@(interfaces=&quot;0.0.0.0:)6033@\13306@&apos; /etc/proxysql.cnf &emsp;&emsp; 登陆proxysql数据库&emsp;&emsp;-uadmin -padmin -P6032 -h127.0.0.1````12&amp;emsp;&amp;emsp; 在代理服务器上增加主机信息&amp;emsp;&amp;emsp; MySQL [(none)]&gt; insert into mysql_servers(hostgroup_id,hostname,port) values(10,’192.168.32.71’,3306),(10,’192.168.32.72’,3307),(10,’192.168.32.72’,3308),(10,’192.168.32.72’,3309); 1&amp;emsp;&amp;emsp; 加载:MySQL [(none)]&gt; ````load mysql servers to runtime &emsp;&emsp; 保存:MySQL [(none)]&gt; mysql servers to disk````123&amp;emsp;&amp;emsp; #设置监控帐号（使用默认监控账号(账号:密码=monitor:monitor)的话，此步可跳过）&amp;emsp;&amp;emsp; MySQL [(none)]&gt; set mysql-monitor_username=’username’set mysql-monitor_password=’password’MySQL [(none)]&gt; load mysql variables to runtime;MySQL [(none)]&gt; save mysql variables to disk; 123&amp;emsp;&amp;emsp; 2、在主服务器上增加创建proxy的监控帐号并授权(从节点会自动复制创建，无需再创)&amp;emsp;&amp;emsp; MySQL [(none)]&gt; ````grant replication client on *.* to monitor@&apos;192.168.32.71&apos;identified by &apos;monitor&apos;; &emsp;&emsp; 3、在代理机上查看监控连接是否正常的 (对connect指标的监控)：&emsp;&emsp; 如果connect_error的结果为NULL则表示正常&emsp;&emsp; MySQL&gt;* from mysql_server_connect_log;````12&amp;emsp;&amp;emsp; 查看监控心跳信息 (对ping指标的监控)：&amp;emsp;&amp;emsp; MySQL&gt; ````select * from mysql_server_ping_log; &emsp;&emsp; **(如果显示连接失败，可尝试在从节点刷新权限privileges;````)**123&amp;emsp;&amp;emsp; 4、设置分组信息&amp;emsp;&amp;emsp; 需要修改的是main库中的mysql_replication_hostgroups表，该表有3个字段：writer_hostgroup，reader_hostgroup，comment, 指定写组的id为10，读组的id为20&amp;emsp;&amp;emsp; MySQL&gt;````insert into mysql_replication_hostgroups values(10,20,&quot;CentOS7&quot;); &emsp;&emsp; 将mysql_replication_hostgroups表的修改加载到RUNTIME生效&emsp;&emsp; MySQL&gt; mysql servers to runtime;````1&amp;emsp;&amp;emsp; MySQL&gt; ````save mysql servers to disk; &emsp;&emsp; Monitor模块监控后端的read_only值，按照read_only的值将节点自动移动到读/写组&emsp;&emsp;查看添加的主机分组表，应该已经自动分组了：&emsp;&emsp; MySQL&gt;hostgroup_id,hostname,port,status,weight from mysql_servers; ````1234567![在这里插入图片描述](https://img-blog.csdnimg.cn/2019092521480589.png)&amp;emsp;&amp;emsp; 5、在proxysql上配置路由规则，实现读写分离&amp;emsp;&amp;emsp; 与规则有关的表：mysql_query_rules和mysql_query_rules_fast_routing，后者是前者的扩展表，1.4.7之后支持&amp;emsp;&amp;emsp; 插入路由规则：将select语句分离到20的读组，select语句中有一个特殊语句&amp;emsp;&amp;emsp; SELECT...FOR UPDATE它会申请写锁，应路由到10的写组&amp;emsp;&amp;emsp; MySQL&gt;````insert into mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply) VALUES(1,1,&apos;^SELECT.*FOR UPDATE$&apos;,10,1),(2,1,&apos;^SELECT&apos;,20,1); &emsp;&emsp; MySQL&gt; mysql query rules to runtime;````1&amp;emsp;&amp;emsp; MySQL&gt; ````save mysql query rules to disk; 注意：因ProxySQL根据rule_id顺序进行规则匹配，select … for update规则的rule_id必须要小于普通的select规则的rule_id &emsp;&emsp;在代理机上用命令测试相应读写的是哪个数据库：&emsp;&emsp;mysql -uroot -pPASSWORD -P3306 -h127.0.0.1 -e &#39;start transaction;select @@server_id;commit;select @@server_id&#39;+——————+| @@server_id&emsp; |+——————+| &emsp; &emsp; 3306&emsp; &emsp; |+——————++——————+| @@server_id&emsp; |+——————+| &emsp; &emsp; 3307 &emsp; &emsp; |+——————+&emsp;&emsp;说明读写分离，在两个终端上成功实现~]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>多实例</tag>
        <tag>级联复制</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于mariadb10.4.8二进制安装及源码编译后设置密码无效的一些发现]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%85%B3%E4%BA%8Emariadb10-4-8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%90%8E%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E6%97%A0%E6%95%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前安装了最新版的mariadb10.4.8后，无论是二进制编译安装还是源码编译安装，设定完密码之后启动mysqld服务，结果都不需要密码就可以登陆进去，无论怎么执行mysql_secure_installation数据库初始化脚本或者mysql_secure_installation安全加固脚本，进入mysql都无需密码，用命令直接设置密码也无效，都是直接一敲mysql就可以进入数据库了。my.cnf配置文件查看了无数遍，也没发现任何蛛丝马迹。今天终于在无意中查看mysql数据库权限时意外有所收获，写出来与大家分享，让大家少走弯路。&emsp;&emsp;当我进入mysql数据库，打开user表时，查看了下用户没有任何问题。MariaDB [mysql]&gt; select user,host,password from user;+———-+————+———————————————————–+| user &emsp;&emsp;| host &emsp;&emsp; | &emsp; password &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+———-+————+———————————————————–+| &emsp;root&emsp; | localhost | 54D9A58CB44735F80AC5AD29961814D6D12B8746 || &emsp;root &emsp;| 127.0.0.1 | 54D9A58CB44735F80AC5AD29961814D6D12B8746 || &emsp;root&emsp; | ::1 &emsp;&emsp;&emsp; | *54D9A58CB44735F80AC5AD29961814D6D12B8746 |+———-+————+———————————————————–+3 rows in set (0.001 sec)|user | host |password ||–|–|–||root | localhost | *54D9A58CB44735F80AC5AD29961814D6D12B8746 ||root | 127.0.0.1 | *54D9A58CB44735F80AC5AD29961814D6D12B8746 ||root |::1| *54D9A58CB44735F80AC5AD29961814D6D12B8746 |&emsp;&emsp;可当我突发奇想打算看看他们这几个用户有什么权限上的区别时，就发现问题了：*MariaDB [mysql]&gt; show grants for ‘root’@’localhost’;**+—————————————————————————————————————+| &emsp;Grants for root@localhost&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+—————————————————————————————————————+| GRANT ALL PRIVILEGES ON *. TO ‘root’@’localhost’ IDENTIFIED VIA mysql_native_password USING ‘invalid’ OR unix_socket WITH GRANT OPTION &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|| GRANT PROXY ON ‘’@’%’ TO ‘root’@’localhost’ WITH GRANT OPTION &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|+—————————————————————————————————————+2 rows in set (0.000 sec)MariaDB [mysql]&gt; show grants for ‘root’@’127.0.0.1’;ERROR 1141 (42000): There is no such grant defined for user ‘root’ on host ‘127.0.0.1’MariaDB [mysql]&gt; show grants for ‘root’@’::1’;ERROR 1141 (42000): There is no such grant defined for user ‘root’ on host ‘::1’MariaDB [mysql]&gt;&emsp;&emsp;root用户竟然查不到权限，这就很奇怪了。在之前的mariadb10.2.27上尝试了下，都是正常的，如下图所示：&emsp;&emsp;于是我就尝试对那两个异常的用户账号授权。&emsp;&emsp;竟然也无法授权。这种情况跟我之前尝试过的直接用insert命令向user表中加的user条目情况有点相似。当时我用 1insert user set Host=&apos;192.168.32.7&apos;,User=&apos;root&apos;,Password=&apos;54D9A58CB44735F80AC5AD29961814D6D12B8746&apos;,ssl_cipher=&apos;&apos;,x509_subject=&apos;&apos;,x509_issuer=&apos;&apos;,authentication_string=&apos;&apos;; 命令在user表中创建了一个用户条目‘root’@’192.168.32.7’。&emsp;&emsp;这个条目看起来和真正的用户一样，可等到授权时就发现没法授权了，且这个用户也没法远程在192.168.32.7主机登录，尝试insert了一个新的非root用户，也是同样的情况。说明create user 命令不单单只是在这个表上创建了新的用户条目，在其他关联的表上也有条目的增加。OK ，话题扯远了，继续说之前的无法加密的问题。&emsp;&emsp;既然是同样的情况，我想到会不会是说明我这个新装好的mariadb上的这两个用户没有创建成功，是不是像上面提到的两个异常用户只是在这表中“徒有其表”呢？&emsp;&emsp;那就尝试创建用户，并查看了下权限。&emsp;&emsp;竟然创建用户成功了，而且权限也显示出来了（我记得我还没有授权呢啊！！！看来是root用户不用授权）。好像一切都恢复正常了。&emsp;&emsp;赶紧退出看下是不是真的恢复正常了，结果失望的发现还是一敲mysql就可以登陆进去了！！！&emsp;&emsp;不过又尝试了下 用127.0.0.1登陆，发现竟然需要密码验证了，且用之前设置的密码才可以登录。我好像发现了什么~&emsp;&emsp;删除用户‘root’@’localhost’，不让删，需要至少一个有CREATE USER权限用户，看来之前的‘root’@’127.0.0.1’用户没有权限。&emsp;&emsp;那就先给‘root’@’127.0.0.1’用户授权all on *.* to 'root'@'127.0.0.1';````，再删除用户'root'@'localhost'，成功了，再重新创建'root'@'localhost'用户并指定密码，再授权。OK，退出重新登陆一下。123456789101112131415161718192021222324![在这里插入图片描述](https://img-blog.csdnimg.cn/20190919155616216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;果然数据库加密成功了~！问题解决！**-------------------------------------------（以上封存，警醒自己的无知~）--------------------------------------------**&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;**后记**：&amp;emsp;&amp;emsp;原来是mariadb10.4.8版本默认是可以本地使用使用unix_socket登陆无需密码，才导致密码无效，在上面的图片里显示得清清楚楚。**MariaDB [mysql]&gt; show grants for &apos;root&apos;@&apos;localhost&apos;;**+---------------------------------------------------------------------------------------------------------------+| &amp;emsp;Grants for root@localhost&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; |+---------------------------------------------------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; IDENTIFIED VIA mysql_native_password USING &apos;invalid&apos; **OR unix_socket** WITH GRANT OPTION &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;|| GRANT PROXY ON &apos;&apos;@&apos;%&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;|+---------------------------------------------------------------------------------------------------------------+2 rows in set (0.000 sec)**MariaDB [mysql]&gt; show grants for &apos;root&apos;@&apos;127.0.0.1&apos;;**ERROR 1141 (42000): There is no such grant defined for user &apos;root&apos; on host &apos;127.0.0.1&apos;**MariaDB [mysql]&gt; show grants for &apos;root&apos;@&apos;::1&apos;;**ERROR 1141 (42000): There is no such grant defined for user &apos;root&apos; on host &apos;::1&apos;MariaDB [mysql]&gt; ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190918202258915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;当然，也存在用户不存在，而user表中有条目的情况。所以想最终解决这个问题，实际上最直接的命令是：&amp;emsp;&amp;emsp;````GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; IDENTIFIED VIA mysql_native_password USING &apos;*54D9A58CB44735F80AC5AD29961814D6D12B8746&apos; WITH GRANT OPTION; &emsp;&emsp;重新对root@localhost用户授权取消unix_sock登陆，并设置密码。&emsp;&emsp;至此，问题才真正解决。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后记写于 2019.9.23。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mariadb</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制安装及源码编译安装mariadb数据库]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85mariadb%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。&emsp;&emsp;MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，它使用了Percona的 XtraDB，InnoDB的变体，分支的开发者希望提供访问即将到来的MySQL 5.4 InnoDB性能。这个版本还包括了 PrimeBase XT (PBXT) 和 FederatedX存储引擎。&emsp;&emsp;开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 过去一年中，大型互联网用户以及Linux发行商纷纷抛弃MySQL，转投MariaDB阵营。MariaDB是目前最受关注的MySQL数据库衍生版，也被视为开源数据库MySQL的替代品。&emsp;&emsp;MariaDB虽然被视为MySQL数据库的替代品，但它在扩展功能、存储引擎以及一些新的功能改进方面都强过MySQL。而且从MySQL迁移到MariaDB也是非常简单的：&emsp;&emsp;1、数据和表定义文件（.frm）是二进制兼容的&emsp;&emsp;2、所有客户端API、协议和结构都是完全一致的&emsp;&emsp;3、所有文件名、二进制、路径、端口等都是一致的&emsp;&emsp;4、所有的MySQL连接器，比如PHP、Perl、Python、Java、.NET、MyODBC、Ruby以及MySQL C connector等在MariaDB中都保持不变&emsp;&emsp;5、mysql-client包在MariaDB服务器中也能够正常运行&emsp;&emsp;6、共享的客户端库与MySQL也是二进制兼容的也就是说，在大多数情况下，你完全可以卸载MySQL然后安装MariaDB，然后就可以像之前一样正常的运行。(以上摘自百度百科)&emsp;&emsp;作为目前比较热门的开源数据库软件，一般常见有三种安装方式：yum或rpm包安装、二进制安装以及源码包安装，包安装过于简单，也很难符合一般企业定制需要，故不做叙述，本文详细讲述后两种安装方式。 二进制安装1.先创建mysql用户及mysql组，并制定家目录为/data/mysql&emsp;&emsp;-r -g 306 mysql #指定属组gid为306````1&amp;emsp;&amp;emsp;````useradd -r -g 306 -u 306 -d /data/mysql mysql #指定属主uid为306，家目录为/data/mysql 2.准备数据目录(mysq用户家目录),并修正权限&emsp;&emsp;/data/mysql;chown mysql:mysqllink12343.去官网下载mariadb 二进制tar包（链接是CentOS7X86_64的10.4.8稳定版） &amp;emsp;&amp;emsp;http://ftp.igh.cnrs.fr/pub/mariadb//mariadb-10.4.8/bintar-linux-systemd-x86_64/mariadb-10.4.8-linux-systemd-x86_64.tar.gz4.**解压tar包**指/usr/local目录下,递归改属主为root、属组为mysql，并在/usr/local目录下创建一个名为mysql的软链接指向解压好的mariadb目录&amp;emsp;&amp;emsp;````tar xzf mariadb-10.4.8-linux-systemd-x86_64.tar.gz -c /usr/local &emsp;&emsp;/usr/local````1&amp;emsp;&amp;emsp;````ln -sv mariadb-10.4.8-linux-systemd-x86_64 mysql &emsp;&emsp;-R root:mysqllink125.**创建配置文件**,并修改&amp;emsp;&amp;emsp;````mkdir /etc/mysql/ &emsp;&emsp;/etc/my.cnflink1&amp;emsp;&amp;emsp;````sed -ri &apos;/datadir=\//s@(.*=).*@\1\/data\/mysql@&apos; /etc/mysql/my.cnf #修改配置文件，指定数据库储存路径 &emsp;&emsp;-ri '/datadir/a\innodb_file_per-table126.**创建数据库文件**&amp;emsp;&amp;emsp;````/usr/local/scripts/mysql_install_db --datadir=/data/mysql --user=mysql 7.创建服务脚本并启动服务&emsp;&emsp;/usr/local/support-files/mysql.serverlink1&amp;emsp;&amp;emsp;````chkconfig --add mysqld &emsp;&emsp;mysqld start````128.**增加PATH环境变量**路径,并生效。&amp;emsp;&amp;emsp;````echo &apos;PATH=/usr/local/mysql/bin:$PATH&apos; &gt;/etc/profile.d/mysql.sh &emsp;&emsp;/etc/profile.d/mysql.sh````129.**运行安全初始化脚本**，设置root口令、禁用匿名登陆、禁用远程主机登陆、删除test数据库，并立即生效(根据提示操作)。&amp;emsp;&amp;emsp;````ln -s /var/lib/mysql/mysql.sock /tmp &emsp;&emsp;12345&amp;emsp;&amp;emsp;至此，二进制安装mariadb数据库就完成了~#### 源码编译安装1.先**创建mysql用户及mysql组**，并制定家目录为/data/mysql&amp;emsp;&amp;emsp;````groupadd -r -g 306 mysql #指定属组gid为306 &emsp;&emsp;-r -g 306 -u 306 -dmysql #指定属主uid为306，家目录为/data/mysql````122.**准备数据目录(mysq用户家目录)**,并修正权限&amp;emsp;&amp;emsp;````mkdir /data/mysql;chown mysql:mysql /data/mysql 3.去官网下载mariadb 源码tar包（链接是CentOS7X86_64的10.4.8稳定版）&emsp;&emsp;http://ftp.igh.cnrs.fr/pub/mariadb//mariadb-10.4.8/source/mariadb-10.4.8.tar.gz4.解压源码包，并进入源码包目录&emsp;&emsp;xvf mariadb-10.4.8.tar.gz````1&amp;emsp;&amp;emsp;````cd mariadb-10.4.8/l 5.CMAKE编译源码包&emsp;&emsp;需要的依赖包有cmake openssldevel ncurses-devel bison bison-devel zlib-devel libcurl-devel libarchive-devel boostdevel gcc gcc-c++ gnutls-devel libxml2-devel libevent-devel libaio-devel ，一口气yum装上。&emsp;&emsp;install cmake openssldevel ncurses-devel bison bison-devel zlib-devel libcurl-devel libarchive-devel boostdevel gcc gcc-c++ gnutls-devel libxml2-devel libevent-devel libaio-devel ````1然后编译 cmake . -DCMAKE_INSTALL_PREFIX=/data/apps/mysql -DMYSQL_DATADIR=/data/mysql/ -DSYSCONFDIR=/etc/ -DMYSQL_USER=mysql -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DWITHOUT_MROONGA_STORAGE_ENGINE=1 -DWITH_DEBUG=0 -DWITH_READLINE=1 -DWITH_SSL=system -DWITH_ZLIB=system -DWITH_LIBWRAP=0 -DENABLED_LOCAL_INFILE=1 -DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci 126.**安装**&amp;emsp;&amp;emsp;````make -j 4 &amp;&amp; make install 7.创建配置文件,并修改&emsp;&emsp;/etc/mysql/````1&amp;emsp;&amp;emsp;````cp /etc/my.cnf /etc/mysql/my.cnf &emsp;&emsp;-ri '/datadir1&amp;emsp;&amp;emsp;````sed -ri &apos;/datadir/a\innodb_file_per-table=on\nskip_name_resolve=on&apos; /etc/mysql/my.cnf #设置每个表独立文件 和 禁用主机名解析 8.创建数据库文件&emsp;&emsp;-R root:mysqllink1&amp;emsp;&amp;emsp;````/usr/local/scripts/mysql_install_db --datadir=/data/mysql --user=mysql 9.创建服务脚本并启动服务&emsp;&emsp;/data/apps/mysql/support-files/mysql.serverlink1&amp;emsp;&amp;emsp;````chkconfig --add mysqld &emsp;&emsp;mysqld start````1210.**增加PATH环境变量**路径,并生效。&amp;emsp;&amp;emsp;````echo &apos;PATH=/data/apps/mysql/bin:$PATH&apos; &gt;/etc/profile.d/mysql.sh &emsp;&emsp;/etc/profile.d/mysql.sh````1211.**运行安全初始化脚本**，设置root口令、禁用匿名登陆、禁用远程主机登陆、删除test数据库，并立即生效(根据提示操作)。&amp;emsp;&amp;emsp;````/data/apps/mysql/bin/mysql_secure_installation &emsp;&emsp;报错：Can’t connect to local MySQL server through socket ‘/data/mysql/mysql.sock’ (2)&emsp;&emsp;用ll看了下/data/mysql/mysql.sock确实不存在，而我记得我配置文件/etc/mysql/my.cnf中定义的sosck是在 下&emsp;&emsp;那就把/var/lib/mysql/mysql.sock文件创建一个软链接至/data/mysql/目录&emsp;&emsp;-s/data/mysql/````12&amp;emsp;&amp;emsp;再次尝试安全初始化脚本。&amp;emsp;&amp;emsp;````/data/apps/mysql/bin/mysql_secure_installation &emsp;&emsp;果然成功了。&emsp;&emsp;至此，源码编译安装mariadb数据库就完成了~]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编译安装</tag>
        <tag>mysql</tag>
        <tag>mariadb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署自动化安装及cobber(Http+TFTP+PXE+kickstart无人职守批量安装精简版Linux系统)]]></title>
    <url>%2F2019%2F09%2F06%2F%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%E5%8F%8Acobber-Http-TFTP-PXE-kickstart%E6%97%A0%E4%BA%BA%E8%81%8C%E5%AE%88%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85%E7%B2%BE%E7%AE%80%E7%89%88Linux%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为了简化每台服务器的系统的装机过程和统一服务器配置，可以采用一键自动化安装系统的方式，实现新机器接上网线开机便可批量安装相同配置的系统，便于以后统一管理。&emsp;&emsp;想要实现自动化安装系统，&emsp;&emsp;1.搭建dhcp服务器，给新机器网卡分配IP地址，并引导机器去搭建好的tftp站点下载引导程序及内核文件；&emsp;&emsp;2.搭建tftp服务器，提供引导程序及内核文件；复制内核文件至服务器目录；&emsp;&emsp;3.搭建http服务器，提供应答kickstart文件、系统安装包程序的下载；挂载光盘或拷贝安装包至目录文件；&emsp;&emsp;4生成ks应答kickstart文件（放置于ftp服务器中）；&emsp;&emsp;5.复制光盘中的/cdrom/isolinux/isolinux.cfg文件至目录pxelinux.cfg/，改名为pxelinux.cfg/fault文件，即为安装菜单（之后目录pxelinux.cfg/整体放入tftp服务器中）。 &emsp;&emsp;演示环境：CentOS7 Kernel Version: 3.10.0-957.el7.x86_64 本机IP:192.168.32.7 1. 配置DHCP服务器&emsp;&emsp;1.首先安装dhcp服务。install dhcp````1234567&amp;emsp;&amp;emsp;2.启动dhcp服务。但直接启动，会报错，如下图所示，须先修改dhcpd的配置文件。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907104911953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;打开/etc/dhcp/dhcpd.conf配置文件后发现，配置文件是空的，难怪报错，有一行“see /usr/share/doc/dhcpd.conf.example”，原来要我们参考这个模版来自己写配置文件。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907104923202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;于是先复制模版至原配置文件目录。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907104932714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;选择覆盖，再打开配置文件。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907104941287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;修改⑴网段⑵租期时长⑶网关⑷DNS⑸DNS域后缀⑹提供资源下载站点IP⑺需要下载的引导文件![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907104948374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;此时重启DHCP服务成功，查看DHCP服务状态，已经启动（状态信息的提示，是指另一块网卡没有被DHCP服务器网段分配地址，分配一个就足够了，可以无视）。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907110332532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)## 2.搭建tftp服务器&amp;emsp;&amp;emsp;1.首先安装tftp服务端````yum install tftp-server -y &emsp;&emsp;2.生成pxelinux.0引导程序，并放入tftp服务器&emsp;&emsp;&emsp;⑴先确定引导程序所在的安装包；&emsp;&emsp;&emsp;search pxelinux````12&amp;emsp;&amp;emsp;&amp;emsp;⑵安装syslinux.x86_64；&amp;emsp;&amp;emsp;&amp;emsp;````yum install syslinux.x86_64 &emsp;&emsp;&emsp;⑶找到引导程序pxelinux.0的所在路径；&emsp;&emsp;&emsp;-ql syslinux.x86_64|grep pxelinux.0````12&amp;emsp;&amp;emsp;&amp;emsp;⑷将引导程序pxelinux.0及菜单背景模版文件menu.c32拷贝到服务器&amp;emsp;&amp;emsp;&amp;emsp;````cp /usr/share/syslinux/pxelinux.0 /usr/share/syslinux/menu.c32 /var/lib/tftpboot/ &emsp;&emsp;3.将准备好的内核文件和initrd.img文件拷贝到服务器&emsp;&emsp;/cdrom6/isolinux/vmlinuz/var/lib/tftpboot/6/````1&amp;emsp;&amp;emsp;````cp /cdrom7/isolinux/vmlinuz /cdrom7/isolinux/initrd.img /var/lib/tftpboot/7/ &emsp;&emsp;最终效果如下： 3.搭建http服务器&emsp;&emsp;1.首先安装httpd服务端install httpd -y````1&amp;emsp;&amp;emsp;2.启动httpd服务````systemctl start httpd &emsp;&emsp;3.查看httpd服务状态是否启动status httpd````1&amp;emsp;&amp;emsp;4.创建安装包文件目录````mkdir -pv /var/www/html/CentOS/&#123;6,7&#125;/os/x86_64/ &emsp;&emsp;5.挂载光盘安装包至目录或拷贝安装文件至目录&emsp;&emsp;/dev/sr0link1&amp;emsp;&amp;emsp;````mount /dev/sr1 /var/www/html/CentOS/6/os/x86_64/ &emsp;&emsp;效果图如下：&emsp;&emsp;6.挂载光盘安装包至目录或拷贝安装文件至目录 4.生成kickstart应答文件&emsp;&emsp;ks文件的生成一般有两种方法：&emsp;&emsp;①：之前手动安装后系统自动生成的的记录文件/root/anaconda-ks.cfg文件是可以直接复制过来修改使用的。&emsp;&emsp;②：用kickstart工具生成。我们这里采用第二种。执行- Passive，来转发图形化界面）1234567891011121314151617&amp;emsp;&amp;emsp;第一步，选择语言，键盘布局，时区，设置root口令（是否加密存储），安装完成后重启，命令行模式安装；![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907171743550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第二步，选择选择系统安装方式，通过HTTP服务站点安装，输入已经搭好的服务器IP和安装包路径；![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907171805775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第三步，选择安装grub引导安装程序，（先不对grub进行加密了，据说会有加密方式不符的话会有报错），加内核参数net.innames=0实现不更改网卡名称；![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907171813994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第四步，清除原有分区，清除分区标签，设置新分区表；![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907171820601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第五步，设置网卡名eth0，及获取IP方式为DHCP；![在这里插入图片描述](https://img-blog.csdnimg.cn/2019090717182994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第六步，默认关闭SELINUX策略和防火墙；![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907171836698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第七步，选择需要的系统服务；&amp;emsp;&amp;emsp;第八步，附加装机前后脚本；![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907173136895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)&amp;emsp;&amp;emsp;第九步，将ks应答文件复制到http服务器&amp;emsp;&amp;emsp;````mkdir -p /var/www/html/ksdir/;cp ~/centos7-ks.cfg /var/www/html/ksdir/ &emsp;&emsp;（CentOS6的KS同样方式生成）&emsp;&emsp;~/centos6-ks.cfglink1234## 5.创建安装菜单&amp;emsp;&amp;emsp;菜单文件的一般有两种方法：&amp;emsp;&amp;emsp;①：复制修改光盘中的菜单文件/cdrom/isolinux/lisolinux.cfg文件是可以直接复制过来修改使用的。&amp;emsp;&amp;emsp;①：VIM手工输入。 default menu.c32timeout 600menu title Auto Install CentOSlabel linux 7 mennu label Install CentOS^7 menu default kernel 7/vmlinuz append initrd=7/initrd.img ks=http://192.168.32.7/ksdir/centos7-ks.cfglabel linux 6 mennu label Install CentOS^6 kernel 6/vmlinuz append initrd=6/initrd.img ks=http://192.168.32.7/ksdir/centos6-ks.cfglabel linux local mennu label Boot from ^local drive localboot Oxffff ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907192047527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70) &amp;emsp;&amp;emsp;再将菜单文件存入tftp服务器中 **/linux.cfg目录** 下 **重命名**为fault文件。tftp服务器最终目录机构如下图所示： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907192456310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70) &amp;emsp;&amp;emsp;至此，基于PXE网卡，无人职守批量安装CentOS系统的配置就完成了。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cobber</tag>
        <tag>kickstart</tag>
        <tag>pxe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6源码编译 安装linunx内核最新版5.2.9]]></title>
    <url>%2F2019%2F08%2F29%2FCentOS6%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91-%E5%AE%89%E8%A3%85linunx%E5%86%85%E6%A0%B8%E6%9C%80%E6%96%B0%E7%89%885-2-9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前在CentOS7 上源码编译安装过新内核，不过有次在6上编译就遇到问题了，提示错误如下&emsp;&emsp;*** [scripts/sign-file] Error 1 make[1]: *** [scripts] Error 2 make````12搞了好久，好像是参数设置不正确。&amp;emsp;&amp;emsp;````error: #error Sorry, your compiler is too old - please upgrade it &emsp;&emsp;好像是说gcc版本过低。&emsp;&emsp;去epel源找了一下，已经是最新版了啊~&emsp;&emsp;查看了下之前CentOS7的gcc版本，是gcc-4.8.5，再去一查这个CentOS6的gcc版本，是gcc-4.4.7，可能就差在这几个小版本上了。&emsp;&emsp;于是升级gcc版本就成了当务之急。&emsp;&emsp;那就源码编译安装个新版的gcc吧。（后来朋友说可以直接把CentOS7上gcc的rpm包直接拿来用的，未尝试） 编译安装gcc&emsp;&emsp;gcc有三个依赖包gmp、mpfr、mpc,要首先编译安装（虽然原本就有，不过如果编译高版本gcc，这三个依赖包不装新版本的话也会报错）&emsp;&emsp;先去下载好三个依赖包源码包及gcc源码包 1234567mkdir /data/gcc #创建目录/data/gcccd /data/gccwget https://gmplib.org/download/gmp/gmp-6.1.2.tar.xz #下载gmp6.1.2wget http://www.mpfr.org/mpfr-current/mpfr-3.1.5.tar.gz #下载mpfr3.1.5wget ftp://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz #下载mpc1.0.3wget ftp://ftp.gnu.org/gnu/gcc/gcc-6.3.0/gcc-6.3.0.tar.gz #下载gcc6.3.0`` &emsp;&emsp;再挨个编译安装三个依赖包（注意这三个依赖包也有依赖关系，需先安装gmp，再安装mpfr，之后再装mpc） gmp&emsp;&emsp;先来第一个，编译安装装gmp 1234tar -xJf gmp-6.1.2.tar.xz gmp-6.1.2cd gmp-6.1.2./configure --prefix=/usr/local/gcc/gmp --build=x86_64-linuxmake &amp;&amp; make install &emsp;&emsp;这当时有报错&emsp;&emsp;could not find a working compiler```12345&amp;emsp;&amp;emsp;当时没有加参数 --build=x86_64-linux，加上之后成功解决，参考: [原文地址](http://www.voidcn.com/article/p-zsgyngma-ug.html). http://www.voidcn.com/article/p-zsgyngma-ug.html#### mpfr&amp;emsp;&amp;emsp;之后编译安装mpfr` tar -xJf mpfr-3.1.5.tar.xz mpfr-3.1.5cd mpfr-3.1.5./configure –prefix=/usr/local/gcc/mpfr –with-gmp=/usr/local/gcc/gmpmake &amp;&amp; make install 1&amp;emsp;&amp;emsp;然后编译安装mpc tar -xzf mpc-1.0.3.tar.gz mpc-1.0.3cd mpc-1.0.3./configure –prefix=/usr/local/gcc/mpc –with-gmp=/usr/local/gcc/gmp -with-mpfr=/usr/local/gcc/mpfrmake &amp;&amp; make install 12#### gcc&amp;emsp;&amp;emsp;之后也没有报错，那就开始编译安装gcc。 tar xvf gcc-6.3.0.tar.gzcd gcc-6.3.0./configure –prefix=/usr/local/gcc –enable-threads=posix –disable-checking –disable-multilib –enable-languages=c,c++ –with-gmp=/usr/local/gcc/gmp –with-mpfr=/usr/local/gcc/mpfr –with-mpc=/usr/local/gcc/mpcmake &amp;&amp; make install 123&amp;emsp;&amp;emsp;gcc中途有几次报错，不过也都解决了。错误提示[1]：&amp;emsp;&amp;emsp;````make: *** [sub-make] Error 2 &emsp;&emsp;显示这个问题编译不过去。这是因为找不到gmp依赖包导致的，可是我明明装了依赖包的，看来是路径设置有问题，因为当时我是把这三个依赖包都装在gcc下，不过在编译gcc的时候忘记改依赖包的地址了。错误提示[2]：&emsp;&emsp;error: cannot compute suffix of object files: cannot compile````123&amp;emsp;&amp;emsp;解决办法是：&amp;emsp;&amp;emsp;在/etc/profile里面加上以下内容：&amp;emsp;&amp;emsp;````export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gcc/mpc-0.9/lib:/usr/local/gcc/gmp-5.0.1/lib:/usr/local/gcc/mpfr-3.1.0/lib &emsp;&emsp;然后重新加载配置文件/etc/profile&emsp;&emsp;/etc/profile````1234567891011121314151617181920212223242526#### 添加变量&amp;emsp;&amp;emsp;/usr/local/lib &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; #这个是默认系统的变量&amp;emsp;&amp;emsp;/usr/local/gmp/lib&amp;emsp;&amp;emsp;/usr/local/mpfr/lib&amp;emsp;&amp;emsp;/usr/local/mpc/lib&amp;emsp;&amp;emsp;/usr/local/mysql/lib &amp;emsp;&amp;emsp;/usr/local/openssl/lib &amp;emsp; &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;#openssl变量&amp;emsp;&amp;emsp;添加保存后记得更新动态库的缓存：&amp;emsp;&amp;emsp;ldconfig -v#### 备份系统默认的gcc版本```mv /usr/bin/gcc /usr/bin/gcc-bakmv /usr/bin/g++ /usr/bin/g++-bakmv /usr/bin/c++ /usr/bin/c++-bak```#### 建新的gcc软连接```ln -s /usr/local/gcc/bin/gcc /usr/bin/gccln -s /usr/local/gcc/bin/c++ /usr/bin/c++ln -s /usr/local/gcc/bin/g++ /usr/bin/g++ln -s /usr/local/gcc/lib64/libstdc++.so.6.0.22 /usr/lib64/libstdc++.so.6```# 编译安装linux kernel 5.2.9&amp;emsp;&amp;emsp;高高兴兴````cd linux-5.2.9````，进入解压好的内核目录，做好.config配置文件，准备用````make menuconfig````对内核进行自定义配置的时候，报错了：&amp;emsp;&amp;emsp;`````error while loading shared libraries: libmpc.so.3: cannot open shared object file: No such file or directory` &emsp;&emsp;这又是怎么回事。好像是gcc出问题了。返回去检查。&emsp;&emsp;原来添加完库忘了更新动态库&emsp;&emsp;-v`````123~结果还报错：` scripts/kconfig/mconf KconfigYour display is too small to run Menuconfig!It must be at least 19 lines by 80 columns.make[2]: * [menuconfig] Error 1make[1]: * [menuconfig] Error 2make: *** [sub-make] Error 2 1234567这是因为我的XSELL窗口太小了，把XSHELL放大最大化，果然就打开了熟悉的蓝色界面~![在这里插入图片描述](https://img-blog.csdnimg.cn/20190829201133861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70)修改一些个性化的设置（例如改名、加NFS文件系统），就可以保存了。#### 编译内核&amp;emsp;&amp;emsp;因为编译内核时间比较长，为防止发生断网或者断电等意外，我们创建一个SCREEN来编译。&amp;emsp;&amp;emsp;` screen -S linuxkernelyes | make -j 16 12345678910111213141516171819&amp;emsp;&amp;emsp;用一个yes命令省去一直手动y了，等待他编译完成就好了。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;在这又遇到一个报错，贴出来和大家分享下：&amp;emsp;&amp;emsp;`````You are building kernel with non-retpoline compiler.`````&amp;emsp;&amp;emsp;去查了下，网上都说是因为gcc版本过低，或内核版本过高。可我这明显不是gcc版本低的问题（都那么高了），问题是内核版本应该也不是问题，毕竟之前CentOS7编译就没这么多事。正犯愁不知道怎么解决的时候，发现了一篇文章[查看原文](http://tjtech.me/how-to-run-kernel-in-qemu-for-x86_64.html)，发现这个报错可以通过修改参数直接不启用RETPOLINE从而跳过（具体后果未知），于是修改配置文件重新来过：`````make cleansed -ri &apos;s@(CONFIG_RETPOLINE=).*@\1n@&apos; .configmake -j 16`````&amp;emsp;&amp;emsp;果然就顺利编译成功了。&amp;emsp;&amp;emsp;然后安装模块：&amp;emsp;&amp;emsp;`````make modules_ install`````&amp;emsp;&amp;emsp;安装模块的时候，有报错：&amp;emsp;&amp;emsp;````ERROR: modinfo: could not find module *````&amp;emsp;&amp;emsp;不过查了相关文章[查看原文](https://blog.csdn.net/maokexu123/article/details/42554923?locationNum=12)，好像这些模块也都可以正常使用，于是乎无视之~&amp;emsp;&amp;emsp;最后，安装内核相关文件。&amp;emsp;&amp;emsp;``````make install &emsp;&emsp;至此，新内核就装完啦~重启切换去去体验一下！]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编译安装</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环实现的小脚本]]></title>
    <url>%2F2019%2F08%2F22%2Ffor%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B0%8F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;用for循环写了个小脚本，可以输出不同大小的图案，能力有限，输出了一个不太规则的字符图案，希望可以早日写出一个脚本可以自动填充放大任何ASCII图案。&emsp;&emsp;效果图如下：&emsp;&emsp;脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#!/bin/bashread -p &quot;please input the size :&quot; n[ &quot;$n&quot; -ge 0 ] 2&gt;/dev/null || &#123; echo &quot;please input a right num!&quot;;exit 10;&#125;mkdir -p ~/best/bestN=`echo $n-1|bc`J=`echo $N/2+1|bc`K=`echo $N/4+1|bc`L=`echo $N/5|bc`#第一行echo -e &apos;88888\c&apos; &gt;~/best/best.f1for i in $(seq $N);do echo -e &apos;888\c&apos; &gt;&gt;~/best/best.f1donefor i in $(seq $L);do echo -e &apos;88\c&apos; &gt;&gt;~/best/best.f1doneecho &apos;888ba&apos; &gt;&gt;~/best/best.f1#第二行echo -e &apos;8\c&apos; &gt;~/best/best.f2for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f2doneecho -e &apos;8 \c&apos; &gt;&gt;~/best/best.f2for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f2doneecho -e &apos; &quot;8\c&apos; &gt;&gt;~/best/best.f2for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f2doneecho -e &apos;b \c&apos; &gt;&gt;~/best/best.f2for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f2doneecho &apos;,d&apos; &gt;&gt;~/best/best.f2#第三行echo -e &apos;8\c&apos; &gt;~/best/best.f3for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f3doneecho -e &apos;8 \c&apos; &gt;&gt;~/best/best.f3for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f3doneecho -e &apos; &quot;8\c&apos; &gt;&gt;~/best/best.f3for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f3doneecho -e &apos;P \c&apos; &gt;&gt;~/best/best.f3for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f3doneecho &apos;88&apos; &gt;&gt;~/best/best.f3#第四行echo -e &apos;8\c&apos; &gt;~/best/best.f4for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f4doneecho -e &apos;8aaa\c&apos; &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e &apos;aaa\c&apos; &gt;&gt;~/best/best.f4doneecho -e &apos;aaa8\c&apos; &gt;&gt;~/best/best.f4for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f4doneecho -e &apos;P&apos;&quot;&apos;&quot;&apos; ,adP\c&apos; &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e &apos;PP\c&apos; &gt;&gt;~/best/best.f4doneecho -e &apos;PYba, ,adP\c&apos; &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e &apos;PP\c&apos; &gt;&gt;~/best/best.f4doneecho -e &apos;PYba, MM\c&apos; &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e &apos;M\c&apos; &gt;&gt;~/best/best.f4doneecho -e &apos;88MM\c&apos; &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e &apos;M\c&apos; &gt;&gt;~/best/best.f4doneecho &gt;&gt;~/best/best.f4#第五行echo -e &apos;8\c&apos; &gt;~/best/best.f5for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f5doneecho -e &apos;8 \c&apos; &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f5doneecho -e &apos; 8\c&apos; &gt;&gt;~/best/best.f5for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f5doneecho -e &apos;b, a8P \c&apos; &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f5doneecho -e &apos; `8 I8[ \c&apos; &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f5doneecho -e &apos; &quot;&apos;&quot;&apos;&quot;&apos; \c&apos; &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f5doneecho -e &apos; 88&apos; &gt;&gt;~/best/best.f5#第六行echo -e &apos;8\c&apos; &gt;~/best/best.f6for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f6doneecho -e &apos;8 \c&apos; &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f6doneecho -e &apos; `8\c&apos; &gt;&gt;~/best/best.f6for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f6doneecho -e &apos;b 8PP&quot;&quot;\c&apos; &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e &apos;&quot;&quot;\c&apos; &gt;&gt;~/best/best.f6doneecho -e &apos;&quot;&quot;&quot;`&apos;&quot;&apos;&quot;&apos; `&quot;Y8\c&apos; &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e &apos;88\c&apos; &gt;&gt;~/best/best.f6doneecho -e &apos;ba, \c&apos; &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f6doneecho -e &apos; 88\c&apos; &gt;&gt;~/best/best.f6echo &gt;&gt;~/best/best.f6#第七行echo -e &apos;8\c&apos; &gt;~/best/best.f7for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f7doneecho -e &apos;8 \c&apos; &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f7doneecho -e &apos; a8\c&apos; &gt;&gt;~/best/best.f7for i in $(seq $L);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f7doneecho -e &apos;P &quot;8b, \c&apos; &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f7doneecho -e &apos; ,aa aa \c&apos; &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f7doneecho -e &apos; ]8I \c&apos; &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f7doneecho -e &apos; 88,&apos; &gt;&gt;~/best/best.f7#第八行echo -e &apos;88888\c&apos; &gt;~/best/best.f8for i in $(seq $N);do echo -e &apos;888\c&apos; &gt;&gt;~/best/best.f8donefor i in $(seq $L);do echo -e &apos;88\c&apos; &gt;&gt;~/best/best.f8doneecho -e &apos;888P&quot; `&quot;Ybb\c&apos; &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e &apos;oo\c&apos; &gt;&gt;~/best/best.f8doneecho -e &apos;d8&quot;&apos;&quot;&apos;&quot;&apos; `&quot;Ybb\c&apos; &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e &apos;oo\c&apos; &gt;&gt;~/best/best.f8doneecho -e &apos;dP&quot;&apos;&quot;&apos;&quot;&apos; \c&apos; &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e &apos; \c&apos; &gt;&gt;~/best/best.f8doneecho -e &apos; &quot;Y888\c&apos; &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e &apos;8\c&apos; &gt;&gt;~/best/best.f8doneecho &gt;&gt;~/best/best.f8for j in $(seq $K);do cat ~/best/best.f1donefor j in $(seq $J);do cat ~/best/best.f2donefor j in $(seq $J);do cat ~/best/best.f3donefor j in $(seq $K);do cat ~/best/best.f4donefor j in $(seq $J);do cat ~/best/best.f5donefor j in $(seq $K);do cat ~/best/best.f6donefor j in $(seq $J);do cat ~/best/best.f7donefor j in $(seq $K);do cat ~/best/best.f8done\rm -rf ~/best/best &emsp;&emsp;脚本写的太复杂，可读性太差，等日后水平提升再来改进，留存！]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7磁盘分区及文件系统]]></title>
    <url>%2F2019%2F08%2F14%2FCentOS7%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一般来说，硬盘上的空间，想要被我们利用，都要经过几个步骤： 1设备识别 2磁盘分区 3创建文件系统（并标记文件系统） 4挂载新的文件系统 5在/etc/fstab文件中创建新条目&emsp; &emsp;&emsp;只有当设备被挂载到文件系统中，才可以被我们访问且使用。&emsp; 1 设备识别 新插入硬盘设备，没法被系统立马识别到，需要手动扫描，才可以发现并识别新设备echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan/sys/class/scsi_host/ 目录下面有几个host 就扫描几次。&emsp;&emsp; 2 磁盘分区2.1为什么要分区 优化I/O性能 实现磁盘空间配额限制 提高修复速度 隔离系统和程序 安装多个OS 采用不同文件系统&emsp; 2.2分区方式&emsp;&emsp;一般来说有两种分区方式 ：MBR和GPT。 MBR：全程Master Boot Record，1982年，使用32位表示扇区，单个分区不超过2T。 如何分区：按柱面 0磁道0扇面：512bytes&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;446byets：boot loader&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;64bytes ： 分区表，其中每16bytes标识一个分区&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2byetes&emsp;：55AA MBR分区中一块硬盘最多有4个主分区，也可以三主分区+1拓展（N个逻辑分区）&emsp; MBR分区结构 MBR分区表&emsp;&emsp;硬盘主导记录MBR由4个部分组成 主引导程序（偏移地址0000H–0088H），它负责从活动分区中装载，并运行系统引导程序 出错信息数据区，偏移地址0089H-00E1H为出错信息，00E2H-01BDH全为0字节 分区表（DPT,Disk Partition Table）含4个分区项，偏移地址01BEH–01FDH，每个分区表长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4 结束标志字，偏移地址01FE–01FF的2个字节值为结束标志55AA&emsp; GPT：GUID（Globals Unique Identifiers） partition table 支持128个分区，使用64位，支持8Z（ 512Byte/block ）64Z （ 4096Byte/block） 使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区表自动备份在头和尾两份，并有CRC校验位 UEFI (Unified Extensible Firmware Interface 统一可扩展固件接口)硬件支持GPT，使操作系统启动&emsp; GPT分区结构 2.3管理分区 2.31列出块设备 2.32创建新分区&emsp;&emsp;parted命令：parted [选项]… [设备 [命令 [参数]…]…]&emsp;&emsp;parted /dev/sdb mklabel gpt|msdos&emsp;&emsp;parted /dev/sdb print&emsp;&emsp;parted /dev/sdb mkpart primary 1 200 （默认M）&emsp;&emsp;parted /dev/sdb rm 1&emsp;&emsp;parted –l 列出分区信息 parted的操作都是实时生效的，小心使用&emsp;&emsp;&emsp; fdisk -l [-u] [device…] 查看分区&emsp;&emsp; fdisk /dev/sdb 管理分区 子命令：&emsp;&emsp;&emsp;&emsp;&emsp;p 查看分区列表&emsp;&emsp;&emsp;&emsp;&emsp;t 更改分区类型&emsp;&emsp;&emsp;&emsp;&emsp;n 创建新分区&emsp;&emsp;&emsp;&emsp;&emsp;d 删除分区&emsp;&emsp;&emsp;&emsp;&emsp;v 校验分区&emsp;&emsp;&emsp;&emsp;&emsp;u 转换单位&emsp;&emsp;&emsp;&emsp;&emsp;w 保存并退出&emsp;&emsp;&emsp;&emsp;&emsp;q 不保存并退出&emsp;gdisk命令与fdisk用法相同，用于创建GPT分区。 2.33同步内核与硬盘的分区表查看内核是否已经识别新的分区cat /proc/partations centos6通知内核重新读取硬盘分区表新增分区用partx -a /dev/DEVICEkpartx -a /dev/DEVICE -f: force删除分区用partx -d –nr M-N /dev/DEVICECentOS 5，7: 使用partprobepartprobe [/dev/DEVICE] 3 创建文件系统3.1文件系统&emsp;&emsp;文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，安全控制，日志，压缩，加密等&emsp;&emsp;&emsp;支持的文件系统：/lib/modules/`uname –r`/kernel/fs&emsp;&emsp;&emsp;各种文件系统：https://en.wikipedia.org/wiki/Comparison_of_file_systems 3.11文件系统类型Linux文件系统：&emsp;&emsp;ext2(Extended file system)：适用于那些分区容量不是太大，更新也不频繁的情况，例如 /boot 分区&emsp;&emsp;ext3：是 ext2 的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中恢复。它通常被用作通用的文件系统&emsp;&emsp;ext4：是 ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件(16TB)、最大1EB的文件系统，以及速度的提升&emsp;&emsp;xfs：SGI，支持最大8EB的文件系统&emsp;&emsp;btrfs（Oracle）, reiserfs, jfs（AIX）, swap光盘：iso9660Windows：FAT32, NTFS，exFATUnix：FFS（fast）, UFS（unix）, JFS2网络文件系统：NFS, CIFS集群文件系统：GFS2, OCFS2（oracle）分布式文件系统：fastdfs,ceph, moosefs, mogilefs, glusterfs, LustreRAW：未经处理或者未经格式化产生的文件系统 3.12文件系统分类根据其是否支持”journal”功能：&emsp;&emsp;日志型文件系统: ext3, ext4, xfs, …&emsp;&emsp;非日志型文件系统: ext2, vfat文件系统的组成部分：&emsp;&emsp;内核中的模块：ext4, xfs, vfat&emsp;&emsp;用户空间的管理工具：mkfs.ext4, mkfs.xfs,mkfs.vfatLinux的虚拟文件系统：VFS 查前支持的文件系统：cat /proc/filesystems查前目前的文件系统：lsblk -f 3.2创建文件系统mkfs命令：(1) mkfs.FS_TYPE /dev/DEVICE&emsp;&emsp;&emsp;&emsp;ext4&emsp;&emsp;&emsp;&emsp;xfs&emsp;&emsp;&emsp;&emsp;btrfs&emsp;&emsp;&emsp;&emsp;vfat(2) mkfs -t FS_TYPE /dev/DEVICE&emsp;&emsp;&emsp;&emsp;-L ‘LABEL’ 设定卷标&emsp;mke2fs命令：ext系列文件系统专用管理工具&emsp;&emsp;&emsp;-t {ext2|ext3|ext4} 指定文件系统类型&emsp;&emsp;&emsp;-b {1024|2048|4096} 指定块大小&emsp;&emsp;&emsp;-L ‘LABEL’ 设置卷标&emsp;&emsp;&emsp;-j 相当于 -t ext3 (mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3)`&emsp;&emsp;&emsp;-i # 为数据空间中每多少个字节创建一个inode；不应该小于block大小&emsp;&emsp;&emsp;-N # 指定分区中创建多少个inode&emsp;&emsp;&emsp;-I 一个inode记录占用的磁盘空间大小，128—4096&emsp;&emsp;&emsp;-m # 默认5%,为管理人员预留空间占总空间的百分比&emsp;&emsp;&emsp;-O FEATURE[,…] 启用指定特性&emsp;&emsp;&emsp;-O ^FEATURE 关闭指定特性 3.3文件系统标签文件系统标签是指向设备的另一种方法。与设备无关blkid：块设备属性信息查看blkid [OPTION]… [DEVICE]&emsp;&emsp;&emsp;-U UUID 根据指定的UUID来查找对应的设备&emsp;&emsp;&emsp;-L LABEL 根据指定的LABEL来查找对应的设备e2label：管理ext系列文件系统的LABELe2label DEVICE [LABEL]findfs ：查找分区findfs [options] LABEL= &lt; label &gt;findfs [options] UUID= &lt; uuid &gt; 3.4文件系统检测和修复文件系统夹故障常发生于死机或者非正常关机之后，挂载为文件系统标记为“no clean” 注意：一定不要在挂载状态下执行下面命令修复 fsck: File System Check&emsp;&emsp;fsck.FS_TYPE&emsp;&emsp;fsck -t FS_TYPE注意：FS_TYPE 一定要与分区上已经文件类型相同-a 自动修复-r 交互式修复错误 e2fsck：ext系列文件专用的检测修复工具-y 自动回答为yes-f 强制修复-p 自动进行安全的修复文件系统问题xfs_repair：xfs文件系统专用检测修复工具-f 修复文件，而设备-n 只检查-d 允许修复只读的挂载设备，在单用户下修复 / 时使用，然后立即reboot 4 挂载新的文件系统挂载： 将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为卸载： 为解除此关联关系的过程把设备关联挂载点：mount Point&emsp;&emsp;mount 设备名 挂载点卸载时：可使用设备，也可以使用挂载点&emsp;&emsp;umount 设备名|挂载点PS：挂载点下原有文件在挂载完成后会被临时隐藏&emsp;&emsp; 挂载点目录一般为空 4.1用mount命令挂载文件系统挂载方法：mount DEVICE MOUNT_POINT&emsp;&emsp;mount：通过查看/etc/mtab文件显示当前已挂载的所有设备&emsp;&emsp;mount [-fnrsvw] [-t vfstype] [-o options] device dirdevice：指明要挂载的设备；&emsp;&emsp;(1) 设备文件：例如/dev/sda5&emsp;&emsp;(2) 卷标：-L ‘LABEL’, 例如 -L ‘MYDATA’&emsp;&emsp;(3) UUID, -U ‘UUID’：例如 -U ‘0c50523c-43f1-45e7-85c0-a126711d406e’&emsp;&emsp;(4) 伪文件系统名称：proc, sysfs, devtmpfs, configfsdir：挂载点需事先存在，建议使用空目录；进程正在使用中的设备无法被卸载。mount常用命令选项&emsp;&emsp;-t vsftype 指定要挂载的设备上的文件系统类型&emsp;&emsp;-r readonly，只读挂载&emsp;&emsp;-w read and write, 读写挂载&emsp;&emsp;-n 不更新/etc/mtab，mount不可见&emsp;&emsp;-a 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中，且挂载选项中有auto功能)&emsp;&emsp;-L ‘LABEL’ 以卷标指定挂载设备&emsp;&emsp;-U ‘UUID’ 以UUID指定要挂载的设备&emsp;&emsp;-B, –bind 绑定目录到另一个目录上&emsp;&emsp;查看内核追踪到的已挂载的所有设备：cat /proc/mounts &emsp;&emsp;-o options：(挂载文件系统的选项)，多个选项使用逗号分隔&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;async 异步模式 sync 同步模式,内存更改时，同时写磁盘&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;包含目录和文件&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;diratime/nodiratime 目录的访问时间戳&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;auto/noauto 是否支持自动挂载,是否支持-a选项&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;exec/noexec 是否支持将文件系统上运行应用程序&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dev/nodev 是否支持在此文件系统上使用设备文件&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;suid/nosuid 是否支持suid和sgid权限&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;remount 重新挂载&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ro 只读 rw 读写&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;user/nouser 是否允许普通用户挂载此设备，/etc/fstab使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;acl 启用此文件系统上的acl功能&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;loop 使用loop设备&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;_netdev 当网络可用时才对网络资源进行挂载，如：NFS文件系统&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;defaults 相当于rw, suid, dev, exec, auto, nouser, async 4.2卸载命令查看挂载情况&emsp;&emsp;findmnt MOUNT_POINT|device查看正在访问指定文件系统的进程&emsp;&emsp;lsof MOUNT_POINT&emsp;&emsp;fuser -v MOUNT_POINT终止所有在正访问指定的文件系统的进程&emsp;&emsp;fuser -km MOUNT_POINT卸载&emsp;&emsp;umount DEVICE&emsp;&emsp;umount MOUNT_POINT 5 修改/etc/fstab配置文件&emsp;&emsp;使用mount命令挂载设备都是临时挂载，每次开机后需要手动重新挂载，比较费时费力，如果需要实现自动挂载，就要修改文件系统挂载配置文件/etc/fstab文件。/etc/fstab文件 下面的每行定义一个要挂载的文件系统&emsp;&emsp;总共六列，分别对应设备、挂载点、文件系统类型、挂载选项、转储频率及是否自检。 1、要挂载的设备或伪文件系统设备文件LABEL：LABEL=””UUID：UUID=””伪文件系统名称：proc, sysfs 2、挂载点 一般为某文件或目录 3、文件系统类型：ext4，xfs，iso9660，nfs，none 4、挂载选项：defaults（包括rw suidi dev exac auto nouser async） ，acl，bind 5、转储频率：0：不做备份 1：每天转储 2：每隔一天转储 6、fsck检查的文件系统的顺序：允许的数字是0 1 2&emsp;&emsp;0：不自检&emsp;&emsp;1：首先自检；一般只有rootfs才用&emsp;&emsp;2：非rootfs使用&emsp;&emsp;可以使用cat 、echo 等命令 将这6个信息 追加至/etc/fstab文件中，也可以用sed 命令 。 &emsp;&emsp;使用mount -a 命令可以立即挂载/etc/fstab中的所有文件系统]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的一键个性化系统脚本]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%88%91%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%AA%E6%80%A7%E5%8C%96%E7%B3%BB%E7%BB%9F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;经常要把虚拟机上的系统搞崩，总是各种报错，有次yum安装gcc程序都报错，一旦折腾半天解决不了，只好选择最笨却最有效的方法——还原vrm虚拟机的快照！可是还原快照到干净系统，就导致之前做的喜欢的配置又都没了 还要去慢慢设置开机图案、别名以及各种环境变量比较麻烦，于是就费了点时间，写了下面这个脚本，每次都可以一键实现让新系统恢复自己当初个性化的各种设置。&emsp;&emsp;先传效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#!/bin/bashread -p &quot;please input a name for the address:&quot; USERDIR#输入用户名，方便在/etc目录下存放生成的配置文件[ -a /etc/$USERDIR ] &amp;&amp; [ -d /etc/$USERDIR ] ||&#123; \rm -rf /etc/$USERDIR; mkdir /etc/$USERDIR; &#125;#mkdir /etc/$USERDIR#生成配置文件目录，若已存在则直接使用此目录cat &gt; /etc/$USERDIR/motd &lt;&lt; ENDoooooooooooo oooooooooo. ooooooooooooo oooo oooooooooo. . 8&apos; 888 &apos;8 &apos;888&apos; &apos;Y8b 8&apos; 888 &apos;8 &apos;888 &apos;888&apos; &apos;Y8b .o8 888 &apos;ooooo. 888 888 .ooooo. 888 888 .oo. .ooooo. 888 888 .ooooo. .oooo.o .o888oo 888 d88&apos; &apos;88b 888oooo888&apos; d88&apos; &apos;88b 888 888P&quot;Y88b d88&apos; &apos;88b 888oooo888&apos; d88&apos; &apos;88b d88( &quot;8 888 888 888 888 888 &apos;88b 888ooo888 888 888 888 888ooo888 888 &apos;88b 888ooo888 &apos;&quot;Y88b. 888 888 888 888 888 .88P 888 .o 888 888 888 888 .o 888 .88P 888 .o o. )88b 888 . o888o &apos;Y8bod8P&apos; o888bood8P&apos; &apos;Y8bod8P&apos; o888o o888o o888o &apos;Y8bod8P&apos; o888bood8P&apos; &apos;Y8bod8P&apos; 8&quot;&apos;888P&apos; &quot;888&quot;END#生成开机欢迎动画，可以随意修改#创建/etc/$USERDIR/login.sh配置文件[ -a /etc/$USERDIR ] &amp;&amp; [ -d /etc/$USERDIR ]&amp;&amp; [ -w /etc/$USERDIR ] ||&#123; \rm -rf /etc/$USERDIR; mkdir /etc/$USERDIR; &#125;#确认文件目录存在且可用,开始写配置文件。#因为水平有限，不知道怎么把命令以及变量通过脚本生成到新脚本里#只能采用最笨的方法——一行一行的写入，希望各位大佬可以指点一二。echo &apos;#!/bin/bash &apos;&gt;/etc/$USERDIR/login.shecho &apos;cat /etc/$USERDIR/motd&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;date=`date &quot;+%F %T&quot;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;head=&quot;System information as of: $date&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;kernel=`uname -r`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;hostname=`echo $HOSTNAME`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Cpu load&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load1=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $1&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load5=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load15=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $3&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#System uptime&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;uptime=`cat /proc/uptime | cut -f1 -d.`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upDays=$((uptime/60/60/24))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upHours=$((uptime/60/60%24))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upMins=$((uptime/60%60))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upSecs=$((uptime%60))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;up_lastime=`date -d &quot;$(awk -F. &apos;&quot;&apos;&quot;&apos;&#123;print $1&#125;&apos;&quot;&apos;&quot;&apos; /proc/uptime) second ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Memory Usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;mem_usage=`free -m | awk &apos;&quot;&apos;&quot;&apos;/Mem:/&#123;total=$2&#125; /buffers\/cache/ &#123;used=$3&#125; END &#123;printf(&quot;%3.2f%%&quot;,used/total*100)&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;swap_usage=`free -m | awk &apos;&quot;&apos;&quot;&apos;/Swap/&#123;printf &quot;%.2f%&quot;,$3/$2*100&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Processes&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;processes=`ps aux | wc -l`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#User&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;users=`users | wc -w`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;USER=`whoami`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#System fs usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;Filesystem=$(df -h | awk &apos;&quot;&apos;&quot;&apos;/^\/dev/&#123;print $6&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Interfaces&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;INTERFACES=$(ip -4 ad | grep &apos;&quot;&apos;&quot;&apos;state &apos;&quot;&apos;&quot;&apos; | awk -F&quot;:&quot; &apos;&quot;&apos;&quot;&apos;!/^[0-9]*: ?lo/ &#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;|grep e)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;$head&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;----------------------------------------------&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Kernel Version:\t%s\n&quot; $kernel&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;HostName:\t%s\n&quot; $hostname&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;System Load:\t%s %s %s\n&quot; $load1, $load5, $load15&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;System Uptime:\t%s &quot;days&quot; %s &quot;hours&quot; %s &quot;min&quot; %s &quot;sec&quot;\n&quot; $upDays $upHours $upMins $upSecs&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Memory Usage:\t%s\t\t\tSwap Usage:\t%s\n&quot; $mem_usage $swap_usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Login Users:\t%s\t\t\tWhoami:\t\t%s\n&quot; $users $USER&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Processes:\t%s\n&quot; $processes&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Filesystem\tUsage\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;for f in $Filesystem&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;do&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; Usage=$(df -h | awk &apos;&quot;&apos;&quot;&apos;&#123;if($NF==&quot;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;$f&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&quot;) print $5&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; echo -e &quot;$f\t\t$Usage&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;done&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Interface\tMAC Address\t\tIP Address\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;for i in $INTERFACES&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;do&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; MAC=$(ip ad show dev $i | grep &quot;link/ether&quot; | awk &apos;&quot;&apos;&quot;&apos;&#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; IP=$(ip ad show dev $i | awk &apos;&quot;&apos;&quot;&apos;/inet / &#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; printf $i&quot;\t\t&quot;$MAC&quot;\t$IP\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;done&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo&apos;&gt;&gt;/etc/$USERDIR/login.sh#生成脚本设置常用命令符以及别名及命令历史cat &gt; /etc/profile.d/env.sh &lt;&lt; ENDPS1=&quot;\e[1;36m[\u@\h \W]\\\\$\e[0m&quot;HISTTIMEFORMAT=&quot;%F %T &quot;HISTCONTROL=ignorebothalias rm=&apos;mkdir -p /date/delete/`date +%F`;\mv -t /date/delete/`date +%F` -f&apos;bash /etc/$USERDIR/login.shENDsed -i &apos;s/^alias rm/#&amp;/&apos; ~/.bashrc#取消用户定义的alias rm。#生成VIM的格式脚本cat &gt; ~/.vimrc &lt;&lt; END#!/bin/bash&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle()&quot;&quot;如果文件类型为.sh文件 if &amp;filetype == &apos;sh&apos; call setline(1,&quot;\##########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1,&quot;\# Author: Name &quot;) call append(line(&quot;.&quot;)+2,&quot;\# QQ: xxxxxxxxx&quot;) call append(line(&quot;.&quot;)+3,&quot;\# mail: xxxxxxxxxx@xxx.com&quot;) call append(line(&quot;.&quot;)+4,&quot;\# Description: The test script&quot;) call append(line(&quot;.&quot;)+5,&quot;\# Created Time: &quot;.strftime(&quot;%F %H:%M:%S&quot;)) call append(line(&quot;.&quot;)+6,&quot;\# Copyright（C）: &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;) call append(line(&quot;.&quot;)+7,&quot;\##########################################################################&quot;) call append(line(&quot;.&quot;)+8,&quot;\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+9,&quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot; &gt; Author: Name&quot;) call append(line(&quot;.&quot;)+2, &quot; &gt; Mail: xxxxxxxxxx@xxx.com&quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;)endif if &amp;filetype == &apos;cpp&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+8, &quot;&quot;)endif if &amp;filetype == &apos;c&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;)endif if &amp;filetype == &apos;java&apos; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+7,&quot;&quot;)endif&quot;&quot;新建文件后，自动定位到文件末尾endfuncautocmd BufNewFile * normal GENDmkdir -p /etc/yum.repos.d/backup\mv -f /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup/#禁用已有其他epel源，并做备份。umount /dev/cdrom#[ `cat /etc/fstab|grep -o iso` ]||sed -i &apos;/iso/c\&apos; /etc/fstab #解挂其他光盘CDUUID=`blkid|sed -nr &apos;/sr0/s/.*\bUUID=&quot;([^&quot;]+).*&quot;/\1/p&apos;`CDTYPE=`blkid|sed -nr &apos;/sr0/s/.*\bTYPE=&quot;([^&quot;]+).*&quot;/\1/p&apos;`[ `cat /etc/fstab|grep -o iso` ]||mkdir -p /cdrom #创建光盘目录[ `cat /etc/fstab|grep -o iso` ]||echo -e &quot;UUID=$CDUUID /cdrom $CDTYPE defaults 0 0&quot; &gt;&gt;/etc/fstab #修改fstab文件，方便以后自动挂载光盘#[ `cat /etc/fstab|grep -o iso` ]|| mount -o ro /dev/sr0 /cdrom #挂载光盘#mount -a #挂载光盘mount -o ro /dev/sr0 /cdrom #挂载光盘#生成常用yum源和epel源，这里选用阿里云的cat &gt; /etc/yum.repos.d/cdrom.repo &lt;&lt; END[cdrom]name=cdrom-repobaseurl=file:///cdromgpgcheck=0enabled=1ENDcat &gt; /etc/yum.repos.d/aliyun.repo &lt;&lt; &quot;END&quot;[aliyun]name=aliyun-epelbaseurl=https://mirrors.aliyun.com/epel/$releasever/$basearch/gpgcheck=1gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-7enabled=1END#新建本地及阿里云epel源.#修改网卡配置，根据个人情况修改cat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; ENDTYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=29126291-418f-4a08-b33e-c5cfa659d9b8DEVICE=ens33ONBOOT=yesIPADDR=172.18.32.7PREFIX=16GATEWAY=172.18.0.1DNS1=114.114.114.114ENDsystemctl restart network.service#重启网络服务，让刚才修改的配置生效mkdir -p /date/apps[ -z `cat ~/.bash_profile|grep apps` ] &amp;&amp; echo &apos;PATH=/date/apps:$PATH&apos; &gt;&gt;~/.bash_profile#修改PAT变量，方便以后装软件。`` &emsp;&emsp;水平有限，都是简单代码，留存记录，方便日后查看整理改进。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>script</tag>
        <tag>init</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由闷骚书生与假正经小姐的古典爱情故事说起]]></title>
    <url>%2F2019%2F08%2F01%2F%E7%94%B1%E9%97%B7%E9%AA%9A%E4%B9%A6%E7%94%9F%E4%B8%8E%E5%81%87%E6%AD%A3%E7%BB%8F%E5%B0%8F%E5%A7%90%E7%9A%84%E5%8F%A4%E5%85%B8%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;城南外湖畔边，天气下着小雨，刮起微风，吹起茶铺门前的风铃叮铃作响让人昏昏欲睡，但铺子里舒缓轻柔的抚琴声却给人自然清醒的感觉，立锥之地，瞥一眼便一览无遗，简单的陈设透露出古朴淡雅，一长发清秀女子品一壶热茶望着这淅淅沥沥的小雨。&emsp;&emsp;“姑娘有心事？”一身穿白袍英俊书生抿嘴品茶问到。少女：“公子与城北唐公子可是熟识？” &emsp;&emsp;“书生：“我与他乃世交，有何事？”少女：“那下次你与他一同前来我这品茶可好？”书生：“他不喜品茶。”少女：“无妨，那公子可知他喜欢什么，我可以慢慢学。”书生：“我其实也不喜品茶。”少女：“公子莫说谎，不喜为何天天早晨都跑我这茶铺。” &emsp;&emsp;“书生撒下铜钱置于木桌上起身离开，未曾回答。少女见状只心生奇怪，也未曾再问，便转身，从容煎茶。&emsp;&emsp;“书生一路默不作声回到家中书房，文房四宝安静置于桌上，拿起笔挥出：小生不才，未得姑娘青睐，扰姑娘良久，姑娘勿怪，自此所有爱慕之意止于唇齿，匿与年华。饮完这杯酒，还有一杯，就此别过，愿你此生无波澜，敬我余生无悲欢。 &emsp;&emsp;“谁又懂书生的心意？但凡经历过那种暗恋相思之苦，才会理解。 &emsp;&emsp;“他生莫作有情痴，人间无地著相思。下辈子不要做个多情的人，在人世间的相思之苦是难以承受的。&emsp;&emsp;我们都曾经为一个得不到的人付出过，心酸过，伤神过。那种滋味充满着酸甜苦辣，叫做喜欢过你的感觉。 &emsp;&emsp;喜欢一个的人时候，我们每时每刻都会翻看ta的每一条朋友圈动态，也总会把自己给带进去，想看看是不是在说自己，就好像你在做阅读理解一样，做完这些题目后，才发现不是为你准备的。 &emsp;&emsp;Ta为你点个赞，你可以开心到不行，小鹿乱撞。什么啊，为什么就给我点赞，ta也喜欢我吗？Ta为什么不跟我表白？Ta这是暗示我要去表白吗？戏精这个词在我们身上表现的淋漓尽致，永远都不会想到是不是别人手滑点赞，因为我们接受不了这个事实。&emsp;&emsp;天天傻傻地期盼他心血来潮的问候一句，然后装作平淡和缓不慌不忙的应答，其实心里能开心一整天。要是没有秒回我的信息，我会觉得自卑，会觉得ta不喜欢跟我这样的人聊天。我曾经发了句晚安给ta，一晚上醒来七次看手机信息。就是那种可怕的朦朦胧胧的意识，梦里都梦到ta好像回了我信息，然后意识带我从梦境里挣扎出来立马去翻看手机。你看，这大概就是喜欢深入骨髓，竟连梦境都不愿放过了吧。 &emsp;&emsp;看到ta跟其他人走得近玩的好开心时心里酸的要命，却发现自己根本没有吃醋的立场。Ta对你说过的每一句都有认认真真记在心里，反复琢磨，却不敢表现出来。偶遇的时候心里高兴得飞了出来，却只能冷静的压抑，给ta一个体面的招呼,我们太过卑微的去追求我认为的爱情，没有去想结果怎样。&emsp;&emsp;而事实是这样的结果就像一场游戏，你拼命练到满级，可ta却不知何时会删了游戏。 &emsp;&emsp;但暗恋这种感情模式和对方其实关系并不大，更多是自我感动。和真爱没有什么关系，不管付出再多，忍受的再多，也不会有人看见，一个人的独角戏确实很累，你也会变得越来越不像自己，真爱是建立在双方对彼此深入了解的基础上的。 &emsp;&emsp;《大话西游》里有一幕：孙悟空与紫霞仙子在围墙上无言告别，围墙下围着一大帮吃瓜群众看戏，曾经我们的喜欢，会让自己误以为是孙悟空或者是至尊宝，其实都不是，我们终究成了围墙下的那帮人，看着别人的爱情，咀嚼着自己的青春。&emsp;&emsp;不知不觉，时间过了很久，我们已经渐渐明白在机场里等船是不会有结果的，有些人我们也不必再等。换个角度看，彼此幸福或许才是最好的结局，未曾拥有的不是遗憾，相反却是青春的美好。 &emsp;&emsp;哪一天你回过头看，微笑着对自己说道：那个人，我曾经喜欢过，很喜欢的那种。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;转载自豆瓣情感私塾&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动备份配置文件脚本（screen后台执行）]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%EF%BC%88screen%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux中配置文件很多，各种需要设置的各种参数很多，有些自定义选项为了方便使用，都会自己修改使用，不过有时候配置文件或者用户参数属性不小心误删掉或者日后想找回当时的参数设置，没有备份肯定是不行的，所以闲暇之余自己写了一个专门备份/etc目录的脚本，以备不时之需。&emsp;&emsp;下面贴代码~ 12345678910111213141516#!/bin/bashecho &quot;Backup is start!&quot; #显示备份开始ScreenName=$&quot;backup&quot; #设置变量定义窗口名screen -dmS $ScreenName #创建一个出于断开模式下的窗口并指定名字screen -S $ScreenName -p 0 -X stuff $&quot;\cp -ap /etc /date/back`date +%F`&quot; #向窗口传递命令备份/etc目录且命名为当前日期screen -S $ScreenName -p 0 -X stuff $&apos;\n&apos; #执行命令，相当于回车echo &quot;backing up，please wait~&quot; #等待备份完成，并提示等待screen -S $ScreenName -p 0 -X stuff $&apos;exit&apos; #备份完后传递退出窗口命令screen -S $ScreenName -p 0 -X stuff $&apos;\n&apos; #执行命令echo &quot;Backup is finshed!&quot; #提示备份完成，脚本结束。 &emsp;&emsp;之前写的脚本总是在创建完screen就停住了，之后的命令没法自动执行，必须Ctrl+A+D暂离screen之后才可以继续执行，不过这样就没法实现自动的初衷了。后来转换思路打算用screen -X的选项从原shell向screen中传递命令却总是失败，后来是参考了大神关于screen传递命令的方法（原文链接），才创建成功的。&emsp;&emsp;此脚本原理大体如下：&emsp;&emsp;脚本中执行screen命令，相当于打开了新的shell，而脚本上的命令都在老shell上，要让备份cp命令在screen上的新shell上跑起来，必须采用向新screen传递命令的方法，才可以实现后台备份，无需担心断网断电的问题。 -S $ScreenName -p 0 -X stuff $'cp -ap/date/back`date +%F`'```12&amp;emsp;&amp;emsp;这条命令单独执行，只会传递在screen中输出cp命令却并不执行，需要```screen -S $ScreenName -p 0 -X stuff $&apos;\n&apos; &emsp;&emsp;命令执行时cp命令才会生效。exit命令亦是如此。&emsp;&emsp;各位大佬如果还有别的更好的方法可以实现功能，希望可以多多交流，不吝赐教。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>script</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM编辑器的整理总结]]></title>
    <url>%2F2019%2F07%2F25%2FVIM%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;VIM是linux中功能强大的文本编辑工具，因为功能强大，所以各种参数快捷键也很复杂，为方便记忆，特整理如下：vim命令基本格式与参数 vim [OPTION] FILE 常见参数： +# :打开文件后，让光标处于第#行，(+ 默认为行尾)。 +/PATTERN :打开文件后，让光标处于第一个被PATTERN匹配到的行的行首。 -b file :以二进制方式打开文件。 -d file1/file2 :比较多个文件的不同。 -m file :以只读方式打开文件。 -e file 或 ex file :直接进入ex模式（扩展命令模式或叫做末行模式）。 vim的几种工作模式 command模式下的光标跳转：字符间跳转：h 左；j下；k 上；l 右。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#command 可以执行#次命令。单词间跳转：w：下一个单词的词首；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e：当前或下一个单词的词尾。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b：当前或前一个单词的词首。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#command 可以执行#次命令。当前页跳转：H：跳转至页首。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;M：跳转至页中间行。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;L：跳转至页底。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zt：将光别所在行移到屏幕顶端；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zz：将光标所在行移到屏幕中间；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zb：将光标所在行移到屏幕低端。行首行尾跳转：^:跳转至行首的第一个非空的字符；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;0:跳转至行首；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$:跳转至行尾。行间移动：#G :移动至第#行行首。（相当于扩展命令模式下 #）&emsp;&emsp;&emsp;&emsp;&emsp; G ：移至最后一行行首。&emsp;&emsp;&emsp;1G 或gg:移至第一行行首。句间移动 : ) : 下一句；&emsp;&emsp;&emsp;&emsp;&emsp;( : 上一句。段间移动 : } : 下一段；&emsp;&emsp;&emsp;&emsp;&emsp;{ : 上一段。翻屏操作：Ctrl+f 向文件尾部翻一屏（向前翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+b 向文件首部翻一屏（向后翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+d 向文件尾部翻半屏（向下翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+u 向文件尾部翻半屏（向上翻屏）； command模式下的字符编辑： x ： 删除（可认为是剪切，并非真的删除）光标处的字符；#x：删除光标处起始的#个字符；p ：在光标所在处的后面插入储存的字符；xp：交换光标所在处的字符及后面字符的位置；~ ： 转换大小写；J ： 删除当前行后的换行符； 替换命令12r ： 替换光标所在处的字符（只能替换一个字符）；R： 切换为REPLACE模式，可持续替换多个字符。 删除命令12345678910d ： 删除命令（可结合光标跳转字符，实现范围删除）；d$: 从光标所在处，删除到行尾；d^: 从光标所在处，删除到非空行首；d0: 从光标所在处，删除到行首；dw: 从光标所在处，删除到下一个单词的词首；de: 从光标所在处，删除到下一个单词的词尾；db: 从光标所在处，删除到前一个单词的词首；dd: 删除光标所在的行；#dd：多行删除；D ： 从当前光标位置一直删除到行尾，等同于d$。 改变命令12345678910c ： 改变命令（与d命令类似，执行删除后进入插入模式）；c$: 从光标所在处，删除到行尾，并进入插入模式；c^: 从光标所在处，删除到非空行首，并进入插入模式；c0: 从光标所在处，删除到行首，并进入插入模式；cw: 从光标所在处，删除到下一个单词的词首，并进入插入模式；ce: 从光标所在处，删除到下一个单词的词尾，并进入插入模式；cb: 从光标所在处，删除到前一个单词的词首，并进入插入模式；cc: 删除光标所在的行，并进入插入模式；#cc：多行删除，并进入插入模式；C ： 从当前光标位置一直删除到行尾，并进入插入模式，等同于c$。 复制命令12345678910y ： 复制(yank)命令（可结合光标跳转字符，实现范围复制）；y$: 从光标所在处，复制到行尾；y^: 从光标所在处，复制到非空行首；y0: 从光标所在处，复制到行首；yw: 从光标所在处，复制到下一个单词的词首；ye: 从光标所在处，复制到下一个单词的词尾；yb: 从光标所在处，复制到前一个单词的词首；yy: 复制光标所在的行；#yy：多行复制； Y ： 从当前光标位置一直复制到行尾，等同于y$。 命令模式下常用用法汇总 效果 #ihello[ESC] 插入“hello”#次 0y$ 复制本行 gU 变为大写 gu 变为小写 di” 当光标在” “之间时，则删除” “的内容 yi( 当光标在( )之间时，则复制( )的内容 vi[ 当光标在[ ]之间时，则选中[ ]的内容 dtx 删除字符直到遇到光标之后的第一个x字符 ytx 复制字符直到遇到光标之后的第一个x字符 ##### 撤销更改命令 123456u ： 撤销命令（可撤销最近的更改）；#u： 撤销多次之前的更改； U ： 撤销光标落在这行后的所有此行的修改。Ctrl+r:重做最后的撤销，取消撤销。. ： 重复前一个操作。#.： 重复前一个操作#次。 调整文本颜色1Ctrl+v[[031mCOLORCtrl+v[[0m 输出红色COLOR 取消高亮显示1set nohlsearch 取消搜索后的高亮显示]]></content>
      <tags>
        <tag>linux</tag>
        <tag>vim编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不忘初心，方得始终]]></title>
    <url>%2F2019%2F07%2F16%2F%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%EF%BC%8C%E6%96%B9%E5%BE%97%E5%A7%8B%E7%BB%88%2F</url>
    <content type="text"><![CDATA[奔跑吧年轻人 &emsp;&emsp;你走了几年弯路了，也迷茫了好久了，已经落后很远了，甚至也已不再年轻了，不能再选择安逸了！ &emsp;&emsp;你已经不是一个人了，妻子要靠你，孩子也要长大了，父母也要老了，生活上你已经是唯一的支撑了！ &emsp;&emsp;生活已经如此了，唯有努力奔跑，才不会被压倒；选择已经如此了，唯有努力学习，才能不虚此行！ &emsp;&emsp;现状就是这样了，后悔没用，你得变得更好！ 拼搏吧挑战者&emsp;&emsp;你敢于跳出自己的舒适区，来北京从零开始，这已经是一个巨大的成功，同时这也是一个巨大的挑战，爱挑战的你，绝对不会轻易认输，难道不是吗？你会永远相信，你是最棒的，你可以做到你想做好的任何事。&emsp;&emsp;趁自己还年轻。趁此时还不晚，去拼一下，为了那一切的一切，将来的你，一定会感激现在拼命的自己！ 坚持吧追梦人&emsp;&emsp;从来没有人可以轻易成功，不经历挫折，怎么能成长，不经历磨砺，怎么能成器，不经历风雨，怎能见彩虹！&emsp;&emsp;遇到挫折与痛苦，不要放弃，想一想自己，当初为什么要来这里？&emsp;&emsp;既然选择了远方，便只顾风雨兼程！]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>初心不负</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下find命令的一般用法。]]></title>
    <url>%2F2019%2F05%2F05%2FLinux%E4%B8%8Bfind%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95%E3%80%82%2F</url>
    <content type="text"><![CDATA[find和locate介绍在linux中，查找文件一般使用locate和find，locate是根据事先构建好的缩影库或者数据库中的数据查找文件名（非实时，速度快，模糊查找），而find作为一个实时查找命令，通过遍历指定起始路径下文件系统层级结构完成文件查找，功能更加强大（实时查找，速度略慢，精确查找）。 find 命令一般用法find [OPTIONS] [查找起始路径] [查找条件] [处理动作][查找起始路径] ：制定具体搜索目标起始路径；默认为当前目录。[查找条件]：指定的查找标准，可以根据文件名，大小，类型，从属关系，时间戳，权限等标准进行；默认为找出指定目录下的所有文件。[处理动作]：对符合查找条件的文件做出的操作，例如删除等操作；默认为输出至标准输出。 查找条件 根据文件名查找：-name，-iname（不区分文件名中的大小写） ps：不支持正则表达式，支持globe风格的通配符如*、?、[]、[^] **根据文件大小查找**：-size (+/-) #UNIT 常用单位：c、k、M、G#UNIT :(#-1,#] 为精确查找#大小的文件（大于#-1大小的文件数值显示为#也符合）-#UNIT:[0,#-1] 为查找小于等于#-1大小的文件+#UNTI:(#,∞)为查找大于#大小的文件 **根据文件类型查找**： -type [文件类型] f：普通文件 d：目录文件 l：符号链接文件 b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 **根据从属关系查找**： -user USERNAME 或 -uid UID -group GROUPNAME 或 -gid GID 查找无属主属组文件：-nouser , -nogroup **根据时间戳查找**： 以“天”为单位：-atime(访问时间)，-mtime(修改时间)（指文件内容修改），-ctime(改变时间)（指权限及从属关系等修改） 以“分钟”为单位：-amin(访问时间)，-mmin(修改时间)（指文件内容修改），-cmin(改变时间)（指权限及从属关系等修改） -atime (+/-) # ，其中#为以现在开始向过去计时的某时间数值。 #：[#，#-1) -#：(#,0] +#：(-∞,#-1) ![ #：[#，#-1) -#：(#,0] +#：(-∞,#-1)](https://img-blog.csdnimg.cn/20190505164447686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70) 根据权限查找 -perm mode 指明确定权限； -perm /mode 任何一类用户(u,g,o)的权限中的任何一项(r,w,x)符合条件即满足； -perm -mode 每一个用户(u,g,o)的权限中的每一项(r,w,x)都同时符合条件即满足。 权限 二进制 八进制 - - - 0 0 0 0 - - x 0 0 1 1 - w - 0 1 0 2 - w x 0 1 1 3 r - - 1 0 0 4 r - x 1 0 1 5 r w - 1 1 0 6 r w x 1 1 1 7 mode形式 &emsp;可以为 -perm /220 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;也可以为-perm /u+w,g+w 或 -perm /u=w,g=w 组合条件查找：同时满足：与：-a，-and;默认满足任一：或：-o，-or不满足：非：-not，! #]find /… ! A -a ! B →→ #]find /… ! ( A -o B ) 或 #]find /… -not ( A -o B )#]find /… ! A -o ! B →→ #]find /… ! ( A -a B ) 或 #]find /… -not ( A -a B ) 处理动作 -print：输出至标准输出；默认动作-ls：类似对查找到的文件执行“ls-l”-delete：删除查找到的文件-fls /PATH/TO/SOMEFILE 将查找到的文件信息长格式保存至指定路径。-ok COMMAND {} ; 对找到的每个文件执行COMMAND命令（可能需要确认）-exec COMMAND {} ; 对找到的每个文件执行COMMAND命定（无需确认）ps：find传递查找到的文件路径之后面的命令时。实现查找出所有符合的文件路径，并一次性传递给后面的命令。但是有些命令不能接受过长的参数，此时命令执行会失效，可用管道find /… | xargs COMMAND执行。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>find命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
