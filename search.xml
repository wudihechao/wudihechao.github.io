<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis高可用配置]]></title>
    <url>%2F%2Fblog%2F14b8983d.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;redis高可用一般有两种方式实现：哨兵和集群。在哨兵 sentinel 机制中，可以解决 redis 高可用的问题， 即当 master 故障后可以自动将 slave 提升为 master 从而可以保证 redis 服务的正常使用，但是无法解决 redis 单机写入的瓶颈问题， 即单机的 redis 写入性能受限于单机的内存大小、 并发数量、 网卡速率等因素。&emsp;&emsp;redis 官方在 redis 3.0 版本之后推出了无中心架构的 redis cluster机制， 在无中心的 redis 集群当中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接， 特点如下： &emsp;&emsp;1：所有 Redis 节点使用(PING 机制)互联。&emsp;&emsp;2：集群中某个节点的失效， 是整个集群中超过半数的节点监测都失效才算真正的失效（类似Sdown和Odown） 。&emsp;&emsp;3：客户端不需要 proxy 即可直接连接 redis， 应用程序需要写全部的 redis 服务器 IP。&emsp;&emsp;4：redis cluster 把所有的 redis node 映射到 0-16383 个槽位(slot)上， 读写需要到指定的 redis node 上进行操作，因此有多少个 reids node 相当于 redis 并发扩展了多少倍。&emsp;&emsp;5：Redis cluster 预先分配 16384 个(slot)槽位，当需要在 redis 集群中写入一个 key -value 的时候，会使用 CRC16(key) mod 16384 之后的值，决定将 key 写入值哪一个槽位从而决定写入哪一个 Redis 节点上， 从而有效解决单机瓶颈。 Sentinel(哨兵)手动配置主从&emsp;&emsp;需要手动先指定某一台 Redis 服务器为 master，然后将其他 slave 服务器修改配置文件或使用命令配置为 master 服务器的 slave。哨兵的前提是已经手动实现了一个 redis master-slave 的运行环境。&emsp;&emsp;例如我们将192.168.32.81上的redis服务设置为master，192.168.32.82、192.168.32.83设置为slave，192.168.32.81中配置文件masterauth 设置为123456&emsp;&emsp;在192.168.32.82上设置主节点信息SLAVEOF 192.168.32.81 6379(redis5版本命令为REPLICAOF 192.168.7.101 6379) 1234192.168.32.82:6379&gt; SLAVEOF 192.168.32.81 6379OK192.168.32.82:6379&gt; CONFIG SET masterauth "123456"OK &emsp;&emsp;同样,192.168.32.83也要设置主节点信息及密码 1234192.168.7.103:6379&gt; SLAVEOF 192.168.7.101 6379OK192.168.7.103:6379&gt; CONFIG SET masterauth "123456"OK &emsp;&emsp;此时通过info Replication命令，在两个从节点上可以看到角色已变更为slave,且master_link_status状态要为up，说明主从结构配置完成。 123456127.0.0.1:6379&gt; info Replication# Replicationrole:slavemaster_host:192.168.32.81master_port:6379master_link_status:up &emsp;&emsp;需要注意的是：不同的 redis 版本之间存在兼容性问题， 因此各 master 和 slave 之间必须保持版本一致，且redis slave 也要开启持久化并设置和 master 同样的连接密码，此外，如果开启了安全模式，未设置密码的话也会导致主从无法连接。 配置Sentinel&emsp;&emsp;哨兵可以不和 Redis 服务器部署在一起。可以使用另外不同的机子，一般采用单数个哨兵（至少3个）。不过为了节约服务器，我们还是和redis服务器部署到一起。&emsp;&emsp;3个机子都手动添加Sentinel配置文件&emsp;&emsp;vim /apps/redis/etc/sentinel.conf 123456789101112bind 0.0.0.0port 26379daemonize yespidfile "redis-sentinel.pid"logfile "sentinel_26379.log"dir "/usr/local/redis"sentinel monitor mymaster 192.168.32.81 6379 2 #法定人数限制(quorum)，即有几个slave 认为 master down 了就进行故障转移sentinel auth-pass mymaster 123456sentinel down-after-milliseconds mymaster 30000 #(SDOWN)主观下线的时间sentinel parallel-syncs mymaster 1 #发生故障转移时候同时向新 master 同步数据的slave 数量， 数字越小总同步时间越长sentinel failover-timeout mymaster 180000 #所有 slaves 指向新的 master 所需的超时时间sentinel deny-scripts-reconfig yes #禁止修改脚本 &emsp;&emsp;通过/apps/redis/bin/redis-sentinel /apps/redis/etc/sentinel.conf命令指定配置文件，启动哨兵，此时通过ss -tanl命令可以看到已监听26379端口，说明哨兵服务已启动。 123456789[root@CentOS8 ~]# redis-cli -h 192.168.32.81 -p 26379192.168.32.81:26379&gt; info Sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=mymaster,status=ok,address=192.168.32.81:6379,slaves=2,sentinels=3 &emsp;&emsp;可以通过redis-cli指定26379端口连接哨兵服务器，info Sentinel查看哨兵状态，显示status=ok，slaves=2，sentinels=3，与我们之前设计的相同，说明哨兵服务正常。&emsp;&emsp;此时，当master故障后，哨兵会通过投票机制，选举一个slave作为新的master，继续实现主从结构，而程序应用也会在主从切换的时候收到通知，Jedis 会进行连接的切换（在 JedisPool 中添加了 Sentinel 和MasterName 参数， JRedis Sentinel 底层基于 Redis 订阅实现 Redis 主从服务的切换通知， 当 Reids 发生主从切换时， Sentinel 会发送通知主动通知 Jedis 进行连接的切换， JedisSentinelPool 在每次从连接池中获取链接对象的时候,都要对连接对象进行检测,如果此链接和 Sentinel 的 Master 服务连接参数不一致,则会关闭此连接,重新获取新的 Jedis 连接对象。），实现redis的高可用。 Redis Cluster&emsp;&emsp;在哨兵 sentinel 机制中，可以解决 redis 高可用的问题， 即当 master 故障后可以自动将 slave 提升为 master 从而可以保证 redis 服务的正常使用，但是无法解决 redis 单机写入的瓶颈问题， 即单机的 redis 写入性能受限于单机的内存大小、 并发数量、 网卡速率等因素，所以Redis自带的Cluster就是很好的一个解决方案。 集群前提&emsp;&emsp;1.每个 redis node 节点采用相同的硬件配置、相同的密码、 相同的 redis 版本。&emsp;&emsp;2.每个节点必须开启的参数cluster-enabled yes #必须开启集群状态， 开启后 redis 进程会有 cluster 显示cluster-config-file nodes-6380.conf #此文件有 redis cluster 集群自动创建和维护，不需要任何手动操作&emsp;&emsp;3.所有 redis 服务器必须没有任何数据&emsp;&emsp;4.先启动为单机 redis 且没有任何 key value 集群部署Redis 3、4&emsp;&emsp;Redis 3 和 4 版本需要使用到集群管理工具 redis-trib.rb，这个工具是 redis 官方推出的管理 redis 集群的工具，集成在 redis 的源码 src 目录下，是基于 redis 提供的集群命令封装成简单、便捷、实用的操作工具， redis-trib.rb 是 redis 作者用 ruby 开发完成的。所以需要有ruby环境，如果系统自带的ruby版本较低（需要Ruby version &gt;= 2.3.0），那就需要重新编译安装更高版本。 编译安装ruby12 yum remove ruby rubygems -ywget https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.5.tar.gz 1234tar xf ruby-2.5.5.tar.gzcd ruby-2.5.5./configure make -j 4 &amp;&amp; make install &emsp;&emsp;安装redis的gem包（Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 http://rubygems.org/ ）源来查找、安装、升级和卸载软件包，非常的便捷）。 1gem install redis &emsp;&emsp;之后就可以使用redis-trib.rb命令来创建管理集群了。 集群创建&emsp;&emsp;通过命令redis-trib.rb create来创建集群，选项–replicas 指定 master 的slave数量.&emsp;&emsp;需要注意的是，集群至少也需要3台master，（–replicas 指定的slave数量可以为0，不过一般不建议），如果指定slave数量为2的话就至少需要9个redis服务器了（3主6从），比较浪费资源，所以我们一般设置replicas数值为1。&emsp;&emsp;如果设置slave数量为0，则所有的6个服务器均为master，无法实现高可，集群信息如下图所示： 12345678127.0.0.1:6379&gt; cluster nodesc65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 192.168.32.82:6379@16379 master - 0 1573794294000 3 connected 5461-8191a13d711b6b54909e5aed44cc8f75195915bbfb95 192.168.32.85:6379@16379 master - 0 1573794293235 6 connected 13653-163835d614e18da36f9d7b3536566205281743adc95c5 192.168.32.8:6379@16379 myself,master - 0 1573794294000 1 connected 0-27306fe42df7ea9c4dbb00d9bae6f7e4238367b1089b 192.168.32.81:6379@16379 master - 0 1573794292212 2 connected 2731-5460e3beb9f45b73b265050499ee093ed1a473a3d566 192.168.32.83:6379@16379 master - 0 1573794295286 4 connected 8192-109228ae323030e3ae28519a27058c6592b94d1aae734 192.168.32.84:6379@16379 master - 0 1573794295000 5 connected 10923-13652127.0.0.1:6379&gt; &emsp;&emsp;如果设置slave数量为2，若创建集群是加入的服务器数量不够9台，则会报错： 123456789101112[root@CentOS8 ~]#redis-trib.rb create --replicas 2 \192.168.32.8:6379 \192.168.32.81:6379 \192.168.32.82:6379 \192.168.32.83:6379 \192.168.32.84:6379 \192.168.32.85:6379&gt;&gt;&gt; Creating cluster*** ERROR: Invalid configuration for cluster creation.*** Redis Cluster requires at least 3 master nodes.*** This is not possible with 6 nodes and 2 replicas per node.*** At least 9 nodes are required. &emsp;&emsp;若之前有创建集群失败的一些操作，或集群中有的redis服务器中有数据信息的话，也是无法创建成功的。会报类似如下如下信息： 1/usr/local/share/gems/gems/redis-4.1.3/lib/redis/client.rb:126:in `call': ERR Slot 2823 is already busy (Redis::CommandError) &emsp;&emsp;所以我们一般在创建集群之前，先连上redis服务器清空数据，并重置集群关系，确保所有的redis服务器都没有数据且都为单机master。 12FLUSHALLcluster reset &emsp;&emsp;然后执行创建集群命令 1234567redis-trib.rb create --replicas 1 \192.168.32.8:6379 \192.168.32.81:6379 \192.168.32.82:6379 \192.168.32.83:6379 \192.168.32.84:6379 \192.168.32.85:6379 &emsp;&emsp;即可成功创建集群。连接redis，登陆，即可看到集群主从关系。 12345678910111213[root@CentOS8 ~]#redis-cli127.0.0.1:6379&gt; cluster nodesNOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; cluster nodesc65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 192.168.32.82:6379@16379 master - 0 1573798716854 3 connected 10923-16383a13d711b6b54909e5aed44cc8f75195915bbfb95 192.168.32.85:6379@16379 slave 6fe42df7ea9c4dbb00d9bae6f7e4238367b1089b 0 1573798715000 6 connected5d614e18da36f9d7b3536566205281743adc95c5 192.168.32.8:6379@16379 myself,master - 0 1573798716000 1 connected 0-54606fe42df7ea9c4dbb00d9bae6f7e4238367b1089b 192.168.32.81:6379@16379 master - 0 1573798717877 2 connected 5461-109228ae323030e3ae28519a27058c6592b94d1aae734 192.168.32.84:6379@16379 slave 5d614e18da36f9d7b3536566205281743adc95c5 0 1573798715834 5 connectede3beb9f45b73b265050499ee093ed1a473a3d566 192.168.32.83:6379@16379 slave c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 0 1573798716000 4 connected127.0.0.1:6379&gt; &emsp;&emsp;监控集群状态 1redis-trib.rb check 192.168.32.8:6379 Redis 5&emsp;&emsp;Redis 5 版本可以直接用redis-cli客户端命令加各种命令参数来管理创建集群(配置文件中如果已配置正确的密码，则不需要-a 选项，-a选项会有warning警告)。&emsp;&emsp;创建集群 1234567redis-cli -a 123456 --cluster create --cluster-replicas 1 \192.168.32.8:6379 \192.168.32.81:6379 \192.168.32.82:6379 \192.168.32.83:6379 \192.168.32.84:6379 \192.168.32.85:6379 &emsp;&emsp;监控集群状态 1redis-cli -a 123456 --cluster check 192.168.32.8:6379 集群管理维护&emsp;&emsp;集群运行时间长久之后，难免由于硬件故障、网络规划、 业务增长等原因对已有集群进行相应的调整， 比如增加 Redis node 节点、 减少节点、 节点迁移、更换服务器等。 动态添加节点&emsp;&emsp;同步之前 Redis node 的配置文件到 192.168.32.86 Redis 编译安装目录， 注意修改配置文件的监听 IP。 12scp redis.conf 192.168.32.86:/apps/redis/etc/scp redis_6380.conf 192.168.32.86:/apps/redis/etc/ &emsp;&emsp;对预备加入的redis服务器清除数据并执行集群重置 12FLUSHALLcluster reset &emsp;&emsp;redis3、4 中添加节点（Adding node 192.168.32.87:6379 to cluster 192.168.32.8:6379） 1redis-trib.rb add-node 192.168.32.87:6379 192.168.32.8:6379 &emsp;&emsp;redis5 中添加节点（Adding node 192.168.32.87:6379 to cluster 192.168.32.8:6379） 1redis-cli --cluster add-node 192.168.32.87:6379 192.168.32.8:6379 重新分配槽位&emsp;&emsp;集群槽位迁移时，迁出的服务器中不能有数据，否则会迁移失败并终止，且需要修复集群，才可以进行第二次迁移。&emsp;&emsp;redis3、4 中对新加的主机重新分配槽位(后可跟集群中任意主机ip:port): 1redis-trib.rb reshard 192.168.32.8:6379 &emsp;&emsp;redis5 对新加的主机重新分配槽位(后可跟集群中任意主机ip:port): 1redis-cli --cluster reshard 192.168.32.8:6379 &emsp;&emsp;输入命令后根据提示输入 123456789How many slots do you want to move (from 1 to 16384)? 4096 #需要迁移多少槽位What is the receiving node ID? 5d614e18da36f9d7b3536566205281743adc95c5 #选择迁移到哪个redis主机What is the receiving node ID? 6bffc0037eea959f0dcc11aca657f928d86cfc75Please enter all the source node IDs. Type 'all' to use all the nodes as source nodes for the hash slots. Type 'done' once you entered all the source nodes IDs.Source node #1:6bffc0037eea959f0dcc11aca657f928d86cfc75 #选择从哪个主机迁出Source node #2:done #输入done结束选择Do you want to proceed with the proposed reshard plan (yes/no)? yes #是否执行，yes确认，之后就会迁移完毕 修复集群&emsp;&emsp;如果迁移失败，则需要修复集群。 &emsp;&emsp;redis3、4 中对对报错redis服务器进行单独修复(后跟需要修复的主机ip:port): 1redis-trib.rb fix 192.168.32.82:6379 &emsp;&emsp;redis5 中对对报错redis服务器进行单独修复(后跟需要修复的主机ip:port): 1redis-cli --cluster fix 192.168.32.82:6379 配置主从关系&emsp;&emsp;在整个 Redis cluster 集群中，每个 master 至少有一个 slave。也可以有多个，但是至少要有一个提供数据备份和服务高可用。&emsp;&emsp;redis-trib.rb info 192.168.32.8:6379 12345678[root@CentOS8 ~]#redis-trib.rb info 192.168.32.8:6379192.168.32.8:6379 (5d614e18...) -&gt; 0 keys | 4096 slots | 1 slaves.192.168.32.82:6379 (c65ab2a5...) -&gt; 0 keys | 4096 slots | 0 slaves.192.168.32.81:6379 (6fe42df7...) -&gt; 0 keys | 4096 slots | 1 slaves.192.168.32.87:6379 (6bffc003...) -&gt; 0 keys | 4096 slots | 1 slaves.192.168.32.86:6379 (e06732b2...) -&gt; 0 keys | 0 slots | 0 slaves.[OK] 0 keys in 5 masters.0.00 keys per slot on average. &emsp;&emsp;我们看到之前的3主3从结构因为我们加了两个服务器变成了5主3从，新加的两个服务器，我们需要将它们设置为一主一从来实现高可用。于是我们要将192.168.32.86变为192.168.32.82的slave。&emsp;&emsp;连接登陆192.168.32.86上的redis服务器，先查好192.168。32.82的ID为c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308，执行 1cluster replicate c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 删除节点&emsp;&emsp;删除节点，需要先将redis主机上的槽位都迁移到其他主机上才可以操作。&emsp;&emsp;迁移完成后，redis3、4 删除节点（要删除的redis主机要写节点号，集群可以写集群中任意主机ip+port） 1234[root@CentOS8 ~]#redis-trib.rb del-node 192.168.32.8:6379 6bffc0037eea959f0dcc11aca657f928d86cfc75&gt;&gt;&gt; Removing node 6bffc0037eea959f0dcc11aca657f928d86cfc75 from cluster 192.168.32.8:6379&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node. &emsp;&emsp;redis5 删除节点 1redis-cli --cluster del-node 192.168.32.8:6379 6bffc0037eea959f0dcc11aca657f928d86cfc75 &emsp;&emsp;主节点被删除之后，其之前它的 slave 自动称为了 Redis 集群中其他 master的 slave，此节点如果不需要也可以一并删除。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>redis</tag>
        <tag>企业级应用</tag>
        <tag>集群</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键源码编译安装redis]]></title>
    <url>%2F%2Fblog%2Ff2c1a89e.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Redis 和 Memcached 是非关系型数据库也称为 NoSQL 数据库， MySQL、 Mariadb、 SQLServer、 PostgreSQL、 Oracle 数据库属于关系型数据(RDBMS, Relational Database Management System)。&emsp;&emsp;Redis(Remote Dictionary Server)在 2009 年发布， 开发者 Salvatore Sanfilippo 是意大利开发者， 他本想为自己的公司开发一个用于替换 MySQL 的产品 Redis， 但是没有想到他把 Redis 开源后大受欢迎，短短几年， Redis 就有了很大的用户群体，目前国内外使用的公司有知乎&gt;网、新浪微博、 GitHub 等。&emsp;&emsp;redis 是一个开源的、 遵循 BSD 协议的、 基于内存的而且目前比较流行的键值数据库(key-value database)，是一个非关系型数据库，redis 提供将内存通过网络远程共享的一种服务，提供类似功能的还有 memcache，但相比 memcache， redis 还提供了易扩展、高性能、 具备数据持久性等功能。&emsp;&emsp;Redis 在高并发、低延迟环境要求比较高的环境使用量非常广泛， 目前 redis 在 DBEngine 月排行榜 https://db-engines.com/en/ranking 中一直比较靠前，而且一直是键值型存储类的首位。 编译安装&emsp;&emsp;redis在centos版本自带的yum源中版本比较低，一般都需要我们编译安装更高版本的redis。 准备源码包&emsp;&emsp;可以先用下载工具去官网下载好源码包，下载链接为 https://db-engines.com/en/ranking 。&emsp;&emsp;出于稳定性要求，一般来说实际生产中不会选用最新版的redis，避免因为漏洞造成服务器的安全隐患，所以本次演示，我们选用目前redis4的最新版本，redis-4.0.14来安装。 编译安装&emsp;&emsp;tar xf redis-4.0.14..tar.gz&emsp;&emsp;cd redis-4.0.14&emsp;&emsp;编译安装redis的依赖包不多，有make和gcc就够了。 1yum install make gcc -y &emsp;&emsp;如果是最小化安装的新系统，忘记安装gcc的话直接去尝试编译安装redis，就会遇到报错： 12345678910111213make[3]: Entering directory '/root/redis-4.0.14/deps/hiredis'gcc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.cmake[3]: gcc: Command not foundmake[3]: *** [Makefile:156: net.o] Error 127make[3]: Leaving directory '/root/redis-4.0.14/deps/hiredis'make[2]: *** [Makefile:46: hiredis] Error 2make[2]: Leaving directory '/root/redis-4.0.14/deps'make[1]: [Makefile:180: persist-settings] Error 2 (ignored) CC adlist.o/bin/sh: cc: command not foundmake[1]: *** [Makefile:228: adlist.o] Error 127make[1]: Leaving directory '/root/redis-4.0.14/src'make: *** [Makefile:9: install] Error 2 &emsp;&emsp;提示没装gcc，再回头补上,yum install gcc -y，也还是会报错的。 123456789101112[root@CentOS8 redis-4.0.14]#make PREFIX=/apps/redis installcd src &amp;&amp; make installmake[1]: Entering directory '/root/redis-4.0.14/src' CC adlist.oIn file included from adlist.c:34:zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; ^~~~~~~~~~~~~~~~~~~~~compilation terminated.make[1]: *** [Makefile:228: adlist.o] Error 1make[1]: Leaving directory '/root/redis-4.0.14/src'make: *** [Makefile:9: install] Error 2 &emsp;&emsp;这是因为上次的编译失败，有残留的文件，我们需要清理下，make distclean，然后重新编译就可以了，make PREFIX=/apps/redis install。&emsp;&emsp;网上也有说可以通过加选项make MALLOC=libc来解决，不过其实是有一些隐患的。首先我们要知道redis 需要使用内存分配器的， 默认是指定内存分配器为 jemalloc ，make MALLOC=libc 就是指定内存分配器为 libc ，而jemalloc 内存分配器在实践中处理内存碎片是要比libc 好的，而且在README.md 文档也说明到了，jemalloc内存分配器也是包含在源码包里面的，可以在deps 目录下看到 jemalloc 目录。&emsp;&emsp;编译完成后，接下来我们还需要几步操作。&emsp;&emsp;创建目录结构mkdir /apps/redis/{etc,logs,data,run}&emsp;&emsp;从源码包中复制配置文件cp redis.conf /apps/redis/etc/&emsp;&emsp;创建systemctl服务启动脚本，为了避免安全隐患，我们还要将redis服务设为以redis身份启动，所以还要修改目录权限 12345678910111213141516171819cat &gt; /usr/lib/systemd/system/redis.service &lt;&lt;"END"[Unit]Description=Redis persistent key-value databaseAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]#ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemdExecStart=/apps/redis/bin/redis-server /apps/redis/etc/redis.conf --supervised systemdExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDType=notifyUser=redisGroup=redisRuntimeDirectory=redisRuntimeDirectoryMode=0755[Install]WantedBy=multi-user.targetEND &emsp;&emsp;创建redis用户，并修改redis目录属主属组。 12groupadd -g 379 redis &amp;&amp; useradd -u 379 -g 379 redis -s /sbin/nologinchown redis.redis -R /apps/redis &emsp;&emsp;修改PATH变量或者直接用软链接的方式(用一个即可，效果一样)，方便执行redis命令。&emsp;&emsp;ln -sv /apps/redis/bin/* /usr/local/bin/(软链接)&emsp;&emsp;echo &quot;PATH=/apps/redis/bin:$PATH&quot; &gt; /etc/profile.d/redis.sh；. /etc/profile.d/redis.sh(改PATH变量) 修改内核参数&emsp;&emsp;这时redis服务就其实已经搭建完成了，已经可以通过服务脚本进行启动了。可是如果直接启动会有一些[warning]信息，而且很有可能在高并发的时候导致redis崩溃。 123413636:M 13 Nov 10:37:06.195 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.13636:M 13 Nov 10:37:06.195 # Server initialized13636:M 13 Nov 10:37:06.195 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.13636:M 13 Nov 10:37:06.195 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled. &emsp;&emsp;我们可以通过修改一些内核参数来避免这一风险。 TCP backlog 参数控制的是三次握手的时候 server 端收到 client ack 确认号之后的队列值，redis默认为511。我们需要将内核的net.core.somaxconn值(系统默认128)更改为大于511，或将redis的队列之修改小于128. 将vm.overcommit_memory值改为10、表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。1、表示内核允许分配所有的物理内存，而不管当前的内存状态如何。2、表示内核允许分配超过所有物理内存和交换空间总和的内存 transparent hugepage：开启大页内存动态分配，需要关闭让 redis 负责内存管理。 &emsp;&emsp;所以，我们执行下面操作 1234cat &gt;&gt; /etc/sysctl.conf &lt;&lt;ENDnet.core.somaxconn = 512vm.overcommit_memory = 1END 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled &emsp;&emsp;至此，redis就正式调试完成，可以正常使用了。 附：一键编译安装redis脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/bin/bashDST="/apps"#[ -d $DST ] || &#123; echo "install into $DST fail,No such file or directory" ;exit 10;&#125;[ -a redis-*.tar.* ] || &#123; echo ' the absence of redis.tar.gz' ;exit 1;&#125;[ -a /usr/lib/systemd/system/redis.service ] &amp;&amp; &#123; echo 'redis.service is exist,redis is aready installed' ;exit 2;&#125;[ -d $DST/redis* ] &amp;&amp; &#123; echo "redis is aready installed into $DST/redis" ;exit 3;&#125;id redis &amp;&gt;/dev/null &amp;&amp; &#123; echo 'user redis is exist,redis is aready installed' ; exit 4;&#125; || &#123; groupadd -g 379 redis &amp;&amp; useradd -u 379 -g 379 redis -s /sbin/nologin || &#123; echo user 379 is exist ;exit 5; &#125; &#125;mkdir -p $DST/redisyum install -y make gcc#yum install -y make gcc wget#wget http://download.redis.io/releases/redis-4.0.14.tar.gztar xf redis-*.tar.*PTH=`find . -name "redis*" -type d |head -n1`cd $PTHmake PREFIX=$DST/redis installmkdir $DST/redis/&#123;etc,logs,data,run&#125;cp redis.conf /apps/redis/etc/chown redis.redis -R /apps/rediscat &gt; /usr/lib/systemd/system/redis.service &lt;&lt;"END"[Unit]Description=Redis persistent key-value databaseAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]#ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemdExecStart=/apps/redis/bin/redis-server /apps/redis/etc/redis.conf --supervised systemdExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDType=notifyUser=redisGroup=redisRuntimeDirectory=redisRuntimeDirectoryMode=0755[Install]WantedBy=multi-user.targetEND[ $DST == "/apps" ] || sed -i "@/apps@$DST@g" /usr/lib/systemd/system/redis.serviceln -sv $DST/redis/bin/* /usr/local/bin/cat &gt;&gt; /etc/sysctl.conf &lt;&lt;ENDnet.core.somaxconn = 512vm.overcommit_memory = 1ENDecho never &gt; /sys/kernel/mm/transparent_hugepage/enabledsystemctl enable --now redis]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>源码编译</tag>
        <tag>一键安装</tag>
        <tag>企业级应用</tag>
        <tag>内核参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故障:/etc/fstab中NFS自动挂载失败]]></title>
    <url>%2F%2Fblog%2F219b1607.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前配置了一个web集群(其实就3个服务器)，想实现数据共享和动静分离，感觉配置分布式存储比较复杂，也没必要，就打算在搭建一个NFS服务器，共享几个目录，挂载在几个web服务器上。&emsp;&emsp;搭建NFS服务过程很顺利，手动挂载也没问题，然后打算将挂载信息写进/etc/fstab配置文件，实现开机自动挂载。 12345678910111213141516## /etc/fstab# Created by anaconda on Wed Oct 9 08:35:16 2019## Accessible filesystems, by reference, are maintained under '/dev/disk/'.# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.## After editing this file, run 'systemctl daemon-reload' to update systemd# units generated from this file.#/dev/mapper/cl-root / xfs defaults 0 0UUID=100a90e3-01ac-43aa-b6da-a10a6c105282 /boot ext4 defaults 1 2/dev/mapper/cl-data /data xfs defaults 0 0/dev/mapper/swap-swap swap swap defaults 0 0/dev/sr0 /cdrom iso9660 defaults 0 0192.168.32.85:/data/nfsshare /apps/nginx/html/wordpress/wp-content/uploads nfs defaults,_netdev 0 0 &emsp;&emsp;以为一切万事大吉之后，重启了机子测试下,df命令一看，发现竟然没有显示，用mount -l命令看了下，也没有挂载信息——竟然没有自动挂载。&emsp;&emsp;开始以为配置文件格式写错了，结果尝试一下mount -a发现一下就挂载成功了。&emsp;&emsp;这就很奇怪了，说明配置文件格式也没问题。&emsp;&emsp;NFS服务器也没任何报错，应该跟NFS服务器没有关系，只是出于某种原因不能自动挂载而已。&emsp;&emsp;可是本地光盘确实可以开机正常挂载的，于是我怀疑是参数写的有问题，不过仔细确认了下，之前参数就是这样的也是可以成功挂载的，抑或是CentOS8有些新特性和改动。上面确实提示After editing this file, run &#39;systemctl daemon-reload&#39; to update systemd units generated from this file，我也尝试了，没有效果，不过既然其他挂载项都没问题，说明问题就在NFS这一行。&emsp;&emsp;于是去查看下系统日志，发现了问题的端倪 1234567891011[root@CentOS8 ~]#tail /var/log/boot.logSee 'systemctl status "apps-nginx-html-wordpress-wp\\x2dcontent-uploads.mount"' for details.[DEPEND] Dependency failed for Remote File Systems. Starting Permit User Sessions... Starting The nginx HTTP and reverse proxy server... Starting Crash recovery kernel arming...[ OK ] Started OpenSSH server daemon.[ OK ] Started Permit User Sessions. Starting Terminate Plymouth Boot Screen... Starting Hold until boot process finishes up...[ OK ] Started Command Scheduler. &emsp;&emsp;显示远程服务系统也就是NFS服务挂载失败，查看详细信息。 12345678910111213[root@CentOS8 ~]#systemctl status "apps-nginx-html-wordpress-wp\\x2dcontent-uploads.mount"● apps-nginx-html-wordpress-wp\x2dcontent-uploads.mount - /apps/nginx/html/wordpress/wp-content/uploads Loaded: loaded (/etc/fstab; generated) Active: failed (Result: resources) Where: /apps/nginx/html/wordpress/wp-content/uploads What: 192.168.32.85:/data/nfsshare Docs: man:fstab(5) man:systemd-fstab-generator(8)Nov 11 16:02:39 CentOS8 systemd[1]: apps-nginx-html-wordpress-wp\x2dcontent-uploads.mount: Mount path /apps/nginx/html/wordpress/wp-content/uploads is not canonical (contains a symlink).Nov 11 16:02:39 CentOS8 systemd[1]: apps-nginx-html-wordpress-wp\x2dcontent-uploads.mount: Failed to run 'mount' task: Too many levels of symbolic linksNov 11 16:02:39 CentOS8 systemd[1]: apps-nginx-html-wordpress-wp\x2dcontent-uploads.mount: Failed with result 'resources'.Nov 11 16:02:39 CentOS8 systemd[1]: Failed to mount /apps/nginx/html/wordpress/wp-content/uploads. &emsp;&emsp;说挂载失败，挂载路径不符合规范is not canonical (contains a symlink).。路径写法应该没问题的，难道是因为Too many levels of symbolic links，层级太多了吗？我记得之前挂载点目录层级结构，比这还长都可以挂载成功的，难道又要归结为CentOS8的新特性了么。&emsp;&emsp;一通百度、google之后，竟然没有人和我遇到的问题一样，挂载点的最大层级数是多大也没人提到过，官方文档也没有查到。&emsp;&emsp;正当我打算将层数改小一些再尝试下的时候，突然看到一篇博客提到Too many levels of symbolic links，不过是在软链接中的报错。我突然想起来，当时我安装完系统后，规划的是讲文档和应用都装在/data目录下，可是我实际操作中比较习惯使用/apps/目录来找各种应用，于是之前编译安装nginx及php之前，我创建了一个软链接ln -s /data/apps /apps，以便/apps下的数据跟系统分区隔离开，在一个单独分区。或许这个is not canonical (contains a symlink).中的symlink说的就是指软链接。&emsp;&emsp;将配置文件修改为192.168.32.85:/data/nfsshare /data/apps/nginx/html/wordpress/wp-content/uploads nfs defaults,_netdev 0 0后，再次重启。df命令查看 12345678910111213[root@CentOS8 ~]#dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 393080 0 393080 0% /devtmpfs 408620 0 408620 0% /dev/shmtmpfs 408620 5816 402804 2% /runtmpfs 408620 0 408620 0% /sys/fs/cgroup/dev/mapper/cl-root 52399108 2700076 49699032 6% //dev/sr0 6967726 6967726 0 100% /cdrom/dev/nvme0n1p1 8191416 163348 7592256 3% /boot/dev/mapper/cl-data 41926656 585412 41341244 2% /data192.168.32.85:/data/nfsshare 41926656 535040 41391616 2% /data/apps/nginx/html/wordpress/wp-content/uploadstmpfs 81724 0 81724 0% /run/user/0[root@CentOS8 ~]# &emsp;&emsp;挂载成功~问题解决！原来纯属自己挖的坑！&emsp;&emsp;记录一下，也算，增长点见识，吸取些教训。]]></content>
      <categories>
        <category>故障记录</category>
      </categories>
      <tags>
        <tag>故障</tag>
        <tag>记录</tag>
        <tag>排错</tag>
        <tag>NFS</tag>
        <tag>挂载</tag>
        <tag>软链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业级应用：负载均衡层——haproxy(二)]]></title>
    <url>%2F%2Fblog%2Ff5daec50.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;继续讲解HAProxy的一些进阶配置及用法，包括报文修改，日志配置，压缩功能，后端服务器状态监测及ACL等功能应用。配置环境及配置文件均延续上一篇《企业级应用：负载均衡层——haproxy(一)》,有任何疑问可以先看上一篇博客。 haproxy的进阶配置haproxy报文修改&emsp;&emsp;在http模式下，基于实际需求修改客户端的请求报文与响应报文，通过reqadd和reqdel在请求报文添加删除字段，通过rspadd与rspidel在响应报文中添加与删除字段。 123456789101112131415在请求报文尾部添加指定首部 reqadd &amp;ltstring&amp;gt [&#123;if | unless&#125; &amp;ltcond&amp;gt]从请求报文中删除匹配正则表达式的首部 reqdel &amp;ltsearch&amp;gt [&#123;if | unless&#125; &amp;ltcond&amp;gt] reqidel &amp;ltsearch&amp;gt [&#123;if | unless&#125; &amp;ltcond&amp;gt]在响应报文尾部添加指定首部 rspadd &amp;ltstring&amp;gt [&#123;if | unless&#125; &amp;ltcond&amp;gt]示例： rspadd X-Via:\ HAPorxy从响应报文中删除匹配正则表达式的首部 rspdel &amp;ltsearch&amp;gt [&#123;if | unless&#125; &amp;ltcond&amp;gt] rspidel &amp;ltsearch&amp;gt [&#123;if | unless&#125; &amp;ltcond&amp;gt]示例： rspidel server.* #从相应报文删除server信息 rspidel X-Powered-By:.* #从响应报文删除X-Powered-By信息 HAProxy日志HAProxy日志配置&emsp;&emsp;需在HAProxy和Rsyslog中分别配置。 HAProxy配置1234567在global配置项定义：log 127.0.0.1 local&#123;1-7&#125; info #基于syslog记录日志到指定设备，级别有(err、warning、info、debug)listen web_portbind 127.0.0.1:80mode httplog globalserver web1 127.0.0.1:8080 check inter 3000 fall 2 rise 5 &emsp;&emsp;然后重启HAProxysystemctl restart haproxy Rsyslog配置 &emsp;&emsp;编辑配置文件vim /etc/rsyslog.conf 123$ModLoad imudp$UDPServerRun 514local3.* /var/log/haproxy.log &emsp;&emsp;然后重启Rsyslogsystemctl restart rsyslog HAProxy日志格式&emsp;&emsp;将特定信息记录在日志中&emsp;&emsp;配置选项：&emsp;&emsp;capture cookie &amp;ltname&amp;gt len &amp;ltlength&amp;gt #捕获请求和响应报文中的 cookie并记录日志&emsp;&emsp;capture request header &amp;ltname&amp;gt len &amp;ltlength&amp;gt #捕获请求报文中指定的首部内容和长度并记录日志&emsp;&emsp;capture response header &amp;ltname&amp;gt len &amp;ltlength&amp;gt #捕获响应报文中指定的内容和长度首部并记录日志&emsp;&emsp;示例： 123capture request header Host len 256capture request header User-Agent len 512capture request header Referer len 15 配置示例1234567891011listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog #日志格式选项 capture request header X-Forwarded-For len 15 capture request header User-Agent len 512 cookie SERVER-COOKIE insert indirect nocache server web1 192.168.32.81:80 cookie web1 check inter 3000 fall 3 rise 5 server web2 192.168.32.82:80 cookie web2 check inter 3000 fall 3 rise 5 压缩功能&emsp;&emsp;启用功能可以对响应给客户端的报文进行压缩，以节省网络带宽，但是会占用部分CPU性能。 配置选项123456compression algo #启用http协议中的压缩机制，常用算法有gzip deflate identity #调试使用的压缩方式 gzip #常用的压缩方式，与各浏览器兼容较好 deflate #有些浏览器不支持 raw-deflate #新出的压缩方式compression type #要压缩的文件类型 配置示例12345678910111213listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog# capture request header X-Forwarded-For len 15# capture request header User-Agent len 512 compression algo gzip compression type compression type text/plain text/html text/css text/xml text/javascript application/javascriptcookie SERVER-COOKIE insert indirect nocacheserver web1 192.168.32.81:80 cookie web1 check inter 3000 fall 3 rise 5server web2 192.168.32.82:80 cookie web2 check inter 3000 fall 3 rise 5 后端服务器状态监测&emsp;&emsp;haproxy能对后端服务器状态进行检测，如果发现后端服务器异常，可以自动将该服务器下线，实现高可用。&emsp;&emsp;haproxy对后端服务器有三种检测方式： 基于四层的传输端口做状态监测 基于指定URI 做状态监测 基于指定URI的request请求头部内容做状态监测1234option httpchkoption httpchk &amp;lturi&amp;gtoption httpchk &amp;ltmethod&amp;gt &amp;lturi&amp;gtoption httpchk &amp;ltmethod&amp;gt &amp;lturi&amp;gt &amp;ltversion&amp;gt &emsp;&emsp;之前我们的配置都是基于传输IP加端口对检测，所以status状态页的后端检测状态里显示的是L4，基于指定URI做状态监测，需要持续从服务器get指定页面，会占用消耗一些带宽资源，所以基于指定URI的request请求头部内容做状态监测最为合理，配置如下： 1234567891011listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog# option httpchk GET /app/monitor/check.html HTTP/1.0 option httpchk HEAD /app/monitor/check.html HTTP/1.0\r\nHost:\ 192.168.7.102 cookie SERVER-COOKIE insert indirect nocache server web1 192.168.32.81:80 cookie web1 check inter 3000 fall 3 rise 5 server web2 192.168.32.82:80 cookie web2 check inter 3000 fall 3 rise 5 &emsp;&emsp;这时再去看9999端口的status页，就会看到后端服务器的检测状态为L7OK了 HAProxy的ACL功能&emsp;&emsp;访问控制列表（ACL，Access Control Lists）是一种基于包过滤的访问控制技术，它可以根据设定的条件对经过服务器传输的数据包进行过滤(条件匹配)，即对接收到的报文进行匹配和过滤，基于请求报文头部中的源地址、源端口、目标地址、目标端口、请求方法、URL、文件后缀等信息内容进行匹配并执行进一步操作，允许其通过或丢弃。 ACL配置选项：12acl &amp;ltaclname&amp;gt &amp;ltcriterion&amp;gt [flags] [operator] [&amp;ltvalue&amp;gt]acl 名称 匹配规范 匹配模式 具体操作符 操作对象类型 ACL-Name&emsp;&emsp;实例：acl image_service hdr_dom(host) -i img.example.com&emsp;&emsp;ACL名称，可以使用大字母A-Z、小写字母a-z、数字0-9、冒号：、点.、中横线和下划线，并且严格区分大小写，比如Image_site和image_site完全是两个acl。 ACL-criterion&emsp;&emsp;定义ACL匹配规范 123456789101112hdr（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：完全匹配字符串hdr_beg（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：前缀匹配hdr_dir（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：路径匹配hdr_dom（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：域匹配hdr_end（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：后缀匹配hdr_len（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：长度匹配hdr_reg（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：正则表达式匹配hdr_sub（[&amp;ltname&amp;gt [，&amp;ltocc&amp;gt]]）：子串匹配dst 目标IPdst_port 目标PORTsrc 源IPsrc_port 源PORT &emsp;&emsp;示例: 123456hdr &amp;ltstring&amp;gt用于测试请求头部首部指定内容hdr_dom(host) 请求的host名称，如 www.example.comhdr_beg(host) 请求的host开头，如 www. img. video. download. ftp.hdr_end(host) 请求的host结尾，如 .com .net .cnpath_beg 请求的URL开头，如/static、/images、/img、/csspath_end 请求的URL中资源的结尾，如 .gif .png .css .js .jpg .jpeg ACL-flags&emsp;&emsp;ACL匹配模式&emsp;&emsp;&emsp;&emsp;-i 不区分大小写&emsp;&emsp;&emsp;&emsp;-m 使用指定的pattern匹配方法&emsp;&emsp;&emsp;&emsp;-n 不做DNS解析&emsp;&emsp;&emsp;&emsp;-u 禁止acl重名，否则多个同名ACL匹配或关系 ACL-operator&emsp;&emsp;ACL 操作符 12345678整数比较：eq、ge、gt、le、lt字符比较： exact match (-m str) :字符串必须完全匹配模式 substring match (-m sub) :在提取的字符串中查找模式，如果其中任何一个被发现，ACL将匹配 prefix match (-m beg) :在提取的字符串首部中查找模式，如果其中任何一个被发现，ACL将匹配 suffix match (-m end) :将模式与提取字符串的尾部进行比较，如果其中任何一个匹配，则ACL进行匹配 subdir match (-m dir) :查看提取出来的用斜线分隔（“/”）的字符串，如果其中任何一个匹配，则ACL进行匹配 domain match (-m dom) :查找提取的用点（“.”）分隔字符串，如果其中任何一个匹配，则ACL进行匹配 ACL-value&emsp;&emsp;value的类型 12345678910111213The ACL engine can match these types against patterns of the following types : Boolean #布尔值 integer or integer range #整数或整数范围，比如用于匹配端口范围 IP address / network #IP地址或IP范围, 192.168.0.1 ,192.168.0.1/24 string exact –精确比较 substring—子串 www.example.com suffix-后缀比较 prefix-前缀比较 subdir-路径， /wp-includes/js/jquery/jquery.js domain-域名，www.example.com regular expression #正则表达式 hex block #16进制 ACL调用方式&emsp;&emsp;ACL调用方式： 与：隐式（默认）使用 或：使用“or” 或 “||”表示 否定：使用“!“ 表示 &emsp;&emsp;示例： 123if valid_src valid_port #与关系if invalid_src || invalid_port #或if ! invalid_src #非 ACL具体示例域名匹配:123456789101112131415listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog acl web_host hdr_dom(host) www.magedu.net use_backend magedu_host if web_host default_backend default_webbackend magedu_host mode http server web1 192.168.32.81:80 check inter 2000 fall 3 rise 5 backend default_web mode http server web2 192.168.32.82:80 check inter 2000 fall 3 rise 5 匹配浏览器类型:&emsp;&emsp;匹配客户端浏览器，将不同类型的浏览器调动至不同的服务器组 1234567891011121314151617listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog acl web_host hdr_dom(host) www.magedu.net use_backend magedu_host if web_host acl redirect_test hdr(User-Agent) -m sub -i "Mozilla/5.0 (Windows NT 6.1; WOW64;Trident/7.0; rv:11.0) like Gecko" redirect prefix http://192.168.7.103 if redirect_test default_backend default_webbackend magedu_host mode http server web1 192.168.32.81:80 check inter 2000 fall 3 rise 5backend default_web mode http server web2 192.168.32.82:80 check inter 2000 fall 3 rise 5 基于文件后缀名实现动静分离:1234567891011121314151617181920listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog acl php_server path_end -i .php use_backend php_server_host if php_server acl image_server path_end -i .jpg .png .jpeg .gif use_backend image_server_host if image_server default_backend default_webbackend php_server_host mode http server web1 192.168.32.81 check inter 2000 fall 3 rise 5backend image_server_host mode http server web1 192.168.32.82 check inter 2000 fall 3 rise 5backend default_web mode http server web1 192.168.32.8:80 check inter 2000 fall 3 rise 5 匹配访问路径实现动静分离:123456789101112131415listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog acl static_path path_beg -i /static /images /javascript use_backend static_path_host if static_path default_backend default_webbackend static_path_host mode http server web1 192.168.32.81 check inter 2000 fall 3 rise 5backend default_web mode http server web1 192.168.32.8:80 check inter 2000 fall 3 rise 5 预定义ACL预定义ACL： ACLname Equivalent to Usage FALSE always_false never match HTTP req_proto_http match if protocol is valid HTTP HTTP_1.0 req_ver 1.0 match HTTP version 1.0 HTTP_1.1 req_ver 1.1 match HTTP version 1.1 HTTP_CONTENT hdr_val(content-length) gt 0 match an existing content-length HTTP_URL_ABS url_reg ^[^/:]*: // match absolute URL with scheme HTTP_URL_SLASH url_beg / match URL beginning with “/“ HTTP_URL_STAR url * match URL equal to “*” LOCALHOST src 127.0.0.1/8 match connection from local host METH_CONNECT method CONNECT match HTTP CONNECT method METH_DELETE method DELETE match HTTP DELETE method METH_GET method GET HEAD match HTTP GET or HEAD method METH_HEAD method HEAD match HTTP HEAD method METH_OPTIONS method OPTIONS match HTTP OPTIONS method METH_POST method POST match HTTP POST method METH_PUT method PUT match HTTP PUT method METH_TRACE method TRACE match HTTP TRACE method RDP_COOKIE req_rdp_cookie_cnt gt 0 match presence of an RDP cookie REQ_CONTENT req_len gt 0 match data in the request buffer TRUE always_true always match WAIT_END wait_end wait for end of content analysis &emsp;&emsp;预定义ACL使用示例 123456789101112131415161718listen web_host bind 172.18.32.249:80 mode http balance roundrobin log global option httplog acl static_path path_beg -i /static /images /javascript use_backend static_path_host if HTTP_1.1 TRUE static_path default_backend default_webbackend php_server_host mode http server web1 192.168.32.81 check inter 2000 fall 3 rise 5backend static_path_host mode http server web1 192.168.32.82 check inter 2000 fall 3 rise 5backend default_web mode http server web1 192.168.32.8:80 check inter 2000 fall 3 rise 5 &emsp;&emsp;详细信息查看官网http://cbonte.github.io/haproxy-dconv/2.0/configuration.html#7.4]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>企业级应用</tag>
        <tag>HAProxy</tag>
        <tag>负载均衡</tag>
        <tag>调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业级应用：负载均衡层——haproxy(一)]]></title>
    <url>%2F%2Fblog%2F5aeb7732.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;HAProxy是法国开发者 威利塔罗(Willy Tarreau) 在2000年使用C语言开发的一个开源软件，是一款具备高并发(一万以上)、高性能的TCP&gt;和HTTP负载均衡器，支持基于cookie的持久性，自动故障切换，支持正则表达式及web状态统计。&emsp;&emsp;HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。&emsp;&emsp;包括 GitHub、Bitbucket、Stack Overflow、Reddit、Tumblr、Twitter和 Tuenti[7]在内的知名网站，及亚马逊网络服务系统都使用了HAProxy。 HAProxy功能HAProxy功能： TCP和HTTP反向代理 SSL/TSL服务器 可以针对HTTP请求添加cookie，进行路由后端服务器 可平衡负载至后端服务器，并支持持久连接 支持所有主服务器故障切换至备用服务器 支持专用端口实现监控服务 支持不影响现有连接情况下停止接受新连接请求 可以在双向添加，修改或删除HTTP报文首部 响应报文压缩 支持基于pattern实现连接请求的访问控制 通过特定的URI为授权用户提供详细的状态信息 不具备的功能： 正向代理–squid，nginx 缓存代理–varnish web服务–nginx、tengine、apache、php、tomcat UDP–目前不支持UDP协议，2.1版本会支持UDP协议代理 单机性能–LVS HAProxy安装&emsp;&emsp;HAProxy 支持基于lua实现功能扩展，lua是一种小巧的脚本语言，于1993年由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组开发，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。&emsp;&emsp;由于centos自带的lua版本比较低并不符合HAProxy要求的lua最低版本(5.3)的要求，因此需要编译安装较新版本的lua环境，然后才能编译安装HAProxy。 安装lua环境&emsp;&emsp;配置lua环境 1yum install libtermcap-devel ncurses-devel libevent-devel readline-devel gcc make &emsp;&emsp;下载lua源码tar包 1wget http://www.lua.org/ftp/lua-5.3.5.tar.gz &emsp;&emsp;编译安装lua 123tar xvf lua-5.3.5.tar.gzcd lua-5.3.5make linux test 安装HAProxy&emsp;&emsp;下载haproxy源码包 1wget http://www.haproxy.org/download/2.0/src/haproxy-2.0.8.tar.gz &emsp;&emsp;安装依赖包 1yum install gcc gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel systemd-devel &emsp;&emsp;（附加工具包net-tools vim iotop bc zip unzip zlib-devel lrzsz tree screen lsof tcpdump wget ntpdate）&emsp;&emsp;编译安装haproxy&emsp;&emsp;cd haproxy-2.0.8&emsp;&emsp;HAProxy 1.8及1.9版本编译参数： 12345678make ARCH=x86_64 \TARGET=linux2628 \USE_PCRE=1 \USE_OPENSSL=1 \USE_ZLIB=1 \USE_SYSTEMD=1 \USE_CPU_AFFINITY=1 \PREFIX=/apps/haproxy &emsp;&emsp;HAProxy 2.0编译参数： 12345678910make ARCH=x86_64 \TARGET=linux-glibc USE_PCRE=1 \USE_OPENSSL=1 \USE_ZLIB=1 \USE_SYSTEMD=1 \USE_CPU_AFFINITY=1 \USE_LUA=1 \LUA_INC=/data/tar/lua-5.3.5/src/ \LUA_LIB=/data/tar/lua-5.3.5/src/ \PREFIX=/apps/haproxy 12make install PREFIX=/apps/haproxycp haproxy /usr/sbin/ &emsp;&emsp;haproxy启动脚本&emsp;&emsp;vim /usr/lib/systemd/system/haproxy.service 123456789[Unit]Description=HAProxy Load BalancerAfter=syslog.target network.target[Service]ExecStartPre=/usr/sbin/haproxy -f /etc/haproxy/haproxy.cfg -c -qExecStart=/usr/sbin/haproxy -Ws -f /etc/haproxy/haproxy.cfg -p /var/lib/haproxy/haproxy.pidExecReload=/bin/kill -USR2 $MAINPID[Install]WantedBy=multi-user.target\ &emsp;&emsp;haproxy配置文件(基本配置文件)&emsp;&emsp;mkdir /etc/haproxy&emsp;&emsp;vim /etc/haproxy/haproxy.cfg 12345678910111213141516171819202122232425262728293031323334353637383940global chroot /apps/haproxy #锁定运行目录 stats socket /var/lib/haproxy/haproxy.sock mode 600 level admin #socket文件 uid 99 #运行haproxy的用户身份，也可设user，group gid 99 daemon #以守护进程运行# nbproc 4 #指定每个haproxy进程开启的线程数，默认为每个进程一个线程# cpu-map 1 0 #绑定haproxy 进程至指定CPU# cpu-map 2 1# cpu-map 3 2# cpu-map 4 3maxconn 100000 #每个haproxy进程的最大并发连接数#maxsslconn #每个haproxy进程ssl最大连接数,用于haproxy配置了证书的场景下#spread-checks #后端server状态check随机提前或延迟百分比时间，建议2-5(20%-50%)之间pidfile /var/lib/haproxy/haproxy.pidlog 127.0.0.1 local3 info #定义全局的syslog服务器；最多可以定义两个defaults option http-keep-alive option forwardfor maxconn 100000 mode http timeout connect 300000ms timeout client 300000ms timeout server 300000mslisten stats mode http bind 0.0.0.0:9999 stats enable log global stats uri /haproxy-status stats auth haadmin:q1w2e3r4yslisten web_port bind 192.168.32.84:80 mode http log global server web1 127.0.0.1:8080 check inter 3000 fall 2 rise 5 &emsp;&emsp;设置haproxypid及socket创建权限&emsp;&emsp;useradd -s /sbin/nologin -r -u 99 haproxy&emsp;&emsp;mkdir /var/lib/haproxy&emsp;&emsp;chown 99.99 /var/lib/haproxy/ -R &emsp;&emsp;至此，才完成haproxy的安装与配置,启动并查看haproxy的状态是否正常吧。&emsp;&emsp;systemctl enable --now haproxy&emsp;&emsp;systemctl status haproxy 配置web均衡&emsp;&emsp;haproxy最主要的功能就是为后端服务器做反向代理，例如我们要为后面的四个web服务器做反向代理，配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960global maxconn 100000 chroot /apps/haproxy stats socket /var/lib/haproxy/haproxy.sock1 mode 600 level admin process 1 stats socket /var/lib/haproxy/haproxy.sock2 mode 600 level admin process 2 uid 99 gid 99 daemon nbproc 2 #指定每个haproxy进程开启的线程数，默认为每个进程一个线程 cpu-map 1 0 #cpu工作线程绑定 cpu-map 2 1# cpu-map 3 2# cpu-map 4 3 pidfile /var/lib/haproxy/haproxy.pid log 127.0.0.1 local3 infodefaults option redispatch #当server Id对应的服务器挂掉后，强制定向到其他健康的服务器 option abortonclose #当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接 option http-keep-alive #开启与客户端的会话保持 option forwardfor #透传客户端真实IP至后端web服务器 mode http #默认工作类型 timeout connect 600s #客户端请求到后端server的最长连接等待时间(TCP之前) timeout server 600s #客户端请求到后端服务端的超时超时时长（TCP之后） timeout client 600s #与客户端的最长非活动时间 timeout http-keep-alive 120s #session会话保持超时时间，范围内会转发到相同的后端服务器 timeout check 50s #对后端服务器的检测超时时间option http-keep-alive#frontend WEB_PORT_80# bind 192.168.32.84:80# mode http# use_backend web_prot_http_nodes#backend web_prot_http_nodes# mode http# option forwardfor# balance static-rr# server web0 192.168.32.8:80 check inter 3000 fall 3 rise 5# server web3 192.168.32.83:80 check inter 3000 fall 3 rise 5# server web2 192.168.32.82:80 check inter 3000 fall 3 rise 5# server web1 192.168.32.81:80 check inter 3000 fall 3 rise 5listen stats bind 0.0.0.0:9999 mode http stats enable log global stats uri /proxy_status #进入后台状态页url路径 stats auth haadmin:hapasswd #进入后台的账号密码listen web_host #使用listen替换frontend+backend的配置方式 bind 192.168.32.84:80 mode http log global balance roundrobin #定义调度算法为roundrobin server web0 192.168.32.8:80 weight 1 check addr 192.168.32.8 port 9000 inter 3000 fall 2 rise 5 server web1 192.168.32.81:80 weight 1 check addr 192.168.32.81 port 9000 inter 3000 fall 2 rise 5 server web2 192.168.32.82:80 weight 1 check addr 192.168.32.82 port 9000 inter 3000 fall 2 rise 5 server web3 192.168.32.83:80 weight 1 check addr 192.168.32.83 port 9000 inter 3000 fall 2 rise 5 &emsp;&emsp;重启服务systemctl restart haproxy,便可登陆本机的状态页(haadmin:hapasswd)查看后端服务器状态。 &emsp;&emsp;刷新几次可以看到，不同pid也就是不同线程提供的status页面。 配置详解globe 全局配置段123进程及安全配置相关的参数性能调整相关参数Debug参数 &emsp;&emsp;全局配置一般大多类似不用多说，须注意的是nbproc若开启多线程，socket设置最好也分开设置，最好每个线程用process #指定固定的socket，方便后期用命令行socat工具管理(echo &quot;disable server web_host/web1&quot; | socat stdio /var/lib/haproxy/haproxy.sock2)，例如： 12345678910111213globalmaxconn 100000chroot /apps/haproxystats socket /var/lib/haproxy/haproxy.sock1 mode 600 level admin process 1stats socket /var/lib/haproxy/haproxy.sock2 mode 600 level admin process 2uid 99gid 99daemonnbproc 2 #指定每个haproxy进程开启的线程数，默认为每个进程一个线程cpu-map 1 0 #cpu工作线程绑定cpu-map 2 1pidfile /var/lib/haproxy/haproxy.pidlog 127.0.0.1 local3 info &emsp;&emsp;其他详细信息参见官方文档：https://cbonte.github.io/haproxy-dconv/2.0/intro.html proxies：代理配置段1234defaults [&amp;ltname&amp;gt] #默认配置项，针对以下的frontend、backend和lsiten生效，可以多个namefrontend &amp;ltname&amp;gt #前端servername，类似于Nginx的一个虚拟主机 server。backend &amp;ltname&amp;gt #后端服务器组，等于nginx的upstreamlisten &amp;ltname&amp;gt #将frontend和backend合并在一起配置 &emsp;&emsp;注：name字段只能使用”-”、”_”、”.”、和”:”，并且严格区分大小写，例如：Web和web是完全不同的两组服务器。 defaults option redispatch #当server Id对应的服务器挂掉后，强制定向到其他健康的服务器option abortonclose #当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接option http-keep-alive #开启与客户端的会话保持option forwardfor #透传客户端真实IP至后端web服务器mode http #默认工作类型timeout connect 120s #客户端请求到后端server的最长连接等待时间(TCP之前)timeout server 600s #客户端请求到后端服务端的超时超时时长（TCP之后）timeout client 600s #与客户端的最长非活动时间timeout http-keep-alive 120s #session 会话保持超时时间，范围内会转发到相同的后端服务器timeout check 5s #对后端服务器的检测超时时间 frontend bind：指定HAProxy的监听地址，可以是IPV4或IPV6，可以同时监听多个IP或端口，可同时用于listen字段中 1bind [&amp;ltaddress&amp;gt]:&amp;ltport_range&amp;gt [, ...] [param*] 1234listen http_proxy #监听http的多个IP的多个端口和sock文件 bind :80,:443,:8801-8810 bind 10.0.0.1:10080,10.0.0.1:10443 bind /var/run/ssl-frontend.sock user root mode 600 accept-proxy 123listen http_https_proxy #https监听 bind :80 bind :443 ssl crt /etc/haproxy/site.pem 1234listen http_https_proxy_explicit #监听ipv6、ipv4和unix sock文件 bind ipv6@:80 bind ipv4@public_ssl:443 ssl crt /etc/haproxy/site.pem bind unix@ssl-frontend.sock user root mode 600 accept-proxy 12listen external_bind_app1 #监听file descriptor bind "fd@$&#123;FD_APP1&#125;" &emsp;&emsp;企业生产示例： 12345frontend WEB_PORT bind :80,:8080 bind 192.168.7.102:10080,:8801-8810,192.168.7.101:9001-9010 mode http/tcp #指定负载协议类型 use_backend backend_name #调用的后端服务器组名称 backend定义一组后端服务器，backend服务器将被frontend进行调用。123mode http/tcp #指定负载协议类型option #配置选项server #定义后端real server &emsp;&emsp;注意：mode要与frontend一致。option后面加httpchk，smtpchk,mysql-check,pgsql-check，ssl-hello-chk方法，可用于实现更多应用层检测功能。 123456789101112check #对指定real进行健康状态检查，默认不开启 addr IP #可指定的健康状态监测IP port num #指定的健康状态监测端口 inter num #健康状态检查间隔时间，默认2000 ms fall num #后端服务器失效检查次数，默认为3 rise num #后端服务器从下线恢复检查次数，默认为2weight #默认为1，最大值为256，0表示不参与负载均衡backup #将后端服务器标记为备份状态disabled #将后端服务器标记为不可用状态redirect prefix http://www.example.net/ #将请求临时重定向至其它URL，只适用于http模式maxconn &amp;ltmaxconn&amp;gt：当前后端server的最大并发连接数backlog &amp;ltbacklog&amp;gt：当server的连接数达到上限后的后援队列长度 &emsp;&emsp;frontend+backend配置实例： 12345678910#官网业务访问入口======================================frontend WEB_PORT_80 bind 192.168.7.248:80 mode http use_backend web_prot_http_nodesbackend web_prot_http_nodes mode http option forwardfor server 192.168.7.101 192.168.7.101:8080 check inter 3000 fall 3 rise 5 server 192.168.7.102 192.168.7.102:8080 check inter 3000 fall 3 rise 5 listenlisten相当于frontend+backend的结合，即定义前端监听代理，又定义了后端服务器，例如上面的frontend+backend组合可用下面这种listen方式代替：1234567#官网业务访问入口=====================================listen WEB_PORT_80 bind 192.168.7.102:80 mode http option forwardfor server web1 192.168.7.101:80 check inter 3000 fall 3 rise 5 server web2 192.168.7.101:80 check inter 3000 fall 3 rise 5 haproxy调度算法&emsp;&emsp;HAProxy通过固定参数balance指明对后端服务器的调度算法，该参数可以配置在listen或backend选项中。&emsp;&emsp;HAProxy的调度算法分为静态和动态调度算法，但是有些算法可以根据参数在静态和动态算法中相互转换。 静态算法 static-rr基于权重的轮询调度，不支持权重的运行时调整及后端服务器慢启动，其后端主机数量没有限制 first根据服务器在列表中的位置，自上而下进行调度，但是其只会当第一台服务器的连接数达到上限，新请求才会分配给下一台服务，因此会忽略服务器的权重设置。（生产不常用） 动态算法 roundrobin基于权重的轮询动态调度算法，支持权重的运行时调整，不完全等于lvs中的rr轮训模式，HAProxy中的roundrobin支持慢启动(新加的服务器会逐渐增加转发数)，其每个后端backend中最多支持4095个real server，roundrobin为默认调度算法，且支持对real server权重动态调整。 leastconn加权的最少连接的动态，支持权重的运行时调整和慢启动，即当前后端服务器连接最少的优先调度(新客户端连接)，比较适合长连接的场景使用，比如MySQL等场景。 其他算法source&emsp;&emsp;源地址hash，基于用户源地址hash并将请求转发到后端服务器，默认为静态即取模方式，但是可以通过hash-type支持的选项更改，后续同一个源地址请求将被转发至同一个后端web服务器，比较适用于session保持/缓存业务等场景。&emsp;&emsp;源地址有两种转发客户端请求到后端服务器的服务器选取计算方式，分别是取模法和一致性hash map-base取模法&emsp;&emsp;map-based：取模法，基于服务器总权重的hash数组取模，该hash是静态的即不支持在线调整权重，不支持慢启动，其对后端服务器调度均衡，缺点是当服务器的总权重发生变化时，即有服务器上线或下线，都会因权重发生变化而导致调度结果整体改变。&emsp;&emsp;所谓取模运算，就是计算两个数相除之后的余数，10%7=3, 7%4=3，(2^32-1)%(1+1+2)&emsp;&emsp;取模法示意图：取模法配置示例： 1234567listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode tcp log global balance source server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 一致性hash&emsp;&emsp;一致性哈希，该hash是动态的，支持在线调整权重，支持慢启动，优点在于当服务器的总权重发生变化时，对调度结果影响是局部的，不会引起大的变动，hash（o）mod n 。&emsp;&emsp;Hash对象到后端服务器的映射关系：&emsp;&emsp;一致性hash后端服务器在线与离线的调度方式示意图：&emsp;&emsp;一致性hash配置示例： 12345678listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode tcp log global balance source hash-type consistent server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 uri&emsp;&emsp;基于对用户请求的uri做hash并将请求转发到后端指定服务器，也可以通过map-based和consistent定义使用取模法还是一致性hash。&emsp;&emsp;uri 取模法配置示例： 1234567listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance uri server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 &emsp;&emsp;uri 一致性hash配置示例： 12345678listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance uri hash-type consistent server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 url_param&emsp;&emsp;url_param对用户请求的url中的 params 部分中的参数name作hash计算，并由服务器总权重相除以后派发至某挑出的服务器；通常用于追踪用户，以确保来自同一个用户的请求始终发往同一个real server 1234假设url = http://www.example.com/foo/bar/index.php?k1=v1&amp;k2=v2则：host = "www.example.com"url_param = "k1=v1&amp;k2=v2" &emsp;&emsp;url_param取模法配置示例: 1234567listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance url_param name,age #支持对单个及多个url_param 值hash server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 &emsp;&emsp;url_param一致性hash配置示例： 12345678listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance url_param name,age #支持对单个及多个url_param 值hash hash-type consistent server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 hdr&emsp;&emsp;针对用户每个http头部(header)请求中的指定信息做hash，此处由 name 指定的http首部将会被取出并做hash计算，然后由服务器总权重相除以后派发至某挑出的服务器，假如无有效的值，则会使用默认的轮询调度。&emsp;&emsp;hdr取模法配置示例： 1234567listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance hdr(User-Agent) server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 一致性hash配置示例： 12345678listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance hdr(User-Agent) hash-type consistent server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 rdp-cookie&emsp;&emsp;rdp-cookie对远程桌面的负载，使用cookie保持会话&emsp;&emsp;rdp-cookie取模法配置示例： 12345listen RDP bind 192.168.7.101:3389 balance rdp-cookie mode tcp server rdp0 172.18.132.20:3389 check fall 3 rise 5 inter 2000 weight 1 &emsp;&emsp;rdp-cookie一致性hash配置示例： 123456listen RDP bind 192.168.7.101:3389 balance rdp-cookie hash-type consistent mode tcp server rdp0 172.18.132.20:3389 check fall 3 rise 5 inter 2000 weight 1 &emsp;&emsp;基于iptables实现： 123net.ipv4.ip_forward = 1# iptables -t nat -A PREROUTING -d 192.168.7.101 -p tcp --dport 3389 -j DNAT --todestination 172.18.139.20:3389# iptables -t nat -A POSTROUTING -s 192.168.0.0/21 -j SNAT --to-source 192.168.7.101 random&emsp;&emsp;在1.9版本开始增加一个叫做random的负载平衡算法，其基于一个随机数作为一致性hash的key，随机负载平衡对于大型服务器场或经常添加或删除服务器非常有用，因为它可以避免在这种情况下由roundrobin或leastconn导致的锤击效应。&emsp;&emsp;random配置实例： 1234567listen web_host bind 192.168.7.101:80,:8801-8810,192.168.7.101:9001-9010 mode http log global balance random server web1 192.168.7.103:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.7.104:80 weight 1 check inter 3000 fall 2 rise 5 算法总结12345678910static-rr---------&gt;tcp/http 静态first-------------&gt;tcp/http 静态roundrobin--------&gt;tcp/http 动态leastconn---------&gt;tcp/http 动态random------------&gt;tcp/http 动态source------------&gt;tcp/httpUri---------------&gt;httpurl_param---------&gt;http 取决于hash_type是否consistenthdr---------------&gt;httprdp-cookie--------&gt;tcp 12345678910first #使用较少static-rr #做了session共享的web集群roundrobinrandomleastconn #数据库source #基于客户端公网IP的会话保持Uri---------------&gt;http #缓存服务器，CDN服务商，蓝汛、百度、阿里云、腾讯url_param---------&gt;httphdr #基于客户端请求报文头部做下一步处理rdp-cookie #很少使用 &emsp;&emsp;详细可参见官方文档：https://cbonte.github.io/haproxy-dconv/2.0/configuration.html#4 haproxy工作模式tcp：四层负载&emsp;&emsp;在四层负载设备中，把client发送的报文目标地址(原来是负载均衡设备的IP地址)，根据均衡设备设置的选择web服务器的规则选择对应的web服务器IP地址，这样client就可以直接跟此服务器建立TCP连接并发送数据。 四层工作模式的IP透传：&emsp;&emsp;haproxy配置中在后端服务器定义中加入关键字send-proxy（注意不要加在check关键字属性的中间了），并重启服务。&emsp;&emsp;在后端nginx服务器配置中监听端口处也加上协议名proxy_protocol,并修改日志格式，在开头加入变量$proxy_protocol_addr，重启服务后即可在日志中看到访问的源地址。&emsp;&emsp;send-proxy是haproxy后端设置的关键字，写错会报错，可以用来启用代理协议Proxy protocol。Proxy protocol是HAProxy的作者Willy Tarreau于2010年开发和设计的一个Internet协议，通过为tcp添加一个很小的头信息，来方便的传递客户端信息（协议栈、源IP、目的IP、源端口、目的端口等)，在网络情况复杂又需要获取用户真实IP时非常有用。 12345678910111213141516haproxy 配置：listen web_prot_http_nodes bind 172.18.32.249:80 mode tcp balance roundrobin server web1 192.168.32.81:80 send-proxy check inter 3000 fall 3 rise 5nginx配置：http &#123; log_format main '$proxy_protocol_addr $remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" ';server &#123; listen 80 proxy_protocol; #listen 80; 内核参数优化&emsp;&emsp;haproxy在做四层负载时，如果要监听bind由keepalived生成的虚拟IP（VIP）时，需要修改内核参数，支持监听非本机IP，否则监听VIP的80端口时会导致haproxy服务无法启动。。&emsp;&emsp;vim /etc/sysctl.conf 1net.ipv4.ip_nonlocal_bind = 1 &emsp;&emsp;如果多网卡，且VIP与后端VIP不在一个网段，还需要加上地址转发参数。 1net.ipv4.ip_forward = 1 &emsp;&emsp;然后sysctl -p使配置文件生效。 1234[root@CentOS8 ~]#sysctl -pnet.ipv4.ip_nonlocal_bind = 1net.ipv4.ip_forward = 1[root@CentOS8 ~]# &emsp;&emsp;当然，也可以将haproxy改为监听0.0.0.0:80，表示监听本机所有网卡的IP的80端口，当keepalived的VIP漂到本机是，自然也可以被haproxy监听，没有时也不影响启动。不过这样的话，haproxy只能对一个项目集群做负载均衡了，而我们实际生产中，都是同时代理多个服务项目集群的转发，需通过bind不同IP的80/443端口来实现，如果直接一个服务bind0.0.0.0：80，占用了所有的80/443端口，显然就没法和其他项目共存了。&emsp;&emsp;所以我们建议在四层负载工作模式下，不要监听0.0.0.0:80，而是监听指定的VIP。 http：七层代理&emsp;&emsp;七层负载均衡服务器起了一个反向代理服务器的作用，服务器建立一次TCP连接要三次握手，而client要访问webserver要先与七层负载设备进行三次握手后建立TCP连接，把要访问的报文信息发送给七层负载均衡；然后七层负载均衡再根据设置的均衡规则选择特定的webserver，然后通过三次握手与此台webserver建立TCP连接，然后webserver把需要的数据发送给七层负载均衡设备，负载均衡设备再把数据发送给client；所以，七层负载均衡设备起到了代理服务器的作用。 七层工作模式的IP透传：1234567891011121314haproxy 配置：defaults option forwardfor或者： option forwardfor header X-Forwarded-xxx #自定义传递IP参数,后端web服务器写X-Forwardedxxx #如果写option forwardfor则后端服务器web格式为X-Forwarded-Forlisten配置：listen web_host bind 192.168.7.101:80 mode http log global balance random server web1 192.168.32.81:80 weight 1 check inter 3000 fall 2 rise 5 server web2 192.168.32.82:80 weight 1 check inter 3000 fall 2 rise 5 &emsp;&emsp;配置web服务器，记录负载均衡透传的客户端IP地址 123456789#apache 配置： LogFormat "%&#123;X-Forwarded-For&#125;i %a %l %u %t \"%r\" %&gt;s %b \"%&#123;Referer&#125;i\" \"%&#123;UserAgent&#125;i\"" combined#tomcat 配置： pattern='%&#123;X-Forwarded-For&#125;i %l %T %t &amp;quot;%r&amp;quot; %s %b &amp;quot;%&#123;UserAgent&#125;i&amp;quot;'/&gt;#nginx 日志格式： http &#123; log_format main '"$http_x_forwarded_For" - $remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" '; haproxy功能实现&emsp;&emsp;初步调整好haproxy的配置文件之后，启动haproxy服务，就已经可以对后端服务器进行代理来实现负载均衡了，不过很多情况下我们需要对后端服务器进行动态操作，例如修改某些主机的负载权重，对某些主机上线或下线等等，而这时，再不影响业务正常访问的情况下，对haproxy动态操作方式一般有两种：在图形界面status状态页下操作，以及使用socat命令行工具通过socket通信。 图形界面&emsp;&emsp;想实现在status界面拥有修改权限，需在配置文件中加入选项stats admin if TRUE。注意，TRUE要大写，否则服务起不来会报错parsing [/etc/haproxy/haproxy.cfg:52] : error detected while parsing a &#39;stats admin&#39; rule : no such ACL : &#39;true&#39;.&emsp;&emsp;最终如下面所示 12345678listen stats mode http bind 0.0.0.0:9999 stats enable log global stats uri /proxy_status stats auth haadmin:hapasswd stats admin if TRUE &emsp;&emsp;这是再刷新status界面，就可以看到界面已经发生了变化&emsp;&emsp;就可以对选择的主机进行操作了。 命令行方式&emsp;&emsp;这是通过直接与haproxy的socekt通信，socket路径就是配置文件中指定的socket路径了，只支持本地通信。而且这需要借主socat的工具，需要先进行安装socat工具。 1yum install socat &emsp;&emsp;用echo信息的方式通过管道传递给socat工具指定haproxy的socket，就可以发送与接收haproxy的信息了。&emsp;&emsp;查看haproxy工作的详细信息 1echo "show info" | socat stdio /var/lib/haproxy/haproxy.sock1 &emsp;&emsp;查看haproxy控制命令 1echo "help" | socat stdio /var/lib/haproxy/haproxy.sock1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465help : this messageprompt : toggle interactive mode with promptquit : disconnectshow tls-keys [id|*]: show tls keys references or dump tls ticket keys when id specifiedset ssl tls-key [id|keyfile] &amp;lttlskey&amp;gt: set the next TLS key for the &amp;ltid&amp;gt or &amp;ltkeyfile&amp;gt listener to &amp;lttlskey&amp;gtshow sess [id] : report the list of current sessions or dump this sessionshutdown session : kill a specific sessionshutdown sessions server : kill sessions on a serverclear counters : clear max statistics counters (add 'all' for all counters)show info : report information about the running process [json|typed]show stat : report counters for each proxy and server [json|typed]show schema json : report schema used for statsdisable agent : disable agent checks (use 'set server' instead)disable health : disable health checks (use 'set server' instead)disable server : disable a server for maintenance (use 'set server' instead)enable agent : enable agent checks (use 'set server' instead)enable health : enable health checks (use 'set server' instead)enable server : enable a disabled server (use 'set server' instead)set maxconn server : change a server's maxconn settingset server : change a server's state, weight or addressget weight : report a server's current weightset weight : change a server's weight (deprecated)show resolvers [id]: dumps counters from all resolvers section and associated name serversclear table : remove an entry from a tableset table [id] : update or create a table entry's datashow table [id]: report table usage stats or dump this table's contentsshow peers [peers section]: dump some information about all the peers or this peers sectiondisable frontend : temporarily disable specific frontendenable frontend : re-enable specific frontendset maxconn frontend : change a frontend's maxconn settingshow servers state [id]: dump volatile server information (for backend &amp;ltid&amp;gt)show backend : list backends in the current running configshutdown frontend : stop a specific frontendset dynamic-cookie-key backend : change a backend secret key for dynamic cookiesenable dynamic-cookie backend : enable dynamic cookies on a specific backenddisable dynamic-cookie backend : disable dynamic cookies on a specific backendshow errors : report last request and response errors for each proxyset maxconn global : change the per-process maxconn settingset rate-limit : change a rate limiting valueset severity-output [none|number|string] : set presence of severity level in feedback informationset timeout : change a timeout settingshow env [var] : dump environment variables known to the processshow cli sockets : dump list of cli socketsshow cli level : display the level of the current CLI sessionshow fd [num] : dump list of file descriptors in useshow activity : show per-thread activity stats (for support/developers)operator : lower the level of the current CLI session to operatoruser : lower the level of the current CLI session to usershow startup-logs : report logs emitted during HAProxy startupshow cache : show cache statusadd acl : add acl entryclear acl &amp;ltid&amp;gt : clear the content of this acldel acl : delete acl entryget acl : report the patterns matching a sample for an ACLshow acl [id] : report available acls or dump an acl's contentsadd map : add map entryclear map &amp;ltid&amp;gt : clear the content of this mapdel map : delete map entryget map : report the keys and values matching a sample for a mapset map : modify map entryshow map [id] : report available maps or dump a map's contentsshow pools : report information about the memory pools usageshow profiling : show CPU profiling optionsset profiling : enable/disable CPU profilingshow threads : show some threads debugging information &emsp;&emsp;查看线程1工作下的web_host集群中web1主机的权重 1234[root@CentOS8 ~]#echo "get weight web_host/web1" | socat stdio /var/lib/haproxy/haproxy.sock11 (initial 1)[root@CentOS8 ~]# &emsp;&emsp;设置线程2工作下的web_host集群中web1主机的权重为2。设置时，不回应信息，说明设置成功。 123[root@CentOS8 ~]#echo "set weight web_host/web1 2" | socat stdio /var/lib/haproxy/haproxy.sock2[root@CentOS8 ~]# &emsp;&emsp;需要注意的一点就是，多线程工作模式下，每个线程是独立的，设置1线程的权重，在其他线程上并不生效。这就意味着，如果想将某个服务器下线的话，需要在每个线程上都分别下线，上线是，也需要在每个线程中enable server。可以用脚本写一个循环来实现。]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>企业级应用</tag>
        <tag>HAProxy</tag>
        <tag>负载均衡</tag>
        <tag>调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报错：Header V3 RSA_SHA256 Signature, key ID 2f86d6a1_ NOKEY]]></title>
    <url>%2F%2Fblog%2F5da16ceb.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;博主在CentOS8上dnf安装PHP的依赖包libmcrypt-devel的时候，死活装不上，一直报错。看了下说是依赖项libmcrypt装不上，报错原因说的是是秘钥校验时缺少主机名。这很奇怪，因为用的是阿里的epel源，之前安装各种软件包都没问题，这次突然就秘钥验证不过了。 12345678910111213141516171819202122232425[root@CentOS8 php-7.3.10]#yum install libmcrypt-devel -yLast metadata expiration check: 0:01:31 ago on Sat 02 Nov 2019 07:47:12 PM CST.Dependencies resolved.===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: libmcrypt-devel x86_64 2.5.8-26.el8 aliyun 18 kInstalling dependencies: libmcrypt x86_64 2.5.8-26.el8 aliyun 109 kTransaction Summary=====================================================================================================================================Install 2 PackagesTotal size: 127 kInstalled size: 320 kDownloading Packages:[SKIPPED] libmcrypt-2.5.8-26.el8.x86_64.rpm: Already downloaded [SKIPPED] libmcrypt-devel-2.5.8-26.el8.x86_64.rpm: Already downloaded warning: /var/cache/dnf/aliyun-a19d7e5a690d289a/packages/libmcrypt-2.5.8-26.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 2f86d6a1: NOKEYaliyun 0.0 B/s | 0 B 00:00 Curl error (3): URL using bad/illegal format or missing URL for file://https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-8 [Invalid file://hostname/, expected localhost or 127.0.0.1 or none]The downloaded packages were saved in cache until the next successful transaction.You can remove cached packages by executing 'dnf clean packages'. &emsp;&emsp;查了下网上很多说法，不过都没有解决疑问。解决方案也五花八门，类似rpm --import /etc/pki/rpm-gpg/RPM*导入秘钥的，也有建议安装时加选项--force --nodeps忽略依赖关系的。秘钥导入没用，我本身yum源仓库配置文件也填写了阿里云镜像源的秘钥路径的。忽略依赖关系强制安装的话，担心会不按依赖项，导致其他别的问题，而且这个选项本身也报错了。&emsp;&emsp;后来只能干脆把秘钥检查关了，确实能装上了。&emsp;&emsp;vim /etc/yum.repos.d/aliyun.repo 12345name=aliyunbaseurl=https://mirrors.aliyun.com/epel/$releasever/Everything/$basearch/gpgcheck=0enabled=1gpgkey=file://https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-$releasever &emsp;&emsp;希望不是因为阿里的安装包被人动过而导致秘钥检查不通过吧，姑且相信吧。记录一下，等后期如果有问题或者有空再来排查原因。&emsp;&emsp;&emsp;&emsp;——————————————后记 ———————————–&emsp;&emsp;原来当时配置yum源文件的时候不小心画蛇添足了，导致gpgkey文件路径不对，应为gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-$releaseve，用file://的话，就不需要加协议了，直接写主机名或IP加路径。&emsp;&emsp;要时刻提醒自己还是要仔细，一直不出错不代表没错。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2019.11.10]]></content>
      <categories>
        <category>故障记录</category>
      </categories>
      <tags>
        <tag>故障</tag>
        <tag>记录</tag>
        <tag>排错</tag>
        <tag>epel</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx防盗链设置的一些细节]]></title>
    <url>%2F%2Fblog%2Fe4415633.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;防盗链的必要性，我这里就不再赘述了，这是网站设计的最基本要求。而在nginx中，一般比较容易实现的防盗链手段就是通过ungx_http_referer_module模块（查看官方文档） 检查访问请求的referer信息是否有效来实现防盗链功能。&emsp;&emsp;所谓referer检查，举个例子来说，在正常情况下当用户在浏览http://example.com/abc.html时点击一个链接去到http://example.com/123.mp3文件时，浏览器在发出请求123.mp3 资源时还会附带当刻浏览器所处的页面地址（即http://example.com/abc.html），所以当你的网站程序接收到下载 jacky.mp3 资源请求的时候，先判断http的referer字段的值，如果是从 自己的域名（example.com）过来的，则可以认为是合法的连接请求，否则就返回一个错误的提示信息。 &emsp;&emsp;这种方法通常用于图片、mp3这种容易被人用html“嵌入”到其他网站的资源，使用这种方法可以防止你的图片直接出现在别人的网页里（或者防止mp3直接被其他网站嵌入到flash播放器里），不过访客使用下载工具还是可以轻松下载，因为现在的下载工具一般会自动用你的域名构造一个引用地址，所以如果想再进一步防范的话，可以使用一个对应表限制每个资源的引用地址，例如将 123.mp3 的引用地址限制为http://example.com/abc.htmlid=123456，这样下载工具就不太可能构造一个“正确”的引用地址了。 referer&emsp;&emsp;要过滤掉盗链访问的referer信息，首先要明确知道，正常访问的referer有哪些。一般来说，正常的referer信息有以下四种： none：请求报文首部没有referer首部，比如用户直接在浏览器输入域名访问web网站，就没有referer信息。 blocked：请求报文有referer首部，但无有效值，比如为空。 本站链接：referer首部中包含本站域名。 搜索引擎跳转：referer中为 * .baidu. * 、 * .google. * 、及其他搜索引擎（如360、必应）（具体图片或mp3媒体文件，不希望被搜索引擎引用，可单独设置，主页等html页面建议允许搜索引擎跳转）&emsp;&emsp;所以根据官方文档,我们只需制定合适的匹配规则，将正常的访问放过，对那些“非正常的”盗链访问，返回403错误代码，即可实现防盗链。undefined 过滤规则设置&emsp;&emsp;打开nginx配置文件，找到想要定义的location下，加入下面设置123456789101112131415location /blog/ &#123; root /apps/nginx/html/; #定义路径 valid_referers none blocked server_names *.example.com ~\.google\. ~\.baidu\.; #设置允许访问的匹配规则,匹配规则可以写在一行，也可以分行写。 if ($invalid_referer) &#123; #设置条件判断，不符合上述规则的，返回403状态码 return 403; &#125;&#125;location ^~ /mp3/ &#123; alias /apps/nginx/html/blog/mp3/; #定义路径，也可用root valid_referers none blocked server_names *.example.com ; if ($invalid_referer) &#123; #设置条件判断，不符合上述规则的，返回403状态码 return 403; &#125;&#125; &emsp;&emsp;也可在全局配置server中做设置，不过还是建议每个location单独设置，因为对于图片和或者音频视频文件本身，还是不希望直接被搜索引擎所引用，造成网站资源的无意义的消耗。 跳转设置&emsp;&emsp;对于盗链者，也可以予以反击，允许他们请求我们的资源，不过，只给他们我们指定的资源，例如百度使用的防盗链图： &emsp;&emsp;&emsp;&emsp;配置上只需将return 403;改为rewrite ^/ http://www.example/images/return.jpg; 例如： 1234567891011location ~ return\.jpg$ &#123; root /apps/nginx/html/blog/images/｝location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; root /apps/nginx/html/blog/images/; valid_referers none blocked server_names *.example.com ~\.google\. ~\.baidu\.; if ($invalid_referer) &#123; rewrite ^/ http://www.example/images/return.jpg; &#125;&#125; &emsp;&emsp;PS：return.jpg要设置规则优先匹配到，这个图片不能被防盗链，不然会无限重定向，导致显示不正常。 规则细节&emsp;&emsp;设置匹配规则时，根据官方文档，只有none、blocked、server_names、arbitrary string和regular expression五种规则。 Parameters can be as follows: none&emsp;&emsp;the “Referer” field is missing in the request header;blocked&emsp;&emsp;the “Referer” field is present in the request header, but its value has been deleted by a firewall or proxy server; such values are strings that do not start with “http://” or “https://”;server_names&emsp;&emsp;the “Referer” request header field contains one of the server names;arbitrary string&emsp;&emsp;defines a server name and an optional URI prefix. A server name can have an “* ” at the beginning or end. During the checking, the server’s port in the “Referer” field is ignored;regular expression&emsp;&emsp;the first symbol should be a “~”. It should be noted that an expression will be matched against the text starting after the “http://” or “https://”. &emsp;&emsp;这就要求我们在设置匹配规则的时候，要按照这个五种方式来，none、blocked直接写上就可以了，没有什么可说的，我们重点理解下剩下三种。 server_names&emsp;&emsp;server names字面上理解很容易，就是匹配的域名。注意：这里的域名，指本服务器上所有监听的域名。而且这是一个包含的关系，只要referer头部信息中包含有本服务器的监听的任意域名，即可通过匹配。 arbitrary string&emsp;&emsp;翻译过来是任意字符串，其实就是任意可以匹配到到字符串，这里支持通配符。大致有2种写法： 直接写域名例如可以写*.example.com,也可写为www.example.*，可问题是为什么就偏偏不支持 * .example. * 呢。这我也很费解，不过确实不支持，有兴趣的朋友可以去试一下，也希望能有大佬告知这其中的原理是什么。 123[root@CentOS8 ~]#/apps/nginx/sbin/nginx -tnginx: [emerg] invalid hostname or wildcard "*.example.*" in /apps/nginx/conf/nginx.conf:95nginx: configuration file /apps/nginx/conf/nginx.conf test failed 定义匹配域名加路径&emsp;&emsp;例如：www.example.com/blog;&emsp;&emsp;而博主试验过很很多次，如果写成例如www.example.com/*，在www.example.com/blog/页面下去引用页面下的/apps/nginx/html/mp3/123.mp3文件时就会报403错误，而写域名加确切地址如www.example.com/blog时才可以访问。仔细查阅了官方文档，才知道，有个很关键的细节就是，这个通配符的位置，只能在域名里。可以再看一下官方文档， &emsp;&emsp;defines a server name and an optional URI prefix. A server name can have an “*” at the beginning or end. During the checking, the server’s port in the “Referer” field is ignored; &emsp;&emsp;我们可以得知，只可以在域名的开头和结尾用 * 的通配符，而不是URI中，这也就是为什么我发现www.examlpe.com/*无法匹配通过的原因。&emsp;&emsp;跟server_names一样，只要包含自定义字符串就可以,例如匹配规则写成www.example.com/mp3/，在www.example.com/mp3/页面下就可以引用的/apps/nginx/html/mp3/123.mp3文件了，在www.example.com/mp3/abc/efg/页面下是同样可以跳转访问/apps/nginx/html/mp3/123.mp3文件的。 regular expression&emsp;&emsp;被指定的正则表达式模式匹配到的字符串,要使用 ~ 开头，例如：~.*.google.com。这要严格按照正则表达式匹配到的referer写，否则就会无法访问。 总结&emsp;&emsp;设置匹配规则时，必须符合其中的某一种，而不能想当然的把几种规则混合起来使用，想要放行的链接，一定要考虑好，到底确切适用于哪一种规则，才不会出现“误伤“、“漏网”的情况。]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>防盗链</tag>
        <tag>referer</tag>
        <tag>配置文件</tag>
        <tag>细节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业级应用：负载均衡层——LVS调度器详解]]></title>
    <url>%2F%2Fblog%2F159ef64c.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;所谓LVS，是Linux Virtual Server的缩写，直译就是linux虚拟服务器。LVS说是虚拟服务器，并不是说这个服务器本身不存在，而是指一般用户访问企业web网站时，访问的都是LVS，而LVS本身上面没有任何web界面资源，真实的界面以及服务都在后端web服务器上，LVS服务器起到的是一个指引分流的作用，所以相对来说，后端的web服务器是real server,而LVS就被称为是virtual server（虚拟服务器）了。&emsp;&emsp;既然这个服务器上没有页面资源，又无法提供服务，那为什么还有必要部署它来多此一举呢？因为通常来说，我们访问的web服务，都不是由单一服务器主机来支撑的，背后都有好几台、甚至成百上千台web服务器集群共同提供，一台单一主机是无法支撑大的访问并发的，需要很多台服务器来共同分担压力，这时就需要一个专门的服务器来进行调度，将大量访问请求分配到不同的web服务器上，减小每台服务器的压力，实现负载均衡。&emsp;&emsp;本文将详细介绍LVS调度器的工作模式及配置实例。 集群和分布式&emsp;&emsp;集群：同一个业务系统，部署在多台服务器上。集群中，每一台服务器实现的功能没有差别，数据和代码都是一样的。&emsp;&emsp;分布式：一个业务被拆成多个子业务，或者本身就是不同的业务，部署在多台服务器上。分布式中，每一台服务器实现的功能是有差别的，数据和代码也是不一样的，分布式每台服务器功能加起来，才是完整的业务。&emsp;&emsp;分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。&emsp;&emsp;对于大型网站，访问用户很多，实现一个群集，在前面部署一个负载均衡服务器，后面几台服务器完成同一业务。如果有用户进行相应业务访问时，负载均衡器根据后端哪台服务器的负载情况，决定由给哪一台去完成响应，并且一台服务器垮了，其它的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，如果一个节点垮了，那这个业务可能就会失败。 Cluster概念&emsp;&emsp;Cluster：集群,为解决某个特定问题将多台计算机组合起来形成的单个系统。;Linux Cluster类型： LB：Load Balancing，负载均衡 HA：High Availiablity，高可用，SPOF（single Point Of failure）MTBF:Mean Time Between Failure 平均无故障时间MTTR:Mean Time To Restoration（ repair）平均恢复前时间A=MTBF/（MTBF+MTTR(0,1)：99%,99.5%,99.9%,99.99%,99.999% HPC：High-performance computing，高性能 LB Cluster的实现 硬件F5 Big-IPCitrix NetscalerA10 A10 软件lvs：Linux Virtual Server，阿里四层SLB (Server Load Balance)使用网络传输的下四层,不支持应用层等数据的调度内核级:功能虽然弱,性能好,一般最为最前端的调度器.nginx：支持七层调度，阿里七层SLB使用Tenginehaproxy：支持七层调度ats：Apache Traffic Server，yahoo捐助给apacheperlbal：Perl 编写pound LB Cluster基于工作的协议层次划分： 传输层（通用）：DPORTLVS：nginx：streamhaproxy：mode tcp 应用层（专用）：针对特定协议，自定义的请求模型分类proxy server：http：nginx, httpd, haproxy(mode http), …fastcgi：nginx, httpd, …mysql：mysql-proxy, … LB Cluster中用户的会话保持&emsp;&emsp;负载均衡之后，用户会话保持的解决方案：&emsp;&emsp;(1) session sticky：同一用户调度固定服务器&emsp;&emsp; Source IP：LVS sh算法（对某一特定服务而言）(固定IP)&emsp;&emsp; Cookie (LVS四层调度,无法识别cookie)&emsp;&emsp;(2) session replication：每台服务器拥有全部session&emsp;&emsp; session multicast cluster&emsp;&emsp;(3) session server：专门的session服务器，如Memcached，Redis 分布式系统：常见的分布式存储： Ceph，GlusterFS，FastDFS，MogileFS常见的分布式计算：hadoop，Spark这里不多介绍。 LVS介绍&emsp;&emsp;LVS：Linux Virtual Server，负载调度器，在linux内核集成。LVS项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。&emsp;&emsp;LVS实现负载均衡,自身的单点失败问题由keepalived解决(vrrp协议).&emsp;&emsp;keepalived还可以实现检查后端服务器状态. lvs集群类型中的术语： VS：Virtual Server，Director Server(DS)，Dispatcher(调度器)，Load Balancer RS：Real Server(lvs),，upstream server(nginx)，backend server(haproxy) CIP：Client IP VIP: Virtual serve IP VS外网的IP (一般也是内网IP,由防火墙DNAT指向) DIP: Director IP VS内网的IP RIP: Real server IP&emsp;&emsp;访问流程：CIP &lt;–&gt; VIP == DIP &lt;–&gt; RIP lvs: ipvsadm/ipvs&emsp;&emsp;ipvsadm：用户空间的命令行工具，规则管理器，用于管理集群服务及RealServer&emsp;&emsp;ipvs：工作于内核空间netfilter的INPUT钩子上的框架 lvs的模式：&emsp;&emsp;lvs-nat：修改请求报文的目标IP,多目标IP的DNAT&emsp;&emsp;lvs-dr：操纵封装新的MAC地址&emsp;&emsp;lvs-tun：在原请求IP报文之外新加一个IP首部&emsp;&emsp;lvs-fullnat：修改请求报文的源和目标IP lvs-nat：&emsp;&emsp;本质是多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发 （1）RIP和DIP应在同一个IP网络，且应使用私网地址；RS的网关要指向DIP （2）请求报文和响应报文都必须经由Director转发，Director易于成为系统瓶颈 （3）支持端口映射，可修改请求报文的目标PORT （4）VS必须是Linux系统，RS可以是任意OS系统 LVS-DR：&emsp;&emsp;Direct Routing，直接路由，LVS默认模式,应用最广泛,通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变 （1） Director和各RS都配置有VIP （2） 确保前端路由器将目标IP为VIP的请求报文发往Director &emsp;&emsp;在前端网关做静态绑定VIP和Director的MAC地址 &emsp;&emsp;在RS上使用arptables工具 arptables -A IN -d $VIP -j DROP arptables -A OUT -s $VIP -j mangle --mangle-ip-s $RIP &emsp;&emsp;在RS上修改内核参数以限制arp通告及应答级别 /proc/sys/net/ipv4/conf/all/arp_ignore /proc/sys/net/ipv4/conf/all/arp_announce （3）RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director （4）RS和Director要在同一个物理网络 （5）请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client （6）不支持端口映射（端口不能修败） （7）RS可使用大多数OS系统 lvs-tun：&emsp;&emsp;转发方式：不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而在原IP报文之外再封装一个IP首部（源IP是DIP，目标IP是RIP），将报文发往挑选出的目标RS；RS直接响应给客户端（源IP是VIP，目标IP是CIP）&emsp;&emsp; (1) DIP, VIP, RIP都应该是公网地址&emsp;&emsp; (2) RS的网关一般不能指向DIP&emsp;&emsp; (3) 请求报文要经由Director，但响应不经由Director&emsp;&emsp; (4) 不支持端口映射&emsp;&emsp; (5) RS的OS须支持隧道功能 lvs-fullnat：通过同时修改请求报文的源IP地址和目标IP地址进行转发&emsp;&emsp;CIP –&gt; DIP&emsp;&emsp;VIP –&gt; RIP (1) VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关一般不会指向DIP (2) RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client (3) 请求和响应报文都经由Director (4) 支持端口映射注意：此类型kernel默认不支持 LVS调度算法ipvs scheduler：&emsp;&emsp;根据其调度时是否考虑各RS当前的负载状态分为两种：静态方法和动态方法 静态方法：仅根据算法本身进行调度 1、RR：roundrobin，轮询 2、WRR：Weighted RR，加权轮询 3、SH：Source Hashing，实现session sticky，源IP地址hash；将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定 4、DH：Destination Hashing；目标地址哈希，第一次轮询调度至RS，后续将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡，如：宽带运营商 动态方法：主要根据每RS当前的负载状态及调度算法进行调度Overhead=value较小的RS将被调度 1、LC：least connections 适用于长连接应用 Overhead=activeconns*256+inactiveconns 2、WLC：Weighted LC，默认调度方法 Overhead=(activeconns*256+inactiveconns)/weight 3、SED：Shortest Expection Delay,初始连接高权重优先 Overhead=(activeconns+1)*256/weight 4、NQ：Never Queue，第一轮均匀分配，后续SED 5、LBLC：Locality-Based LC，动态的DH算法，使用场景：根据负载状态实现正向代理 6、LBLCR：LBLC with Replication，带复制功能的LBLC，解决LBLC负载不均衡问题，从负载重的复制到负载轻的RS ipvsadm/ipvs：ipvs：&emsp;&emsp;grep -i -A 10 &quot;ipvs&quot; /boot/config-VERSION-RELEASE.x86_64&emsp;&emsp;支持的协议：TCP， UDP， AH， ESP， AH_ESP, SCTPipvs集群：&emsp;&emsp;管理集群服务&emsp;&emsp;管理服务上的RS ipvsadm：&emsp;&emsp;程序包：ipvsadm&emsp;&emsp;Unit File: ipvsadm.service&emsp;&emsp;主程序：/usr/sbin/ipvsadm&emsp;&emsp;规则保存工具：/usr/sbin/ipvsadm-save&emsp;&emsp;规则重载工具：/usr/sbin/ipvsadm-restore&emsp;&emsp;配置文件：/etc/sysconfig/ipvsadm-configipvsadm命令：核心功能： 集群服务管理：增、删、改 集群服务的RS管理：增、删、改 查看 &emsp;&emsp;例：命令总结： 123456789ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [--pepersistence_engine] [-b sched-flags]ipvsadm -D -t|u|f service-address 删除ipvsadm –C 清空ipvsadm –R 重载ipvsadm -S [-n] 保存ipvsadm -a|e -t|u|f service-address -r server-address [options]ipvsadm -d -t|u|f service-address -r server-addressipvsadm -L|l [options]ipvsadm -Z [-t|u|f service-address] 管理集群服务：增、改、删&emsp;&emsp;增、改：ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]&emsp;&emsp;删除：ipvsadm -D -t|u|f service-addressservice-address： VIP&emsp;&emsp; -t|u|f：&emsp;&emsp; -t: TCP协议的端口，VIP:TCP_PORT&emsp;&emsp; -u: UDP协议的端口，VIP:UDP_PORT&emsp;&emsp; -f：firewall MARK，标记，一个数字&emsp;&emsp;[-s scheduler]：指定集群的调度算法，默认为wlc 管理集群上的RS：增、改、删&emsp;&emsp;增、改：ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight]&emsp;&emsp;删：ipvsadm -d -t|u|f service-address -r server-address server-address&emsp;&emsp;rip[:port] 如省略port，不作端口映射选项：&emsp;&emsp;lvs类型：&emsp;&emsp;-g: gateway, dr类型，默认&emsp;&emsp;-i: ipip, tun类型&emsp;&emsp;-m: masquerade, nat类型&emsp;&emsp;-w weight：权重 &emsp;&emsp;清空定义的所有内容：ipvsadm –C清空计数器：ipvsadm -Z [-t|u|f service-address] 查看：ipvsadm -L|l [options]&emsp;&emsp;–numeric, -n：以数字形式输出地址和端口号&emsp;&emsp;–exact：扩展信息，精确值&emsp;&emsp;–connection，-c：当前IPVS连接输出&emsp;&emsp;–stats：统计信息&emsp;&emsp;–rate ：输出速率信息 ipvs规则：/proc/net/ip_vsipvs连接：/proc/net/ip_vs_conn 保存及重载规则&emsp;&emsp;保存：建议保存至/etc/sysconfig/ipvsadmipvsadm-save &gt; /PATH/TO/IPVSADM_FILEipvsadm -S &gt; /PATH/TO/IPVSADM_FILEsystemctl stop ipvsadm.service&emsp;&emsp;重载：ipvsadm-restore &lt; /PATH/FROM/IPVSADM_FILEsystemctl restart ipvsadm.service 注意事项负载均衡集群设计时要注意的问题&emsp;&emsp;(1) 是否需要会话保持&emsp;&emsp;(2) 是否需要共享存储 共享存储：NAS， SAN， DS（分布式存储） 数据同步： lvs-nat：设计要点：&emsp;&emsp;(1) RIP与DIP在同一IP网络, RIP的网关要指向DIP&emsp;&emsp;(2) 支持端口映射&emsp;&emsp;(3) Director要打开核心转发功能 LVS-DRDR模型中各主机上均需要配置VIP，解决地址冲突的方式有三种： (1) 在前端网关做静态绑定 (2) 在各RS使用arptables (3) 在各RS修改内核参数，来限制arp响应和通告的级别限制响应级别：arp_ignore 0：默认值，表示可使用本地任意接口上配置的任意地址进行响应 1: 仅在请求的目标IP配置在本地主机的接收到请求报文的接口上时，才给予响应限制通告级别：arp_announce 0：默认值，把本机所有接口的所有信息向每个接口的网络进行通告 1：尽量避免将接口信息向非直接连接网络进行通告 2：必须避免将接口信息向非本网络进行通告 附：&emsp;&emsp;RS的配置脚本 12345678910111213141516171819202122232425#!/bin/bashvip=10.0.0.100mask='255.255.255.255'dev=lo:1case $1 instart)echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignoreecho 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignoreecho 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announceecho 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announceifconfig $dev $vip netmask $mask #broadcast $vip up#route add -host $vip dev $dev;;stop)ifconfig $dev downecho 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignoreecho 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignoreecho 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announceecho 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce;;*)echo "Usage: $(basename $0) start|stop"exit 1;;esac &emsp;&emsp;VS的配置脚本 12345678910111213141516171819202122232425#!/bin/bashvip='10.0.0.100'iface='lo:1'mask='255.255.255.255'port='80'rs1='192.168.0.101'rs2='192.168.0.102'scheduler='wrr'type='-g'case $1 instart)ifconfig $iface $vip netmask $mask #broadcast $vip upiptables -Fipvsadm -A -t $&#123;vip&#125;:$&#123;port&#125; -s $scheduleripvsadm -a -t $&#123;vip&#125;:$&#123;port&#125; -r $&#123;rs1&#125; $type -w 1ipvsadm -a -t $&#123;vip&#125;:$&#123;port&#125; -r $&#123;rs2&#125; $type -w 1;;stop)ipvsadm -Cifconfig $iface down;;*)echo "Usage $(basename $0) start|stop“exit 1esac FireWall Mark&emsp;&emsp;FWM：FireWall Mark&emsp;&emsp;MARK target 可用于给特定的报文打标记&emsp;&emsp;–set-mark value其中：value 可为0xffff格式，表示十六进制数字&emsp;&emsp;借助于防火墙标记来分类报文，而后基于标记定义集群服务；可将多个不同的应用使用同一个集群服务进行调度&emsp;&emsp;实现方法：&emsp;&emsp;在Director主机打标记：iptables -t mangle -A PREROUTING -d $vip -p $proto –m multiport - -dports $port1,$port2,… -j MARK --set-mark NUMBER&emsp;&emsp;在Director主机基于标记定义集群服务：ipvsadm -A -f NUMBER [options] 持久连接&emsp;&emsp;session 绑定：对共享同一组RS的多个集群服务，需要统一进行绑定，lvs sh算法无法实现&emsp;&emsp;持久连接（ lvs persistence ）模板：实现无论使用任何调度算法，在一段时间内（默认360s ），能够实现将来自同一个地址的请求始终发往同一个RSipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]&emsp;&emsp;持久连接实现方式：&emsp;&emsp;每端口持久（PPC）：每个端口定义为一个集群服务，每集群服务单独调度&emsp;&emsp;每防火墙标记持久（PFWMC）：基于防火墙标记定义集群服务；可实现将多个端口上的应用统一调度，即所谓的port Affinity&emsp;&emsp;每客户端持久（PCC）：基于0端口（表示所有服务）定义集群服务，即将客户端对所有应用的请求都调度至后端主机，必须定义为持久模式 LVS高可用性 Director不可用，整个系统将不可用；SPoF Single Point of Failure&emsp;&emsp;解决方案：高可用&emsp;&emsp;keepalived heartbeat/corosync 某RS不可用时，Director依然会调度请求至此RS&emsp;&emsp;解决方案： 由Director对各RS健康状态进行检查，失败时禁用，成功时启用keepalived heartbeat/corosync ldirectord&emsp;&emsp;检测方式：&emsp;&emsp;(a) 网络层检测，icmp&emsp;&emsp;(b) 传输层检测，端口探测&emsp;&emsp;(c) 应用层检测，请求某关键资源&emsp;&emsp;RS全不用时：backup server, sorry server ldirectord&emsp;&emsp;ldirectord：监控和控制LVS守护进程，可管理LVS规则&emsp;&emsp;包名：ldirectord-3.9.6-0rc1.1.1.x86_64.rpm&emsp;&emsp;下载：http://download.opensuse.org/repositories/network:/haclustering:/Stable/CentOS_CentOS-7/x86_64/&emsp;&emsp;文件：&emsp;&emsp;/etc/ha.d/ldirectord.cf 主配置文件&emsp;&emsp;/usr/share/doc/ldirectord-3.9.6/ldirectord.cf 配置模版&emsp;&emsp;/usr/lib/systemd/system/ldirectord.service 服务&emsp;&emsp;/usr/sbin/ldirectord 主程序,Perl实现&emsp;&emsp;/var/log/ldirectord.log 日志&emsp;&emsp;/var/run/ldirectord.ldirectord.pid pid文件 &emsp;&emsp;Ldirectord配置文件示例 123456789101112131415checktimeout=3checkinterval=1autoreload=yeslogfile=“/var/log/ldirectord.log“ #日志文件quiescent=no #down时yes权重为0，no为删除virtual=5 #指定VS的FWM 或 IP:PORTreal=172.16.0.7:80 gate 2 #DR模型，权重为 2real=172.16.0.8:80 gate 1fallback=127.0.0.1:80 gate #sorry serverservice=httpscheduler=wrrchecktype=negotiatecheckport=80request="index.html"receive=“Test Ldirectord"]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>企业级应用</tag>
        <tag>负载均衡</tag>
        <tag>调度算法</tag>
        <tag>集群</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码编译Apache和PHP实现lamp架构]]></title>
    <url>%2F%2Fblog%2Fdcaccc5a.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;所谓LAMP架构，是指：&emsp;&emsp;&emsp;&emsp;L：linux&emsp;&emsp;&emsp;&emsp;A：apache (httpd)&emsp;&emsp;&emsp;&emsp;M：mysql, mariadb&emsp;&emsp;&emsp;&emsp;（或M：memcached）&emsp;&emsp;&emsp;&emsp;P：php, perl, python&emsp;&emsp;WEB资源类型：&emsp;&emsp;&emsp;&emsp;静态资源：原始形式与响应内容一致，在客户端浏览器执行&emsp;&emsp;&emsp;&emsp;动态资源：原始形式通常为程序文件，需要在服务器端执行之后，将执行结果返回给客户端 LAMP工作原理&emsp;&emsp;httpd：接收用户的web请求；静态资源则直接响应；动态资源为php脚本，对此类资源的请求将交由php来运行&emsp;&emsp;php：运行php程序&emsp;&emsp;MariaDB：数据管理系统 httpd与php结合的方式1、modules (将php编译成为httpd的模块,默认方式) MPM:prefork: libphp5.soevent, worker: libphp5-zts.so2、FastCGI &emsp;&emsp;本文将分别展示以模块方式以及FCGI的方式，源码编译apache、php、mariadb来实现LAMP架构。 编译部署编译安装mariadb&emsp;&emsp;之前曾详细介绍，这里就不再赘述。 编译安装apache&emsp;&emsp;先安装依赖包yum install gcc pcre-devel openssl-devel expat-devel autoconf libtool gcc-c++&emsp;&emsp;下载apache源码包以及apr包 123wget https://archive.apache.org/dist/httpd/httpd-2.4.39.tar.gzwget https://www-us.apache.org/dist//apr/apr-1.7.0.tar.gzwget https://www-us.apache.org/dist//apr/apr-util-1.6.1.tar.gz &emsp;&emsp;替换apr、apr-util文件 12345tar xf apr-1.7.0.tar.gz -C httpd-2.4.39/srclib/ tar xf apr-util-1.6.1.tar.gz -C httpd-2.4.39/srclib/ cd httpd-2.4.39/srclib/mv apr-1.7.0 aprmv apr-util-1.6.1 apr-util &emsp;&emsp;编译安装 1234567891011./configure --prefix=/data/httpd24 \--enable-so \--enable-ssl \--enable-cgi \--enable-rewrite \--with-zlib \--with-pcre \--enable-modules=most \--enable-mpms-shared=all \--with-mpm=prefork \--with-included-apr 1make -j 4 &amp;&amp; make install &emsp;&emsp;写入PATH变量,并生效 1vim /etc/profile.d/httpd.sh 12#!/bin/bashexport PATH=/data/httpd24/bin:$PATH 1source /etc/profile.d/httpd.sh 编译安装php模块方式&emsp;&emsp;先安装依赖包 1yum install -y libxml2-devel &emsp;&emsp;在官网下载php最新版php-7.3.10.tar.xz包并解压 123wget https://www.php.net/distributions/php-7.3.10.tar.xztar xvf php-7.3.10.tar.xzcd php-7.3.10.tar.xz 1234567891011121314151617./configure --prefix=/data/php/ \--enable-mysqlnd \--with-mysqli=mysqlnd \--with-openssl \--with-pdo-mysql=mysqlnd \--enable-mbstring \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--enable-xml \--enable-sockets \--with-apxs2=/data/httpd24/bin/apxs \--with-config-file-path=/data/php/etc \--with-config-file-scan-dir=/data/php/etc/php.d \--enable-maintainer-zts \--disable-fileinfo &emsp;&emsp;PS:如果apache是之前yum装的，很有可能没有apxs文件，只需要dnf install httpd-devel -y命令安装httpd-devel包，即可生成/usr/bin/apxs工具，如果是以前编译安装的，也要改为正确apxs2对应路径。&emsp;&emsp;编译安装 1make -j 4 &amp;&amp; make install &emsp;&emsp;复制配置文件模版至配置文件目录 1cp php.ini-production /data/php/etc/php.ini &emsp;&emsp;修改apache配置文件,设置默认php页面，增加PHP模块 1vim /etc/httpd/conf/httpd.conf 123456789101112131415&amp;ltIfModule dir_module&amp;gt DirectoryIndex index.php index.html #增加php页面&amp;lt/IfModule&amp;gt----&amp;ltIfModule mime_module&amp;gt AddType application/x-compress .Z AddType application/x-gzip .gz .tgz AddType application/x-httpd-php .php #增加模块 AddType application/x-httpd-php-source .phps #增加模块&amp;lt/IfModule&amp;gt &emsp;&emsp;添加php测试页 1vim /data/httpd24/htdocs/index.php 123&amp;lt?phpphpinfo() ?&amp;gt &emsp;&emsp;重启apache服务 1apachectl restart &emsp;&emsp;访问php测试页进行测试,便可看到php设置已经成功 1curl HOSTIP FCGI方式&emsp;&emsp;也要先安装依赖包 1yum install libxml2-devel bzip2-devel libmcrypt-devel &emsp;&emsp;同样下载tar包，解压并进入编译目录&emsp;&emsp;开始编译安装 123456789101112131415161718./configure --prefix=/data/php \--enable-mysqlnd \--with-mysqli=mysqlnd \--with-pdo-mysql=mysqlnd \--with-openssl \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--with-libxml-dir=/usr \--with-config-file-path=/etc \--with-config-file-scan-dir=/etc/php.d \--enable-mbstring \--enable-xml \--enable-sockets \--enable-fpm \--enable-maintainer-zts \--disable-fileinfo 1make -j 4 &amp;&amp; make install &emsp;&emsp;复制模版文件当配置文件 1cp /data/php-7.3.10/php.ini-production /etc/php.ini &emsp;&emsp;因为php-fpm模式相当于单独的一个服务，将服务配置文件放至/usr/lib/systemd/system/目录 1cp /data/php-7.3.10/sapi/fpm/php-fpm.service /usr/lib/systemd/system/ &emsp;&emsp;生成fpm配置文件，并修改进程属主属组为apache 1234cd /data/php/etccp php-fpm.conf.default php-fpm.confcd php-fpm.d/cp www.conf.default www.conf 1234vim www.confuser apachegroup apache &emsp;&emsp;加载配置文件并启动进程 12systemctl daemon-reloadsystemctl enable --now php-fpm.service &emsp;&emsp;修改配置httpd.conf 支持php-fpm&emsp;&emsp;取消下面两行的注释 12LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so &emsp;&emsp;修改下面行 12345678&amp;ltIfModule dir_module&amp;gtDirectoryIndex index.php index.html&amp;lt/IfModule&amp;gt加下面四行AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phpsProxyRequests OffProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/data/httpd24/htdocs/$1 &emsp;&emsp;也可修改php监听端口9000 为socket路径，下面代理转发命令为为 12ProxyRequests OffProxyPassMatch ^/(.*\.php)$ unix:/var/run/php-fpm/php-fpm.sock|fcgi://localhost/data/httpd24/htdocs/$1 &emsp;&emsp;重启apache服务 1apachectl restart 至此，php页面就可以正常访问了]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>编译安装</tag>
        <tag>LAMP</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP架构实现PowerDNS]]></title>
    <url>%2F%2Fblog%2F57d66c4.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;PowerDNS 是一个跨平台的开源DNS服务组件，它是高性能的域名服务器，除了支持普通的BIND配置文件，PowerDNS还可以从MySQL,Oracle,PostgreSQL等的数据库读取数据。PowerDNS安装了Poweradmin(基于php实现)，能实现Web管理DNS记录，非常方便。&emsp;&emsp;ps:本次过程是在centos7系统上完成。 配置安装pdns安装pdns包1yum install -y pdns pdns-backend-mysql 创建pdns数据库&emsp;&emsp;搭建好mariadb数据库了，启动数据库服务，参考官方文档创建powerdns数据库及其中的表，参看下面文档 https://doc.powerdns.com/md/authoritative/backend-generic-mysql/vim powerdns.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293CREATE DATABASE powerdns;GRANT ALL ON powerdns.* TO 'powerdns'@'127.0.0.1' IDENTIFIED BY 'powerdns';use powerdns;CREATE TABLE domains ( id INT AUTO_INCREMENT, name VARCHAR(255) NOT NULL, master VARCHAR(128) DEFAULT NULL, last_check INT DEFAULT NULL, type VARCHAR(6) NOT NULL, notified_serial INT DEFAULT NULL, account VARCHAR(40) DEFAULT NULL, PRIMARY KEY (id)) Engine=InnoDB;CREATE UNIQUE INDEX name_index ON domains(name);CREATE TABLE records ( id BIGINT AUTO_INCREMENT, domain_id INT DEFAULT NULL, name VARCHAR(255) DEFAULT NULL, type VARCHAR(10) DEFAULT NULL, content VARCHAR(64000) DEFAULT NULL, ttl INT DEFAULT NULL, prio INT DEFAULT NULL, change_date INT DEFAULT NULL, disabled TINYINT(1) DEFAULT 0, ordername VARCHAR(255) BINARY DEFAULT NULL, auth TINYINT(1) DEFAULT 1, PRIMARY KEY (id)) Engine=InnoDB;CREATE INDEX nametype_index ON records(name,type);CREATE INDEX domain_id ON records(domain_id);CREATE INDEX recordorder ON records (domain_id, ordername);CREATE TABLE supermasters ( ip VARCHAR(64) NOT NULL, nameserver VARCHAR(255) NOT NULL, account VARCHAR(40) NOT NULL, PRIMARY KEY (ip, nameserver)) Engine=InnoDB;CREATE TABLE comments ( id INT AUTO_INCREMENT, domain_id INT NOT NULL, name VARCHAR(255) NOT NULL, type VARCHAR(10) NOT NULL, modified_at INT NOT NULL, account VARCHAR(40) NOT NULL, comment VARCHAR(64000) NOT NULL, PRIMARY KEY (id)) Engine=InnoDB;CREATE INDEX comments_domain_id_idx ON comments (domain_id);CREATE INDEX comments_name_type_idx ON comments (name, type);CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);CREATE TABLE domainmetadata ( id INT AUTO_INCREMENT, domain_id INT NOT NULL, kind VARCHAR(32), content TEXT, PRIMARY KEY (id)) Engine=InnoDB;CREATE INDEX domainmetadata_idx ON domainmetadata (domain_id, kind);CREATE TABLE cryptokeys ( id INT AUTO_INCREMENT, domain_id INT NOT NULL, flags INT NOT NULL, active BOOL, content TEXT, PRIMARY KEY(id)) Engine=InnoDB;CREATE INDEX domainidindex ON cryptokeys(domain_id);CREATE TABLE tsigkeys ( id INT AUTO_INCREMENT, name VARCHAR(255), algorithm VARCHAR(50), secret VARCHAR(255), PRIMARY KEY (id)) Engine=InnoDB;CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm); &emsp;&emsp;以上参数设置为官方文档默认值，如果参数数值大小不对，可自行修改调整。数据库名、主机名、用户名及密码自行修改。&emsp;&emsp;导入SQL语句mysql -uroot -ppassword &lt; power.sql，此时powerdns数据库就创建好了。 配置PowerDNS使用mariadb作为后台数据存储可参见官方文档的设置参数： gmysql-hostHost (ip address) to connect to. Mutually exclusive with gmysql-socket.WARNING: When specified as a hostname a chicken/egg situation might arise where the database is needed to resolve the IP address of the database. It is best to supply an IP address of the database here.gmysql-portThe port to connect to on gmysql-host. Default: 3306gmysql-socketConnect to the UNIX socket at this path. Mutually exclusive with gmysql-host.gmysql-dbnameName of the database to connect to. Default: “pdns”.gmysql-userUser to connect as. Default: “powerdns”.gmysql-groupGroup to connect as. Default: “client”.gmysql-passwordThe password to for gmysql-user.gmysql-dnssecEnable DNSSEC processing for this backend. Default=no.gmysql-innodb-read-committedUse the InnoDB READ-COMMITTED transaction isolation level.Default=yes.gmysql-timeoutThe timeout in seconds for each attempt to read from, or write to the server. A value of 0 will disable the timeout. Default: 10 &emsp;&emsp;官方文档第一条写的很清楚，gmysql-localhost那一项最好填ip，或者你的hostname为localhost也可以解析成127.0.0.1，所以虽然我是本机数据库，也选择直接使用127.0.0.1（我试了localhost，提示无法连接数据库，应该是因为我改了hostname导致没法解析成127.0.0.1了，干脆直接用ip就成功连接了） vim /etc/pdns/pdns.conf&emsp;&emsp;用/搜索到”launch=”将值修改为gmysql，并在下面添加mysql的相关信息设置： 123456launch=gmysqlgmysql-host=127.0.0.1gmysql-port=3306gmysql-dbname=powerdnsgmysql-user=powerdnsgmysql-password=powerdns &emsp;&emsp;好了pdns服务就配置好了，启动服务. 12systemctl start pdnssystemctl enable pdns 搭建LAP架构用web界面实现pdns服务安装httpd和php相关包并启动httpd服务123yum -y install httpd php php-devel php-gd php-mcrypt php-imap php-ldap php-mysql php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-mhash gettextsystemctl start httpdsystemctl enable httpd 下载PowerAdmin程序，并解压缩到相应目录1234wget http://downloads.sourceforge.net/project/poweradmin/poweradmin-2.1.7.tgztar xvf poweradmin-2.1.7.tgz -C /var/www/htmlcd /var/www/htmlmv poweradmin-2.1.7 poweradmin 登陆web界面安装PowerAdmin&emsp;&emsp;浏览器输入http://powerdns服务器IP/poweradmin/install/ 进入安装向导界面。&emsp;&emsp;1.选择语言&emsp;&emsp;2. 确认powerdns服务已连接好数据库，如果之前已经有相关记录，本次安装将会清除之前的数据，时候确定安装。&emsp;&emsp;3.填写数据库相关信息&emsp;&emsp;4.为Poweradmin创建一个受限用户&emsp;&emsp;说明：&emsp;&emsp;&emsp;&emsp; Username：PowerAdmin用户名&emsp;&emsp;&emsp;&emsp; Password：上述用户的密码&emsp;&emsp;&emsp;&emsp; Hostmaster：当创建SOA记录指定默认主机管理员&emsp;&emsp;&emsp;&emsp; Primary nameserver：主域名服务器&emsp;&emsp;&emsp;&emsp; Secondary namesever:辅域名服务器&emsp;&emsp;5.按照下面页面说明，在数据库中创建用户并授权 1234GRANT SELECT, INSERT, UPDATE, DELETEON powerdns.*TO 'powerdns'@'127.0.0.1'IDENTIFIED BY 'powerdns'; &emsp;&emsp;6.按下面页面说明，创建config.in.php文件内容&emsp;&emsp;vim /var/www/html/poweradmin/inc/config.inc.php 12345678910111213141516&amp;lt?php$db_host = '127.0.0.1';$db_user = 'powerdns';$db_pass = 'powerdns';$db_name = 'powerdns';$db_type = 'mysql';$db_layer = 'PDO';$session_key = 'Kae&#125;LCI!&amp;^Ew6(5eyd6B~!SVHRHhu+t(svkGqb1S&#123;C0&#125;TP';$iface_lang = 'en_EN';$dns_hostmaster = 'powerdns';$dns_ns1 = '192.168.32.7';$dns_ns2 = '192.168.32.7';` &emsp;&emsp;7.设置完成，删除install目录&emsp;&emsp;\rm -rf install&emsp;&emsp;如果不进行第6、7步就会报错，如上图所示。&emsp;&emsp;8.输入用户名密码登陆&emsp;&emsp;9.进入主页面。至此PowerDNS在web上展示就实现了~]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>LAMP</tag>
        <tag>经验分享</tag>
        <tag>PowerDNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum/dnf 安装mariadb10.4.8（最新版）]]></title>
    <url>%2F%2Fblog%2F72c5296a.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;近期想在新出的CentOS8上安装一下最新版的mariadb10.4.8，不过又嫌源码编译太麻烦费时间。就想去找找有没有yum源可用。&emsp;&emsp;果然官网上已经放出了yum安装的repo源了，也支持到CentOS8了——http://mirror.aarnet.edu.au/pub/MariaDB//mariadb-10.4.8/yum/centos/8/x86_64/&emsp;&emsp;那就手动加一个yum源吧。&emsp;&emsp;vim /etc/yum.repos.d/mariadb1048.repo 12345[mariadb10.4.8]name=Mariadb10.4.8 RPM repository for Linux $releasever - $basearchbaseurl=http://mirror.aarnet.edu.au/pub/MariaDB//mariadb-10.4.8/yum/centos/$releasever/$basearch/enabled=1gpgcheck=0 &emsp;&emsp;加好yum源后，执行安装dnf install mariadb-server -y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116aliyun 4.7 kB/s | 5.3 kB 00:01 cdrom-AppStream 4.1 MB/s | 4.3 kB 00:00 cdrom-base 3.8 MB/s | 3.9 kB 00:00 Mariadb10.4.8 RPM repository for Linux 8 - x86_64 1.8 kB/s | 2.9 kB 00:01 Dependencies resolved.===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: mariadb-server x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 16 MInstalling dependencies: mariadb x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 6.2 M mariadb-common x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 62 k mariadb-connector-c x86_64 3.0.7-1.el8 cdrom-AppStream 148 k mariadb-errmsg x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 232 k perl-DBD-MySQL x86_64 4.046-2.module_el8.0.0+72+668237d8 cdrom-AppStream 156 k perl-DBI x86_64 1.641-2.module_el8.0.0+66+fe1eca09 cdrom-AppStream 740 k perl-Digest noarch 1.17-395.el8 cdrom-AppStream 27 k perl-Digest-MD5 x86_64 2.55-396.el8 cdrom-AppStream 37 k perl-Net-SSLeay x86_64 1.85-6.el8 cdrom-AppStream 358 k perl-URI noarch 1.73-3.el8 cdrom-AppStream 116 k perl-libnet noarch 3.11-3.el8 cdrom-AppStream 121 k perl-Carp noarch 1.42-396.el8 cdrom-base 30 k perl-Data-Dumper x86_64 2.167-399.el8 cdrom-base 58 k perl-Encode x86_64 4:2.97-3.el8 cdrom-base 1.5 M perl-Errno x86_64 1.28-416.el8 cdrom-base 76 k perl-Exporter noarch 5.72-396.el8 cdrom-base 34 k perl-File-Path noarch 2.15-2.el8 cdrom-base 38 k perl-File-Temp noarch 0.230.600-1.el8 cdrom-base 63 k perl-Getopt-Long noarch 1:2.50-4.el8 cdrom-base 63 k perl-HTTP-Tiny noarch 0.074-1.el8 cdrom-base 58 k perl-IO x86_64 1.38-416.el8 cdrom-base 141 k perl-MIME-Base64 x86_64 3.15-396.el8 cdrom-base 31 k perl-Math-BigInt noarch 1:1.9998.11-5.el8 cdrom-base 195 k perl-Math-Complex noarch 1.59-416.el8 cdrom-base 108 k perl-PathTools x86_64 3.74-1.el8 cdrom-base 90 k perl-Pod-Escapes noarch 1:1.07-395.el8 cdrom-base 20 k perl-Pod-Perldoc noarch 3.28-396.el8 cdrom-base 86 k perl-Pod-Simple noarch 1:3.35-395.el8 cdrom-base 213 k perl-Pod-Usage noarch 4:1.69-395.el8 cdrom-base 34 k perl-Scalar-List-Utils x86_64 3:1.49-2.el8 cdrom-base 68 k perl-Socket x86_64 4:2.027-2.el8 cdrom-base 59 k perl-Storable x86_64 1:3.11-3.el8 cdrom-base 98 k perl-Term-ANSIColor noarch 4.06-396.el8 cdrom-base 46 k perl-Term-Cap noarch 1.17-395.el8 cdrom-base 23 k perl-Text-ParseWords noarch 3.30-395.el8 cdrom-base 18 k perl-Text-Tabs+Wrap noarch 2013.0523-395.el8 cdrom-base 24 k perl-Time-Local noarch 1:1.280-1.el8 cdrom-base 34 k perl-Unicode-Normalize x86_64 1.25-396.el8 cdrom-base 82 k perl-constant noarch 1.33-396.el8 cdrom-base 25 k perl-interpreter x86_64 4:5.26.3-416.el8 cdrom-base 6.3 M perl-libs x86_64 4:5.26.3-416.el8 cdrom-base 1.6 M perl-macros x86_64 4:5.26.3-416.el8 cdrom-base 72 k perl-parent noarch 1:0.237-1.el8 cdrom-base 20 k perl-podlators noarch 4.11-1.el8 cdrom-base 118 k perl-threads x86_64 1:2.21-2.el8 cdrom-base 61 k perl-threads-shared x86_64 1.58-2.el8 cdrom-base 48 k psmisc x86_64 23.1-3.el8 cdrom-base 151 k MariaDB-client x86_64 10.4.8-1.el8 mariadb10.4.8 12 M MariaDB-common x86_64 10.4.8-1.el8 mariadb10.4.8 87 kInstalling weak dependencies: mariadb-backup x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 6.2 M mariadb-gssapi-server x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 49 k mariadb-server-utils x86_64 3:10.3.11-2.module_el8.0.0+35+6f2527ed cdrom-AppStream 1.6 M perl-IO-Socket-IP noarch 0.39-5.el8 cdrom-AppStream 47 k perl-IO-Socket-SSL noarch 2.060-2.el8 cdrom-AppStream 289 k perl-Mozilla-CA noarch 20160104-7.el8 cdrom-AppStream 15 kTransaction Summary=====================================================================================================================================Install 56 PackagesTotal size: 56 MTotal download size: 12 MInstalled size: 260 MIs this ok [y/N]: yDownloading Packages:(1/2): MariaDB-common-10.4.8-1.el8.x86_64.rpm 35 kB/s | 87 kB 00:02 (2/2): MariaDB-client-10.4.8-1.el8.x86_64.rpm 195 kB/s | 12 MB 01:02 -------------------------------------------------------------------------------------------------------------------------------------Total 197 kB/s | 12 MB 01:02 Running transaction checkTransaction check succeeded.Running transaction testThe downloaded packages were saved in cache until the next successful transaction.You can remove cached packages by executing 'dnf clean packages'.Error: Transaction check error: file /usr/bin/msql2mysql conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysql conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysql_find_rows conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysql_plugin conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysql_waitpid conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqlaccess conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqladmin conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqlbinlog conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqlcheck conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqldump conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqlimport conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqlshow conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/bin/mysqlslap conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/msql2mysql.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysql.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysql_find_rows.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysql_plugin.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysql_waitpid.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqlaccess.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqladmin.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqlbinlog.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqlcheck.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqldump.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqlimport.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqlshow.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64 file /usr/share/man/man1/mysqlslap.1.gz conflicts between attempted installs of mariadb-3:10.3.11-2.module_el8.0.0+35+6f2527ed.x86_64 and MariaDB-client-10.4.8-1.el8.x86_64Error Summary------------- &emsp;&emsp;竟然报错了，说是版本冲突。仔细一看，装的是本地光盘的mariadb-sever 3:10.3.11-2.module_el8.0.0+35+6f2527ed.用的是本地yum光盘yum源，看了下mariadb官网上的软件名称叫MariaDB-server-10.4.8-1.el8.x86_64.rpm，那就重新换成大写，dnf install MariaDB-server.还是报错： 12345[root@CentOS8 ~]#yum install MariaDB-serverLast metadata expiration check: 0:05:33 ago on Sat 12 Oct 2019 10:19:15 AM CST.No match for argument: MariaDB-server * Maybe you meant: mariadb-serverError: Unable to find a match &emsp;&emsp;那没办法，把本地光盘yum源禁用掉再试试吧 12345678910111213141516171819202122232425[root@CentOS8 ~]#vim /etc/yum.repos.d/cdrom.repo [root@CentOS8 ~]#yum install mariadb-serverLast metadata expiration check: 0:13:24 ago on Sat 12 Oct 2019 10:34:12 AM CST.No match for argument: mariadb-server * Maybe you meant: MariaDB-serverError: Unable to find a match[root@CentOS8 ~]#yum install MariaDB-serverLast metadata expiration check: 0:13:36 ago on Sat 12 Oct 2019 10:34:12 AM CST.Error: Problem: cannot install the best candidate for the job - nothing provides rsync needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(strict) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides /usr/bin/perl needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(vars) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(Getopt::Long) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(POSIX) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(File::Basename) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(File::Path) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(Data::Dumper) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(File::Temp) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(File::Copy) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(DBI) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides perl(Sys::Hostname) needed by MariaDB-server-10.4.8-1.el8.x86_64 - nothing provides lsof needed by MariaDB-server-10.4.8-1.el8.x86_64(try to add '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages) &emsp;&emsp;这次倒是不能识别小写mariadb，只能识别大写了MariaDB。不过没有了本地光盘yum源，我这是最小安装的系统，也没法安装依赖了啊。这就陷入两难问题了。如果开启本地光盘yum源，无论后跟版本号或是大写都会提示找不到匹配项，小写的话就会去装mariadb-server3XXX版本，不开启本地光盘yum源的话，就没法装所需依赖了。&emsp;&emsp;突然想起可以直接用包管理工具安装rpm包来解决依赖性的问题，还可以指定要按的主程序包。那就试试直接看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245[root@CentOS8 ~]#dnf install http://mirror.aarnet.edu.au/pub/MariaDB//mariadb-10.4.8/yum/centos/8/x86_64/rpms/MariaDB-server-10.4.8-1.el8.x86_64.rpmLast metadata expiration check: 0:00:25 ago on Sat 12 Oct 2019 10:51:11 AM CST.MariaDB-server-10.4.8-1.el8.x86_64.rpm 197 kB/s | 26 MB 02:14 Dependencies resolved.===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: MariaDB-server x86_64 10.4.8-1.el8 @commandline 26 MInstalling dependencies: boost-program-options x86_64 1.66.0-6.el8 cdrom-AppStream 143 k perl-DBI x86_64 1.641-2.module_el8.0.0+66+fe1eca09 cdrom-AppStream 740 k perl-Digest noarch 1.17-395.el8 cdrom-AppStream 27 k perl-Digest-MD5 x86_64 2.55-396.el8 cdrom-AppStream 37 k perl-Net-SSLeay x86_64 1.85-6.el8 cdrom-AppStream 358 k perl-URI noarch 1.73-3.el8 cdrom-AppStream 116 k perl-libnet noarch 3.11-3.el8 cdrom-AppStream 121 k lsof x86_64 4.91-2.el8 cdrom-base 253 k perl-Carp noarch 1.42-396.el8 cdrom-base 30 k perl-Data-Dumper x86_64 2.167-399.el8 cdrom-base 58 k perl-Encode x86_64 4:2.97-3.el8 cdrom-base 1.5 M perl-Errno x86_64 1.28-416.el8 cdrom-base 76 k perl-Exporter noarch 5.72-396.el8 cdrom-base 34 k perl-File-Path noarch 2.15-2.el8 cdrom-base 38 k perl-File-Temp noarch 0.230.600-1.el8 cdrom-base 63 k perl-Getopt-Long noarch 1:2.50-4.el8 cdrom-base 63 k perl-HTTP-Tiny noarch 0.074-1.el8 cdrom-base 58 k perl-IO x86_64 1.38-416.el8 cdrom-base 141 k perl-MIME-Base64 x86_64 3.15-396.el8 cdrom-base 31 k perl-Math-BigInt noarch 1:1.9998.11-5.el8 cdrom-base 195 k perl-Math-Complex noarch 1.59-416.el8 cdrom-base 108 k perl-PathTools x86_64 3.74-1.el8 cdrom-base 90 k perl-Pod-Escapes noarch 1:1.07-395.el8 cdrom-base 20 k perl-Pod-Perldoc noarch 3.28-396.el8 cdrom-base 86 k perl-Pod-Simple noarch 1:3.35-395.el8 cdrom-base 213 k perl-Pod-Usage noarch 4:1.69-395.el8 cdrom-base 34 k perl-Scalar-List-Utils x86_64 3:1.49-2.el8 cdrom-base 68 k perl-Socket x86_64 4:2.027-2.el8 cdrom-base 59 k perl-Storable x86_64 1:3.11-3.el8 cdrom-base 98 k perl-Term-ANSIColor noarch 4.06-396.el8 cdrom-base 46 k perl-Term-Cap noarch 1.17-395.el8 cdrom-base 23 k perl-Text-ParseWords noarch 3.30-395.el8 cdrom-base 18 k perl-Text-Tabs+Wrap noarch 2013.0523-395.el8 cdrom-base 24 k perl-Time-Local noarch 1:1.280-1.el8 cdrom-base 34 k perl-Unicode-Normalize x86_64 1.25-396.el8 cdrom-base 82 k perl-constant noarch 1.33-396.el8 cdrom-base 25 k perl-interpreter x86_64 4:5.26.3-416.el8 cdrom-base 6.3 M perl-libs x86_64 4:5.26.3-416.el8 cdrom-base 1.6 M perl-macros x86_64 4:5.26.3-416.el8 cdrom-base 72 k perl-parent noarch 1:0.237-1.el8 cdrom-base 20 k perl-podlators noarch 4.11-1.el8 cdrom-base 118 k perl-threads x86_64 1:2.21-2.el8 cdrom-base 61 k perl-threads-shared x86_64 1.58-2.el8 cdrom-base 48 k rsync x86_64 3.1.3-4.el8 cdrom-base 404 k MariaDB-client x86_64 10.4.8-1.el8 mariadb10.4.8 12 M MariaDB-common x86_64 10.4.8-1.el8 mariadb10.4.8 87 k galera-4 x86_64 26.4.2-1.rhel8.0.el8 mariadb10.4.8 13 MInstalling weak dependencies: perl-IO-Socket-IP noarch 0.39-5.el8 cdrom-AppStream 47 k perl-IO-Socket-SSL noarch 2.060-2.el8 cdrom-AppStream 289 k perl-Mozilla-CA noarch 20160104-7.el8 cdrom-AppStream 15 kTransaction Summary=====================================================================================================================================Install 51 PackagesTotal size: 65 MTotal download size: 25 MInstalled size: 236 MIs this ok [y/N]: yDownloading Packages:(1/3): MariaDB-common-10.4.8-1.el8.x86_64.rpm 35 kB/s | 87 kB 00:02 (2/3): MariaDB-client-10.4.8-1.el8.x86_64.rpm 203 kB/s | 12 MB 00:59 (3/3): galera-4-26.4.2-1.rhel8.0.el8.x86_64.rpm 198 kB/s | 13 MB 01:08 -------------------------------------------------------------------------------------------------------------------------------------Total 376 kB/s | 25 MB 01:08 Running transaction checkTransaction check succeeded.Running transaction testTransaction test succeeded.Running transaction Preparing : 1/1 Installing : perl-Exporter-5.72-396.el8.noarch 1/51 Installing : perl-libs-4:5.26.3-416.el8.x86_64 2/51 Installing : perl-Carp-1.42-396.el8.noarch 3/51 Installing : perl-Scalar-List-Utils-3:1.49-2.el8.x86_64 4/51 Installing : perl-parent-1:0.237-1.el8.noarch 5/51 Installing : perl-Text-ParseWords-3.30-395.el8.noarch 6/51 Running scriptlet: MariaDB-common-10.4.8-1.el8.x86_64 7/51 Installing : MariaDB-common-10.4.8-1.el8.x86_64 7/51 Running scriptlet: MariaDB-common-10.4.8-1.el8.x86_64 7/51 Installing : perl-Term-ANSIColor-4.06-396.el8.noarch 8/51 Installing : perl-macros-4:5.26.3-416.el8.x86_64 9/51 Installing : perl-Errno-1.28-416.el8.x86_64 10/51 Installing : perl-Socket-4:2.027-2.el8.x86_64 11/51 Installing : perl-Text-Tabs+Wrap-2013.0523-395.el8.noarch 12/51 Installing : perl-Unicode-Normalize-1.25-396.el8.x86_64 13/51 Installing : perl-File-Path-2.15-2.el8.noarch 14/51 Installing : perl-IO-1.38-416.el8.x86_64 15/51 Installing : perl-PathTools-3.74-1.el8.x86_64 16/51 Installing : perl-constant-1.33-396.el8.noarch 17/51 Installing : perl-threads-1:2.21-2.el8.x86_64 18/51 Installing : perl-threads-shared-1.58-2.el8.x86_64 19/51 Installing : perl-interpreter-4:5.26.3-416.el8.x86_64 20/51 Installing : perl-MIME-Base64-3.15-396.el8.x86_64 21/51 Installing : perl-IO-Socket-IP-0.39-5.el8.noarch 22/51 Installing : perl-Data-Dumper-2.167-399.el8.x86_64 23/51 Installing : perl-File-Temp-0.230.600-1.el8.noarch 24/51 Installing : perl-Storable-1:3.11-3.el8.x86_64 25/51 Installing : perl-Time-Local-1:1.280-1.el8.noarch 26/51 Installing : perl-Digest-1.17-395.el8.noarch 27/51 Installing : perl-Digest-MD5-2.55-396.el8.x86_64 28/51 Installing : perl-Net-SSLeay-1.85-6.el8.x86_64 29/51 Installing : perl-Math-Complex-1.59-416.el8.noarch 30/51 Installing : perl-Math-BigInt-1:1.9998.11-5.el8.noarch 31/51 Installing : perl-Pod-Escapes-1:1.07-395.el8.noarch 32/51 Installing : perl-Term-Cap-1.17-395.el8.noarch 33/51 Installing : perl-Mozilla-CA-20160104-7.el8.noarch 34/51 Installing : perl-Encode-4:2.97-3.el8.x86_64 35/51 Installing : perl-Pod-Simple-1:3.35-395.el8.noarch 36/51 Installing : perl-Getopt-Long-1:2.50-4.el8.noarch 37/51 Installing : perl-podlators-4.11-1.el8.noarch 38/51 Installing : perl-Pod-Usage-4:1.69-395.el8.noarch 39/51 Installing : perl-Pod-Perldoc-3.28-396.el8.noarch 40/51 Installing : perl-HTTP-Tiny-0.074-1.el8.noarch 41/51 Installing : perl-IO-Socket-SSL-2.060-2.el8.noarch 42/51 Installing : perl-libnet-3.11-3.el8.noarch 43/51 Installing : perl-URI-1.73-3.el8.noarch 44/51 Installing : perl-DBI-1.641-2.module_el8.0.0+66+fe1eca09.x86_64 45/51 Running scriptlet: MariaDB-client-10.4.8-1.el8.x86_64 46/51 Installing : MariaDB-client-10.4.8-1.el8.x86_64 46/51 Running scriptlet: MariaDB-client-10.4.8-1.el8.x86_64 46/51 Installing : rsync-3.1.3-4.el8.x86_64 47/51 Installing : lsof-4.91-2.el8.x86_64 48/51 Installing : boost-program-options-1.66.0-6.el8.x86_64 49/51 Running scriptlet: boost-program-options-1.66.0-6.el8.x86_64 49/51 Running scriptlet: galera-4-26.4.2-1.rhel8.0.el8.x86_64 50/51 Installing : galera-4-26.4.2-1.rhel8.0.el8.x86_64 50/51 Running scriptlet: galera-4-26.4.2-1.rhel8.0.el8.x86_64 50/51 Running scriptlet: MariaDB-server-10.4.8-1.el8.x86_64 51/51 Installing : MariaDB-server-10.4.8-1.el8.x86_64 51/51 Running scriptlet: MariaDB-server-10.4.8-1.el8.x86_64 51/51 Two all-privilege accounts were created.One is root@localhost, it has no password, but you need tobe system 'root' user to connect. Use, for example, sudo mysqlThe second is mysql@localhost, it has no password either, butyou need to be the system 'mysql' user to connect.After connecting you can set the password, if you would need to beable to connect as any of these users with a password and without sudoSee the MariaDB Knowledgebase at http://mariadb.com/kb or theMySQL manual for more instructions.Please report any problems at http://mariadb.org/jiraThe latest information about MariaDB is available at http://mariadb.org/.You can find additional information about the MySQL part at:http://dev.mysql.comConsider joining MariaDB's strong and vibrant community:https://mariadb.org/get-involved/ Verifying : boost-program-options-1.66.0-6.el8.x86_64 1/51 Verifying : perl-DBI-1.641-2.module_el8.0.0+66+fe1eca09.x86_64 2/51 Verifying : perl-Digest-1.17-395.el8.noarch 3/51 Verifying : perl-Digest-MD5-2.55-396.el8.x86_64 4/51 Verifying : perl-IO-Socket-IP-0.39-5.el8.noarch 5/51 Verifying : perl-IO-Socket-SSL-2.060-2.el8.noarch 6/51 Verifying : perl-Mozilla-CA-20160104-7.el8.noarch 7/51 Verifying : perl-Net-SSLeay-1.85-6.el8.x86_64 8/51 Verifying : perl-URI-1.73-3.el8.noarch 9/51 Verifying : perl-libnet-3.11-3.el8.noarch 10/51 Verifying : lsof-4.91-2.el8.x86_64 11/51 Verifying : perl-Carp-1.42-396.el8.noarch 12/51 Verifying : perl-Data-Dumper-2.167-399.el8.x86_64 13/51 Verifying : perl-Encode-4:2.97-3.el8.x86_64 14/51 Verifying : perl-Errno-1.28-416.el8.x86_64 15/51 Verifying : perl-Exporter-5.72-396.el8.noarch 16/51 Verifying : perl-File-Path-2.15-2.el8.noarch 17/51 Verifying : perl-File-Temp-0.230.600-1.el8.noarch 18/51 Verifying : perl-Getopt-Long-1:2.50-4.el8.noarch 19/51 Verifying : perl-HTTP-Tiny-0.074-1.el8.noarch 20/51 Verifying : perl-IO-1.38-416.el8.x86_64 21/51 Verifying : perl-MIME-Base64-3.15-396.el8.x86_64 22/51 Verifying : perl-Math-BigInt-1:1.9998.11-5.el8.noarch 23/51 Verifying : perl-Math-Complex-1.59-416.el8.noarch 24/51 Verifying : perl-PathTools-3.74-1.el8.x86_64 25/51 Verifying : perl-Pod-Escapes-1:1.07-395.el8.noarch 26/51 Verifying : perl-Pod-Perldoc-3.28-396.el8.noarch 27/51 Verifying : perl-Pod-Simple-1:3.35-395.el8.noarch 28/51 Verifying : perl-Pod-Usage-4:1.69-395.el8.noarch 29/51 Verifying : perl-Scalar-List-Utils-3:1.49-2.el8.x86_64 30/51 Verifying : perl-Socket-4:2.027-2.el8.x86_64 31/51 Verifying : perl-Storable-1:3.11-3.el8.x86_64 32/51 Verifying : perl-Term-ANSIColor-4.06-396.el8.noarch 33/51 Verifying : perl-Term-Cap-1.17-395.el8.noarch 34/51 Verifying : perl-Text-ParseWords-3.30-395.el8.noarch 35/51 Verifying : perl-Text-Tabs+Wrap-2013.0523-395.el8.noarch 36/51 Verifying : perl-Time-Local-1:1.280-1.el8.noarch 37/51 Verifying : perl-Unicode-Normalize-1.25-396.el8.x86_64 38/51 Verifying : perl-constant-1.33-396.el8.noarch 39/51 Verifying : perl-interpreter-4:5.26.3-416.el8.x86_64 40/51 Verifying : perl-libs-4:5.26.3-416.el8.x86_64 41/51 Verifying : perl-macros-4:5.26.3-416.el8.x86_64 42/51 Verifying : perl-parent-1:0.237-1.el8.noarch 43/51 Verifying : perl-podlators-4.11-1.el8.noarch 44/51 Verifying : perl-threads-1:2.21-2.el8.x86_64 45/51 Verifying : perl-threads-shared-1.58-2.el8.x86_64 46/51 Verifying : rsync-3.1.3-4.el8.x86_64 47/51 Verifying : MariaDB-client-10.4.8-1.el8.x86_64 48/51 Verifying : MariaDB-common-10.4.8-1.el8.x86_64 49/51 Verifying : galera-4-26.4.2-1.rhel8.0.el8.x86_64 50/51 Verifying : MariaDB-server-10.4.8-1.el8.x86_64 51/51 Installed: MariaDB-server-10.4.8-1.el8.x86_64 perl-IO-Socket-IP-0.39-5.el8.noarch perl-IO-Socket-SSL-2.060-2.el8.noarch perl-Mozilla-CA-20160104-7.el8.noarch boost-program-options-1.66.0-6.el8.x86_64 perl-DBI-1.641-2.module_el8.0.0+66+fe1eca09.x86_64 perl-Digest-1.17-395.el8.noarch perl-Digest-MD5-2.55-396.el8.x86_64 perl-Net-SSLeay-1.85-6.el8.x86_64 perl-URI-1.73-3.el8.noarch perl-libnet-3.11-3.el8.noarch lsof-4.91-2.el8.x86_64 perl-Carp-1.42-396.el8.noarch perl-Data-Dumper-2.167-399.el8.x86_64 perl-Encode-4:2.97-3.el8.x86_64 perl-Errno-1.28-416.el8.x86_64 perl-Exporter-5.72-396.el8.noarch perl-File-Path-2.15-2.el8.noarch perl-File-Temp-0.230.600-1.el8.noarch perl-Getopt-Long-1:2.50-4.el8.noarch perl-HTTP-Tiny-0.074-1.el8.noarch perl-IO-1.38-416.el8.x86_64 perl-MIME-Base64-3.15-396.el8.x86_64 perl-Math-BigInt-1:1.9998.11-5.el8.noarch perl-Math-Complex-1.59-416.el8.noarch perl-PathTools-3.74-1.el8.x86_64 perl-Pod-Escapes-1:1.07-395.el8.noarch perl-Pod-Perldoc-3.28-396.el8.noarch perl-Pod-Simple-1:3.35-395.el8.noarch perl-Pod-Usage-4:1.69-395.el8.noarch perl-Scalar-List-Utils-3:1.49-2.el8.x86_64 perl-Socket-4:2.027-2.el8.x86_64 perl-Storable-1:3.11-3.el8.x86_64 perl-Term-ANSIColor-4.06-396.el8.noarch perl-Term-Cap-1.17-395.el8.noarch perl-Text-ParseWords-3.30-395.el8.noarch perl-Text-Tabs+Wrap-2013.0523-395.el8.noarch perl-Time-Local-1:1.280-1.el8.noarch perl-Unicode-Normalize-1.25-396.el8.x86_64 perl-constant-1.33-396.el8.noarch perl-interpreter-4:5.26.3-416.el8.x86_64 perl-libs-4:5.26.3-416.el8.x86_64 perl-macros-4:5.26.3-416.el8.x86_64 perl-parent-1:0.237-1.el8.noarch perl-podlators-4.11-1.el8.noarch perl-threads-1:2.21-2.el8.x86_64 perl-threads-shared-1.58-2.el8.x86_64 rsync-3.1.3-4.el8.x86_64 MariaDB-client-10.4.8-1.el8.x86_64 MariaDB-common-10.4.8-1.el8.x86_64 galera-4-26.4.2-1.rhel8.0.el8.x86_64 Complete! &emsp;&emsp;果然成功了。问题解决。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
        <tag>mariadb</tag>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化运维之Ansible]]></title>
    <url>%2F%2Fblog%2F8a189dcf.html</url>
    <content type="text"><![CDATA[企业实际应用场景分析 Dev开发环境&emsp;&emsp;使用者：程序员&emsp;&emsp;功能：程序员开发软件，测试BUG的环境&emsp;&emsp;管理者：程序员 测试环境&emsp;&emsp;使用者：QA测试工程师&emsp;&emsp;功能：测试经过Dev环境测试通过的软件的功能&emsp;&emsp;管理者：运维&emsp;&emsp;说明：测试环境往往有多套,测试环境满足测试功能即可，不宜过多&emsp;&emsp;1、测试人员希望测试环境有多套,公司的产品多产品线并发，即多个版本，意味着多个版本同步测试&emsp;&emsp;2、通常测试环境有多少套和产品线数量保持一样 发布环境：代码发布机,有些公司为堡垒机（安全屏障）&emsp;&emsp;使用者：运维&emsp;&emsp;功能：发布代码至生产环境&emsp;&emsp;管理者：运维（有经验）&emsp;&emsp;发布机：往往需要有2台（主备） 生产环境&emsp;&emsp;使用者：运维，少数情况开放权限给核心开发人员，极少数公司将权限完全开放给开发人员并其维护&emsp;&emsp;功能：对用户提供公司产品的服务&emsp;&emsp;管理者：只能是运维&emsp;&emsp;生产环境服务器数量：一般比较多，且应用非常重要。往往需要自动工具协助部署配置应用 灰度环境（生产环境的一部分）&emsp;&emsp;使用者：运维&emsp;&emsp;功能：在全量发布代码前将代码的功能面向少量精准用户发布的环境,可基于主机或用户执行灰度发布&emsp;&emsp;案例：共100台生产服务器，先发布其中的10台服务器，这10台服务器就是灰度服务器&emsp;&emsp;管理者：运维&emsp;&emsp;灰度环境：往往该版本功能变更较大，为保险起见特意先让一部分用户优化体验该功能，待这部分用户使用没有重大问题的时候，再全量发布至所有服务器程序发布 程序发布要求：&emsp;&emsp;不能导致系统故障或造成系统完全不可用&emsp;&emsp;不能影响用户体验 预发布验证：&emsp;&emsp;新版本的代码先发布到服务器（跟线上环境配置完全相同，只是未接入到调度器） 灰度发布：&emsp;&emsp;基于主机，用户，业务 发布路径：&emsp;&emsp;/webapp/tuangou&emsp;&emsp;/webapp/tuangou-1.1&emsp;&emsp;/webapp/tuangou-1.2 发布过程：在调度器上下线一批主机(标记为maintenance 状态) –&gt; 关闭服务 –&gt; 部署新版本的应用程序 –&gt; 启动服务 –&gt; 在调度器上启用这一批服务器 自动化灰度发布：脚本、发布平台自动化运维应用场景 文件传输 应用部署 配置管理 任务流编排常用自动化运维工具 Ansible：python，Agentless，中小型应用环境 Saltstack：python，一般需部署agent，执行效率更高 Puppet：ruby, 功能强大，配置复杂，重型,适合大型环境 Fabric：python，agentless Chef：ruby，国内应用少 Cfengine funcAnsible简介 var ap = new APlayer({ element: document.getElementById("aplayer-dKWftoHq"), narrow: false, autoplay: true, showlrc: false, music: { title: "Coming Home", author: "Peter Jeremias", url: "https://hewanyue.com/mp3/ComingHome.mp3", pic: "https://hewanyue.com/mp3/cover/ComingHome.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Ansible特性 模块化：调用特定的模块，完成特定任务 Paramiko（python对ssh的实现），PyYAML，Jinja2（模板语言）三个关键模块 支持自定义模块 基于Python语言实现 部署简单，基于python和SSH(默认已安装)，agentless 安全，基于OpenSSH 支持playbook编排任务 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况 无需代理不依赖PKI（无需ssl） 可使用任何编程语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案Ansible架构Ansible工作原理Ansible主要组成部分 ANSIBLE PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件 INVENTORY：Ansible管理主机的清单/etc/anaible/hosts MODULES：Ansible执行命令的功能模块，多数为内置核心模块，也可自定义 PLUGINS：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用 API：供第三方程序调用的应用程序编程接口 ANSIBLE：组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具Ansible命令执行来源： USER，普通用户，即SYSTEM ADMINISTRATOR CMDB（配置管理数据库） API 调用 PUBLIC/PRIVATE CLOUD API调用 USER-&gt; Ansible Playbook -&gt; Ansibile利用ansible实现管理的方式： Ad-Hoc 即ansible命令，主要用于临时命令使用场景 Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前期的规划过程 Ansible-playbook（剧本）执行过程 将已有编排好的任务集写入Ansible-Playbook 通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行Ansible主要操作对象 HOSTS主机 NETWORKING网络设备注意事项&emsp;&emsp;执行ansible的主机一般称为主控端，中控，master或堡垒机&emsp;&emsp;主控端Python版本需要2.6或以上&emsp;&emsp;被控端Python版本小于2.4需要安装python-simplejson&emsp;&emsp;被控端如开启SELinux需要安装libselinux-python&emsp;&emsp;windows不能做为主控端 安装Ansiblerpm包安装: EPEL源yum install ansible 编译安装:12345678yum -y install python-jinja2 PyYAML python-paramiko python-babel python-cryptowget https://releases.ansible.com/ansible/ansible-1.5.4.tar.gztar xf ansible-1.5.4.tar.gzcd ansible-1.5.4python setup.py buildpython setup.py installmkdir /etc/ansiblecp -r examples/* /etc/ansible Git方式: 123git clone git://github.com/ansible/ansible.git --recursivecd ./ansiblesource ./hacking/env-setup pip安装： pip是安装Python包的管理器，类似yum 1234yum install python-pip python-develyum install gcc glibc-devel zibl-devel rpm-bulid openssl-develpip install --upgrade pippip install ansible --upgrade 确认安装： ansible --version 配置Ansible配置文件&emsp;&emsp;/etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性（一般保持默认） 12345678910111213[defaults]#inventory = /etc/ansible/hosts # 主机列表配置文件#library = /usr/share/my_modules/ # 库文件存放目录#remote_tmp = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录#local_tmp = $HOME/.ansible/tmp # 本机的临时命令执行目录#forks = 5 # 默认并发数#sudo_user = root # 默认sudo 用户#ask_sudo_pass = True #每次执行ansible命令是否询问ssh密码#ask_pass = True#remote_port = 22#host_key_checking = False # 检查对应服务器的host_key，建议取消注释#log_path=/var/log/ansible.log #日志文件#module_name = command #默认模块 &emsp;&emsp;/etc/ansible/hosts Inventory 主机清单&emsp;&emsp;ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名 默认的inventory file为/etc/ansible/hosts inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成文件格式 inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明ntp.servers.com[webservers]www1.webservers.com:2222www2.webservers.com[dbservers]db1.dbservers.comdb2.dbservers.comdb3.dbservers.com主机清单inventory 如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机 示例：[websrvs]www[1:100].example.com[dbsrvs]db-[a:f].example.com &emsp;&emsp;/etc/ansible/roles/ 存放角色的目录 程序&emsp;&emsp;/usr/bin/ansible 主程序，临时命令执行工具&emsp;&emsp;/usr/bin/ansible-doc 查看配置文档，模块功能查看工具&emsp;&emsp;/usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台&emsp;&emsp;/usr/bin/ansible-playbook 定制自动化任务，编排剧本工具&emsp;&emsp;/usr/bin/ansible-pull 远程执行命令的工具&emsp;&emsp;/usr/bin/ansible-vault 文件加密工具&emsp;&emsp;/usr/bin/ansible-console 基于Console界面与用户交互的执行工具 Ansible命令 ansible ansible-doc ansible-playbook ansible-vault ansible-console ansible-galaxy ansible-pullansible-doc: 显示模块帮助ansible-doc [options] [module...]&emsp;&emsp;-l, –list 列出可用模块&emsp;&emsp;-s, –snippet显示指定模块的playbook片段示例：&emsp;&emsp;ansible-doc -l 列出所有模块&emsp;&emsp;ansible-doc ping 查看指定模块帮助用法&emsp;&emsp;ansible-doc -s ping 查看指定模块帮助用法ansible&emsp;&emsp;ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点ansible &amp;lthost-pattern&amp;gt [-m module_name] [-a args]ansible选项&emsp;&emsp;–version 显示版本&emsp;&emsp;-m module 指定模块，默认为command&emsp;&emsp;-v 详细过程 –vv -vvv更详细&emsp;&emsp;–list-hosts 显示主机列表，可简写 –list&emsp;&emsp;-k, –ask-pass 提示输入ssh连接密码，默认Key验证&emsp;&emsp;-C, –check 检查，并不执行&emsp;&emsp;-T, –timeout=TIMEOUT 执行命令的超时时间，默认10s&emsp;&emsp;-u, –user=REMOTE_USER 执行远程执行的用户&emsp;&emsp;-b, –become 代替旧版的sudo 切换&emsp;&emsp;–become-user=USERNAME 指定sudo的runas用户，默认为root&emsp;&emsp;-K, –ask-become-pass 提示输入sudo时的口令 ansible的Host-pattern匹配主机的列表 All ：表示所有Inventory中的所有主机ansible all –m ping * :通配符ansible &quot;*&quot; -m pingansible 192.168.1.* -m pingansible &quot;*srvs&quot; -m ping 或关系ansible &quot;websrvs:appsrvs&quot; -m pingansible &quot;192.168.1.10:192.168.1.20&quot; -m ping 逻辑与ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping在websrvs组并且在dbsrvs组中的主机 逻辑非ansible &#39;websrvs:!dbsrvs&#39; –m ping在websrvs组，但不在dbsrvs组中的主机注意：此处为单引号 综合逻辑ansible &#39;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&#39; –m ping 正则表达式ansible &quot;websrvs:&amp;dbsrvs&quot; –m pingansible &quot;~(web|db).*.servers.com&quot; –m pingansible常用模块模块文档：https://docs.ansible.com/ansible/latest/modules/modules_by_category.html Command：在远程主机执行命令，默认模块，可忽略-m选项ansible srvs -m command -a &#39;service vsftpd start&#39;ansible srvs -m command -a &#39;echo passwd |passwd --stdin user&#39;此命令不支持 $VARNAME &amp;lt &amp;gt | ; &amp; 等，须用shell模块实现 Shell：和command相似，用shell执行命令ansible srv -m shell -a ‘echo passwd |passwd –stdin user’&emsp;&emsp;调用bash执行命令 类似cat /tmp/stanley.md | awk -F&#39;|&#39; &#39;{print $1,$2}&#39;&amp;&gt; /tmp/example.txt这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器 Script：在远程主机上运行ansible服务器上的脚本ansible &amp;lthost-pattern&amp;gt -m script -a &quot;/PATH/TO/SCRIPT_FILE&quot;ansible websrvs -m script -a /data/test.sh Copy：从主控端复制文件到远程主机ansible srv -m copy -a &quot;src=/root/test1.sh dest=/tmp/test2.sh owner=wang mode=600 backup=yes&quot;如目标存在，默认覆盖，此处指定先备份ansible srv -m copy -a &quot;content=&#39;test content\n&#39; dest=/tmp/test.txt&quot;指定内容，直接生成目标文件 Fetch：从远程主机提取文件至主控端，copy相反，目前不支持目录ansible srv -m fetch -a &#39;src=/root/test.sh dest=/data/scripts&#39; File：设置文件属性ansible srv -m file -a &quot;path=/root/test.sh owner=wang mode=755&quot;ansible srv -m file -a &quot;path=/data/testdir state=directory&quot;ansible srv -m file -a &#39;src=/data/testfile dest=/data/testfile-link state=link&#39; unarchive：解包解压缩，有两种用法：1、将ansible主机上的压缩包传到远程主机后解压缩至特定目录，设置copy=yes.2、将远程主机上的某个压缩包解压缩到指定路径下，设置copy=no常见参数：copy：默认为yes，当copy=yes，拷贝的文件是从ansible主机复制到远程主机上，如果设置为copy=no，会在远程主机上寻找src源文件src：源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，如果是远程主机上的路径，则需要设置copy=nodest：远程主机上的目标路径mode：设置解压缩后的文件权限示例：ansible srv -m unarchive -a &#39;src=/data/foo.tgz dest=/var/lib/foo&#39;ansible srv -m unarchive -a &#39;src=/tmp/foo.zip dest=/data copy=no mode=0777&#39;ansible srv -m unarchive -a &#39;src=https://example.com/example.zip dest=/data copy=no&#39; Archive：打包压缩ansible all -m archive -a &#39;path=/etc/sysconfig dest=/data/sysconfig.tar.bz2 format=bz2 owner=wang mode=0777&#39; Hostname：管理主机名ansible node1 -m hostname -a &quot;name=websrv&quot; Cron：计划任务支持时间：minute，hour，day，month，weekdayansible srv -m cron -a &quot;minute=*/5 job=&#39;/usr/sbin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&#39; name=Synctime&quot;创建任务ansible srv -m cron -a &#39;state=absent name=Synctime&#39;删除任务 Yum：管理包ansible srv -m yum -a &#39;name=httpd state=present&#39;安装ansible srv -m yum -a &#39;name=httpd state=absent&#39;删除ansible常用模块 Service：管理服务ansible srv -m service -a &#39;name=httpd state=stopped&#39;ansible srv -m service -a &#39;name=httpd state=started enabled=yes&#39;ansible srv -m service -a &#39;name=httpd state=reloaded&#39;ansible srv -m service -a &#39;name=httpd state=restarted&#39; User：管理用户ansible srv -m user -a &#39;name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root&#39;ansible srv -m user -a &#39;name=sysuser1 system=yes home=/app/sysuser1&#39;ansible srv -m user -a &#39;name=user1 state=absent remove=yes&#39;删除用户及家目录等数据 Group：管理组ansible srv -m group -a &quot;name=testgroup system=yes&quot;ansible srv -m group -a &quot;name=testgroup state=absent&quot;ansible命令执行过程&emsp;&emsp;1. 加载自己的配置文件 默认/etc/ansible/ansible.cfg&emsp;&emsp;2. 加载自己对应的模块文件，如command&emsp;&emsp;3. 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件&emsp;&emsp;4. 给文件+x执行&emsp;&emsp;5. 执行并返回结果&emsp;&emsp;6. 删除临时py文件，退出&emsp;&emsp;执行状态：&emsp;&emsp;&emsp;&emsp;绿色：执行成功并且不需要做改变的操作&emsp;&emsp;&emsp;&emsp;黄色：执行成功并且对目标主机做变更&emsp;&emsp;&emsp;&emsp;红色：执行失败ansible-galaxy&emsp;&emsp;连接 https://galaxy.ansible.com 下载相应的rolesansible-galaxy&emsp;&emsp;列出所有已安装的galaxyansible-galaxy list&emsp;&emsp;安装galaxyansible-galaxy install geerlingguy.redis&emsp;&emsp;删除galaxyansible-galaxy remove geerlingguy.redisansible-pull&emsp;&emsp;推送命令至远程，效率无限提升，对运维要求较高ansible-playbook&emsp;&emsp;执行playbook&emsp;&emsp; 示例：ansible-playbook hello.yml123456#hello world yml file- hosts: websrvs remote_user: root tasks: - name: hello world command: /usr/bin/wall hello world ansible-vault&emsp;&emsp;功能：管理加密解密yml文件ansible-vault [create|decrypt|edit|encrypt|rekey|view]ansible-vault encrypt hello.yml 加密ansible-vault decrypt hello.yml 解密ansible-vault view hello.yml 查看ansible-vault edit hello.yml 编辑加密文件ansible-vault rekey hello.yml 修改口令ansible-vault create new.yml 创建新文件 Ansible-console&emsp;&emsp;ansible终端。2.0+新增，可交互执行命令，支持tabroot@test (2)[f:10] $ 执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$ 设置并发数： forks n 例如： forks 10 切换组： cd 主机组 例如： cd web 列出当前组主机列表： list 列出所有的内置命令： ?或help 示例：root@all (2)[f:5]$ listroot@all (2)[f:5]$ cd appsrvsroot@appsrvs (2)[f:5]$ listroot@appsrvs (2)[f:5]$ yum name=httpd state=presentroot@appsrvs (2)[f:5]$ service name=httpd state=startedplaybook playbook是由一个或多个“play”组成的列表 play的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。Task实际是调用ansible的一个module，将多个play组织在一个playbook中，即可以让它们联合起来，按事先编排的机制执行预定义的动作 Playbook采用YAML语言编写 playbook核心元素 Hosts 执行的远程主机列表 Tasks 任务集 Variables 内置变量或自定义变量在playbook中调用 Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers 和 notify 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断ansible-playbook -t tagsname useradd.ymlplaybook基础组件 Hosts：&emsp;&emsp;playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中。可以是如下形式：one.example.comone.example.com:two.example.com 192.168.1.50192.168.1.*Websrvs:dbsrvs 或者，两个组的并集Websrvs:&amp;dbsrvs 与，两个组的交集webservers:!phoenix 在websrvs组，但不在dbsrvs组 示例: - hosts: websrvs：dbsrvs remote_user&emsp;&emsp;remote_user: 可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户 12345678- hosts: websrvs remote_user: root tasks: - name: test connection ping: remote_user: user sudo: yes 默认sudo为root sudo_user: wang sudo为wang task列表和action&emsp;&emsp;play的主体部分是task list，task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后，再开始第二个任务&emsp;&emsp;task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致&emsp;&emsp;每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出playbook基础组件&emsp;&emsp;tasks：任务列表&emsp;&emsp;两种格式：(1) action: module arguments(2) module: arguments 建议使用&emsp;&emsp;注意：shell和command模块后面跟命令，而非key=value&emsp;&emsp;某任务的状态在运行后为changed时，可通过“notify”通知给相应的handlers&emsp;&emsp;任务可以通过”tags“打标签，可在ansible-playbook命令上使用-t指定进行调用示例： 123tasks: - name: disable selinux command: /sbin/setenforce 0 &emsp;&emsp;如果命令或脚本的退出码不为零，可以使用如下方式替代 123tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand || /bin/true &emsp;&emsp;或者使用ignore_errors来忽略错误信息 1234tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand ignore_errors: True 运行playbook 运行playbook的方式ansible-playbook &amp;ltfilename.yml&amp;gt ... [options] 常见选项 -check -C 只检测可能会发生的改变，但不真正执行操作 -list-hosts 列出运行任务的主机 -list-tags 列出tag -list-tasks 列出task -limit 主机列表 只针对主机列表中的主机执行 v -vv -vvv 显示过程 示例ansible-playbook file.yml --check 只检测ansible-playbook file.ymlansible-playbook file.yml --limit websrvs&emsp;&emsp;可以对比下SHELL脚本VSPlaybook123456789#!/bin/bash# 安装Apacheyum install --quiet -y httpd# 复制配置文件cp /tmp/httpd.conf /etc/httpd/conf/httpd.confcp /tmp/vhosts.conf /etc/httpd/conf.d/# 启动Apache，并设置开机启动service httpd startchkconfig httpd on 1234567891011- hosts: all remote_user: root tasks: - name: "安装Apache" yum: name=httpd - name: "复制配置文件" copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/ - name: "复制配置文件" copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/ - name: "启动Apache，并设置开机启动" service: name=httpd state=started enabled=yes 示例：sysuser.yml 1234567- hosts: all remote_user: root tasks: - name: create mysql user user: name=mysql system=yes uid=36 - name: create a group group: name=httpd system=yes 示例：httpd.yml 123456789- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ - name: start service service: name=httpd state=started enabled=yes handlers和notify结合使用触发条件 Handlers是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作 Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作Playbook中handlers使用12345678910111213- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ notify: restart httpd - name: ensure apache is running service: name=httpd state=started enabled=yes handlers: - name: restart httpd service: name=httpd state=restarted 示例 1234567891011121314151617181920- hosts: websrvs remote_user: root tasks: - name: add group nginx tags: user user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: Install Nginx yum: name=nginx state=present - name: config copy: src=/root/config.txt dest=/etc/nginx/nginx.conf notify: - Restart Nginx - Check Nginx Process handlers: - name: Restart Nginx service: name=nginx state=restarted enabled=yes - name: Check Nginx process shell: killall -0 nginx &amp;&gt; /tmp/nginx.log Playbook中tags使用示例：httpd.yml 1234567891011- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ tags: conf - name: start httpd service tags: service service: name=httpd state=started enabled=yes ansible-playbook –t conf httpd.yml Playbook中变量使用变量名：&emsp;&emsp;仅能由字母、数字和下划线组成，且只能以字母开头 变量来源： 1 ansible setup facts 远程主机的所有变量都可直接调用 2 在/etc/ansible/hosts中定义普通变量：主机组中主机单独定义，优先级高于公共变量公共（组）变量：针对主机组中所有主机定义统一变量 3 通过命令行指定变量，优先级最高ansible-playbook –e varname=value 4 在playbook中定义 123vars: - var1: value1 - var2: value2 5 在独立的变量YAML文件中定义 6 在role中定义 变量命名:&emsp;&emsp; 变量名仅能由字母、数字和下划线组成，且只能以字母开头 变量定义：&emsp;&emsp;key=value示例：http_port=80 变量调用方式： 通过 调用变量，且变量名前后必须有空格，有时用“”才生效 ansible-playbook –e 选项指定ansible-playbook test.yml -e &quot;hosts=www user=servers&quot;示例：使用setup变量示例：var.yml12345- hosts: websrvs remote_user: root tasks: - name: create log file file: name=/var/log/ &#123;&#123; ansible_fqdn &#125;&#125; state=touch ansible-playbook var.yml示例：var.yml 12345- hosts: websrvs remote_user: root tasks: - name: install package yum: name=&#123;&#123; pkname &#125;&#125; state=present ansible-playbook –e pkname=httpd var.yml 示例：var.yml 12345678910- hosts: websrvs remote_user: root vars: - username: user1 - groupname: group1 tasks: - name: create group group: name=&#123;&#123; groupname &#125;&#125; state=present - name: create user user: name=&#123;&#123; username &#125;&#125; state=present ansible-playbook var.ymlansible-playbook -e &quot;username=user2 groupname=group2” var2.yml 变量来源: 主机变量&emsp;&emsp;可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用示例：[websrvs]www1.servers.com http_port=80 maxRequestsPerChild=808www2.servers.com http_port=8080 maxRequestsPerChild=909 组变量&emsp;&emsp;组变量是指赋予给指定组内所有主机上的在playbook中可用的变量示例：[websrvs]www1.servers.comwww2.servers.com[websrvs:vars]ntp_server=ntp.servers.comnfs_server=nfs.servers.com示例：变量 普通变量[websrvs] 192.168.99.101 http_port=8080 hname=www1192.168.99.102 http_port=80 hname=www2 公共（组）变量[websvrs:vars]http_port=808mark=“-”[websrvs] 192.168.99.101 http_port=8080 hname=www1192.168.99.102 http_port=80 hname=www2ansible websvrs –m hostname –a ‘name=’ 命令行指定变量：ansible websvrs –e http_port=8000 –m hostname –a&#39;name=&#39; 使用变量文件cat vars.yml12var1: httpdvar2: nginx cat var.yml 123456789- hosts: web remote_user: root vars_files: - vars.yml tasks: - name: create httpd log file: name=/app/&#123;&#123; var1 &#125;&#125;.log state=touch - name: create nginx log file: name=/app/&#123;&#123; var2 &#125;&#125;.log state=touch 模板template 文本文件，嵌套有脚本（使用模板编程语言编写） Jinja2语言，使用字面量，有下面形式字符串：使用单引号或双引号数字：整数，浮点数列表：[item1, item2, …]元组：(item1, item2, …)字典：{key1:value1, key2:value2, …}布尔型：true/false 算术运算：+, -, , /, //, %, * 比较操作：==, !=, &gt;, &gt;=, &lt;, &lt;= 逻辑运算：and，or，not 流表达式：For，If，When template功能：根据模块文件动态生成对应的配置文件 template文件必须存放于templates目录下，且命名为 .j2 结尾 yaml/yml 文件需和templates目录平级，目录结构如下：./├── temnginx.yml└── templates└── nginx.conf.j2 template示例示例：利用template 同步nginx配置文件 准备templates/nginx.conf.j2文件vim temnginx.yml12345- hosts: websrvs remote_user: root tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf ansible-playbook temnginx.yml Playbook中template变更替换修改文件nginx.conf.j2 下面行为worker_processes ;cat temnginx2.yml12345- hosts: websrvs remote_user: root tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf ansible-playbook temnginx2.yml Playbook中template算术运算示例：vim nginx.conf.j2 12worker_processes &#123;&#123; ansible_processor_vcpus**2 &#125;&#125;;worker_processes &#123;&#123; ansible_processor_vcpus+2 &#125;&#125;; template条件判断when&emsp;&emsp;条件测试:如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过when语句实现，在task中使用，jinja2的语法格式when语句&emsp;&emsp;在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法示例： 1234tasks: - name: "shutdown RedHat flavored systems" command: /sbin/shutdown -h now when: ansible_os_family == "RedHat" 示例：when条件判断 12345678910111213- hosts: websrvs remote_user: root tasks: - name: add group nginx tags: user user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: Install Nginx yum: name=nginx state=present - name: restart Nginx service: name=nginx state=restarted when: ansible_distribution_major_version == “6” 示例：when条件判断 1234567tasks: - name: install conf file to centos7 template: src=nginx.conf.c7.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version == "7" - name: install conf file to centos6 template: src=nginx.conf.c6.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version == "6" 迭代：with_items迭代：当有需要重复性执行的任务时，可以使用迭代机制 对迭代项的引用，固定变量名为”item“ 要在task中使用with_items给定要迭代的元素列表 列表格式：&emsp;&emsp;字符串&emsp;&emsp;字典示例：12345- name: add several users user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel with_items: - testuser1 - testuser2 &emsp;&emsp;上面语句的功能等同于下面的语句： 1234- name: add user testuser1 user: name=testuser1 state=present groups=wheel- name: add user testuser2 user: name=testuser2 state=present groups=wheel 示例：将多个文件进行copy到被控端 12345678- hosts: testsrv remote_user: root tasks: - name: Create rsyncd config copy: src=&#123;&#123; item &#125;&#125; dest=/etc/&#123;&#123; item &#125;&#125; with_items: - rsyncd.secrets - rsyncd.conf 123456789101112131415- hosts: websrvs remote_user: root tasks: - name: copy file copy: src=&#123;&#123; item &#125;&#125; dest=/tmp/&#123;&#123; item &#125;&#125; with_items: - file1 - file2 - file3 - name: yum install httpd yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - apr - apr-util - httpd 123456789- hosts: websrvs remote_user: root tasks: - name: install some packages yum: name=&#123;&#123; item &#125;&#125; state=present with_items: - nginx - memcached - php-fpm 示例：迭代嵌套子变量 123456789101112131415- hosts：websrvs remote_user: root tasks: - name: add some groups group: name=&#123;&#123; item &#125;&#125; state=present with_items: - group1 - group2 - group3 - name: add some users user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; state=present with_items: - &#123; name: 'user1', group: 'group1' &#125; - &#123; name: 'user2', group: 'group2' &#125; - &#123; name: 'user3', group: 'group3' &#125; Playbook中template for if12345678910&#123;% for vhost in nginx_vhosts %&#125;server &#123;listen &#123;&#123; vhost.listen | default('80 default_server') &#125;&#125;;&#123;% if vhost.server_name is defined %&#125;server_name &#123;&#123; vhost.server_name &#125;&#125;;&#123;% endif %&#125;&#123;% if vhost.root is defined %&#125;root &#123;&#123; vhost.root &#125;&#125;;&#123;% endif %&#125;&#123;% endfor %&#125; roles&emsp;&emsp;ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。&emsp;&emsp;复杂场景：建议使用roles，代码复用度高 变更指定主机或主机组 如命名不规范维护和传承成本大 某些功能需多个Playbook，通过includes即可实现roles角色(roles)：角色集合roles/&emsp;mysql/&emsp;httpd/&emsp;nginx/&emsp;memcached/Ansible Roles目录编排roles目录结构&emsp;&emsp;每个角色，以特定的层级目录结构进行组织roles目录结构：playbook.yml&emsp;roles/&emsp;project/&emsp;tasks/&emsp;files/&emsp;vars/&emsp;templates/&emsp;handlers/&emsp;default/ 不常用&emsp;meta/ 不常用Roles各目录作用 /roles/project/ :项目名称,有以下子目录 files/ ：存放由copy或script模块等调用的文件 templates/：template模块查找所需要模板文件的目录 tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 handlers/：至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 vars/：定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含 default/：设定默认变量时使用此目录中的main.yml文件创建role创建role的步骤(1) 创建以roles命名的目录(2) 在roles目录中分别创建以各角色名称命名的目录，如webservers等(3) 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建(4) 在playbook文件中，调用各角色针对大型项目使用Roles进行编排roles目录结构：playbook.ymlroles/&emsp;project/&emsp;&emsp;tasks/&emsp;&emsp;files/&emsp;&emsp;vars/&emsp;&emsp;templates/&emsp;&emsp;handlers/&emsp;&emsp;default/ # 不经常用&emsp;&emsp;meta/ # 不经常用示例：nginx-role.ymlroles/└── nginx├── files│ └── main.yml├── tasks│ ├── groupadd.yml│ ├── install.yml│ ├── main.yml│ ├── restart.yml│ └── useradd.yml└── vars└── main.ymlplaybook调用角色调用角色方法1：123456- hosts: websrvs remote_user: root roles: - mysql - memcached - nginx 调用角色方法2：&emsp;&emsp;传递变量给角色 12345- hosts: remote_user: roles: - mysql - &#123; role: nginx, username: nginx &#125; &emsp;&emsp; 键role用于指定角色名称&emsp;&emsp; 后续的k/v用于传递变量给角色 调用角色方法3：&emsp;&emsp;还可基于条件测试实现角色调用 12roles: - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version == ‘7’ &#125; roles playbook tags使用 roles playbook tags使用ansible-playbook --tags=&quot;nginx,httpd,mysql&quot; nginx-role.yml 123456789// nginx-role.yml- hosts: testweb remote_user: root roles: - &#123; role: nginx ,tags: [ 'nginx', 'web' ] ,when: ansible_distribution_major_version == "6“ &#125; - &#123; role: httpd ,tags: [ 'httpd', 'web' ] &#125; - &#123; role: mysql ,tags: [ 'mysql', 'db' ] &#125; - &#123; role: marridb ,tags: [ 'mysql', 'db' ] &#125; - &#123; role: php &#125;]]></content>
      <categories>
        <category>linux进阶</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>总结</tag>
        <tag>Ansible</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myql数据库MHA实现高可用（多实例间实现）]]></title>
    <url>%2F%2Fblog%2F108203a7.html</url>
    <content type="text"><![CDATA[&emsp;&emsp; MHA(master high availability)目前是MySQL高可用方面是一个相对成熟的解决方案。在切换过程中，mha能做到0-30s内自动完成数据库的切换，并且在切换过程中最大的保持数据的一致性，以达到真正意义上的高可用&emsp;&emsp; MHA的组成： &emsp;&emsp; MHA Manager(管理节点)和MHA Node(数据节点)。MHA Manager可以独立部署在一台独立的机器上，管理多个集群，也可以部署在从从库上。 &emsp;&emsp; 当Master出现故障的时候，它可以自动将最新的数据的Slave提升为新的Master，然后将所有的Slave重新指向新的Master，整个故障转移过程是完全透明的。&emsp;&emsp; 实验演示图如下：&emsp;&emsp; 操作如下：&emsp;&emsp; 1、在192.168.32.71主机和192.168.32.72主机上搭建好1主3从的主从配置服务器；&emsp;&emsp; 2、在192.168.32.7主机作为监控主机，安装mhamanager包和node包，192.168.32.71主机、192.168.32.72主机只安装node包；&emsp;&emsp; 3、将三台主机的ssh公钥信息互相储存（或公用一个公钥私钥对），设置好相互之间的基于key验证免密登录。（因为用的是多实例数据库，SSH连通性验证时还会检查各个数据库之间的连通性，这就包括3307、3308、3309端口数据库之间的SSH连接，所以一定要在192.168.32.72主机家目录的.ssh/authorized_keys文件中加入192.168.32.72本机的公钥，否则会报错，切记，已踩坑）&emsp;&emsp; 4、编写mha配置文件，路径随意。vim /etc/mha.cnf 1234567891011121314151617181920212223[server default]user=mhauserpassword=mhusermanager_workdir=/data/mastermha/group1/manager_log=/data/mastermha/group1/manager.logremote_workdir=/data/mastermha/group1/ssh_user=rootrepl_user=repluserrepl_password=repluserping_interval=1master_binlog_dir=/data/mysql[server1]hostname=192.168.32.71[server2]hostname=192.168.32.72port=3307candidate_master=1[server3]hostname=192.168.32.72port=3308[server4]hostname=192.168.32.72port=3309 &emsp;&emsp; 5、在主数据库服务器也就是192.168.32.71主机上创建监控账号（user=mhauser password=mhauser）和复制帐号（repl_user=repluser repl_password=repluser）（要和配置文件相同,已有则无需创建，可以用现成的，权限符合即可） 12GRANT ALL ON *.* TO mhauser@'192.168.32.7%' IDENTIFIED BY 'mhauser';GRANT REPLICATION SLAVE ON *.* TO 'repluser'@'192.168.32.7%' IDENTIFIED BY 'repluser' &emsp;&emsp; 6、用MHA包自带工具进行测试usr/bin/masterha_check_ssh --conf=/etc/mha.cnf 12345678910111213141516171819[root@CentOS7 ~]#/usr/bin/masterha_check_ssh --conf=/etc/mha.cnfFri Sep 27 11:17:25 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Sep 27 11:17:25 2019 - [info] Reading application default configuration from /etc/mha.cnf..Fri Sep 27 11:17:25 2019 - [info] Reading server configuration from /etc/mha.cnf..Fri Sep 27 11:17:25 2019 - [info] Starting SSH connection tests..Fri Sep 27 11:17:28 2019 - [debug] Fri Sep 27 11:17:25 2019 - [debug] Connecting via SSH from root@192.168.32.71(192.168.32.71:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:25 2019 - [debug] ok.Fri Sep 27 11:17:25 2019 - [debug] Connecting via SSH from root@192.168.32.71(192.168.32.71:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:26 2019 - [debug] ok.Fri Sep 27 11:17:26 2019 - [debug] Connecting via SSH from root@192.168.32.71(192.168.32.71:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:27 2019 - [debug] ok.Fri Sep 27 11:17:28 2019 - [debug] Fri Sep 27 11:17:26 2019 - [debug] Connecting via SSH from root@192.168.32.72(192.168.32.72:22) to root@192.168.32.71(192.168.32.71:22)..Fri Sep 27 11:17:27 2019 - [debug] ok.Fri Sep 27 11:17:27 2019 - [debug] Connecting via SSH from root@192.168.32.72(192.168.32.72:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:28 2019 - [debug] ok.Fri Sep 27 11:17:28 2019 - [debug] Connecting via SSH from root@192.168.32.72(192.168.32.72:22) to root@192.168.32.72(192.168.32.72:22)..Fri Sep 27 11:17:29 2019 - [info] All SSH connection tests passed successfully. usr/bin/masterha_check_repl --conf=/etc/mha.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687[root@CentOS7 ~]#/usr/bin/masterha_check_repl --conf=/etc/mha.cnfFri Sep 27 11:18:12 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Sep 27 11:18:12 2019 - [info] Reading application default configuration from /etc/mha.cnf..Fri Sep 27 11:18:12 2019 - [info] Reading server configuration from /etc/mha.cnf..Fri Sep 27 11:18:12 2019 - [info] MHA::MasterMonitor version 0.56.Fri Sep 27 11:18:13 2019 - [info] GTID failover mode = 0Fri Sep 27 11:18:13 2019 - [info] Dead Servers:Fri Sep 27 11:18:13 2019 - [info] Alive Servers:Fri Sep 27 11:18:13 2019 - [info] 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3307)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3308)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3309)Fri Sep 27 11:18:13 2019 - [info] Alive Slaves:Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3307) Version=10.4.8-MariaDB-log (oldest major version between slaves) log-bin:enabledFri Sep 27 11:18:13 2019 - [info] Replicating from 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] Primary candidate for the new Master (candidate_master is set)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3308) Version=10.4.8-MariaDB-log (oldest major version between slaves) log-bin:enabledFri Sep 27 11:18:13 2019 - [info] Replicating from 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] 192.168.32.72(192.168.32.72:3309) Version=10.4.8-MariaDB-log (oldest major version between slaves) log-bin:enabledFri Sep 27 11:18:13 2019 - [info] Replicating from 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] Current Alive Master: 192.168.32.71(192.168.32.71:3306)Fri Sep 27 11:18:13 2019 - [info] Checking slave configurations..Fri Sep 27 11:18:13 2019 - [info] Checking replication filtering settings..Fri Sep 27 11:18:13 2019 - [info] binlog_do_db= , binlog_ignore_db= Fri Sep 27 11:18:13 2019 - [info] Replication filtering check ok.Fri Sep 27 11:18:13 2019 - [info] GTID (with auto-pos) is not supportedFri Sep 27 11:18:13 2019 - [info] Starting SSH connection tests..Fri Sep 27 11:18:17 2019 - [info] All SSH connection tests passed successfully.Fri Sep 27 11:18:17 2019 - [info] Checking MHA Node version..Fri Sep 27 11:18:18 2019 - [info] Version check ok.Fri Sep 27 11:18:18 2019 - [info] Checking SSH publickey authentication settings on the current master..Fri Sep 27 11:18:18 2019 - [info] HealthCheck: SSH to 192.168.32.71 is reachable.Fri Sep 27 11:18:18 2019 - [info] Master MHA Node version is 0.56.Fri Sep 27 11:18:18 2019 - [info] Checking recovery script configurations on 192.168.32.71(192.168.32.71:3306)..Fri Sep 27 11:18:18 2019 - [info] Executing command: save_binary_logs --command=test --start_pos=4 --binlog_dir=/data/mysql --output_file=/data/mastermha/group1//save_binary_logs_test --manager_version=0.56 --start_file=master-bin.000012 Fri Sep 27 11:18:18 2019 - [info] Connecting to root@192.168.32.71(192.168.32.71:22).. Creating /data/mastermha/group1 if not exists.. ok. Checking output directory is accessible or not.. ok. Binlog found at /data/mysql, up to master-bin.000012Fri Sep 27 11:18:19 2019 - [info] Binlog setting check done.Fri Sep 27 11:18:19 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..Fri Sep 27 11:18:19 2019 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user='mhauser' --slave_host=192.168.32.72 --slave_ip=192.168.32.72 --slave_port=3307 --workdir=/data/mastermha/group1/ --target_version=10.4.8-MariaDB-log --manager_version=0.56 --relay_log_info=/data/mysql3307/data/relay-log.info --relay_dir=/data/mysql3307/data/ --slave_pass=xxxFri Sep 27 11:18:19 2019 - [info] Connecting to root@192.168.32.72(192.168.32.72:22).. Checking slave recovery environment settings.. Opening /data/mysql3307/data/relay-log.info ... ok. Relay log found at /data/mysql3307/data, up to relay-log.000034 Temporary relay log file is /data/mysql3307/data/relay-log.000034 Testing mysql connection and privileges.. done. Testing mysqlbinlog output.. done. Cleaning up test file(s).. done.Fri Sep 27 11:18:19 2019 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user='mhauser' --slave_host=192.168.32.72 --slave_ip=192.168.32.72 --slave_port=3308 --workdir=/data/mastermha/group1/ --target_version=10.4.8-MariaDB-log --manager_version=0.56 --relay_log_info=/data/mysql3308/data/relay-log.info --relay_dir=/data/mysql3308/data/ --slave_pass=xxxFri Sep 27 11:18:19 2019 - [info] Connecting to root@192.168.32.72(192.168.32.72:22).. Checking slave recovery environment settings.. Opening /data/mysql3308/data/relay-log.info ... ok. Relay log found at /data/mysql3308/data, up to relay-log.000009 Temporary relay log file is /data/mysql3308/data/relay-log.000009 Testing mysql connection and privileges.. done. Testing mysqlbinlog output.. done. Cleaning up test file(s).. done.Fri Sep 27 11:18:20 2019 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user='mhauser' --slave_host=192.168.32.72 --slave_ip=192.168.32.72 --slave_port=3309 --workdir=/data/mastermha/group1/ --target_version=10.4.8-MariaDB-log --manager_version=0.56 --relay_log_info=/data/mysql3309/data/relay-log.info --relay_dir=/data/mysql3309/data/ --slave_pass=xxxFri Sep 27 11:18:20 2019 - [info] Connecting to root@192.168.32.72(192.168.32.72:22).. Checking slave recovery environment settings.. Opening /data/mysql3309/data/relay-log.info ... ok. Relay log found at /data/mysql3309/data, up to relay-log.000009 Temporary relay log file is /data/mysql3309/data/relay-log.000009 Testing mysql connection and privileges.. done. Testing mysqlbinlog output.. done. Cleaning up test file(s).. done.Fri Sep 27 11:18:20 2019 - [info] Slaves settings check done.Fri Sep 27 11:18:20 2019 - [info] 192.168.32.71(192.168.32.71:3306) (current master) +--192.168.32.72(192.168.32.72:3307) +--192.168.32.72(192.168.32.72:3308) +--192.168.32.72(192.168.32.72:3309)Fri Sep 27 11:18:20 2019 - [info] Checking replication health on 192.168.32.72..Fri Sep 27 11:18:20 2019 - [info] ok.Fri Sep 27 11:18:20 2019 - [info] Checking replication health on 192.168.32.72..Fri Sep 27 11:18:20 2019 - [info] ok.Fri Sep 27 11:18:20 2019 - [info] Checking replication health on 192.168.32.72..Fri Sep 27 11:18:20 2019 - [info] ok.Fri Sep 27 11:18:20 2019 - [warning] master_ip_failover_script is not defined.Fri Sep 27 11:18:20 2019 - [warning] shutdown_script is not defined.Fri Sep 27 11:18:20 2019 - [info] Got exit code 0 (Not master dead).MySQL Replication Health is OK. &emsp;&emsp; 均显示测试成功~&emsp;&emsp; 可以启动MHAmanager了，注意这是一个前端程序，如果检测到主数据库宕机，则会自动切换从数据为新的主服务器并使其他的从服务器从新的主服务器数据库上面复制数据，此后程序自动终止。 1234[root@CentOS7 ~]#/usr/bin/masterha_manager --conf=/etc/mha.cnfFri Sep 27 11:35:37 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.Fri Sep 27 11:35:37 2019 - [info] Reading application default configuration from /etc/mha.cnf..Fri Sep 27 11:35:37 2019 - [info] Reading server configuration from /etc/mha.cnf.. &emsp;&emsp; 在主数据库上将mysql进程杀掉后，MHA进程自动结束。&emsp;&emsp; 在3307端口数据库上查询，已经没有从节点信息了。&emsp;&emsp; 在3308端口数据库以及3309端口数据上显示，主数据库已变为更为3307端口数据库，说明转换主从结构成功！&emsp;&emsp; PS：因为几个数据库都是源码编译安装，数据库路径和二进制文件储存位置都做出了调整，与默认位置不同，而yum安装的MHAmaster中如果配置文件中不写明master_binlog_dir的位置，则会默认去/usr/bin/msyql/目录下找主机二进制文件（当然，mysql数据库也是yum安装的可忽略这些配置，一切默认就好，而配置文件中添加server主机时，如果端口号不是默认3306，一定要记得写明port端口号，如本文中多实例用的不同端口，标记清楚即可。）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>多实例</tag>
        <tag>mysql</tag>
        <tag>MHA</tag>
        <tag>高可用</tag>
        <tag>mariadb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql多实例实现主从级联复制及读写分离]]></title>
    <url>%2F%2Fblog%2Fd006fe9f.html</url>
    <content type="text"><![CDATA[一、多实例1、概述&emsp;&emsp; MySQL多实例就是在一台机器上开启多个不同的服务端口（如：3306,3307），运行多个MySQL服务进程，通过不同的socket监听不同的服务端口来提供各自的服务2.1、优点1）有效利用服务器资源&emsp;&emsp; 当单个服务器资源过剩时，可以充分利用剩余的资源来提供更多的服务；2）节约服务器资源 &emsp;&emsp; 当公司资金紧张，但数据库又需要数据库之间各自提供服务时，并且还想使用主从同步等技术，此时多实例就再好不过了；3）方便后期架构扩展 &emsp;&emsp; 当公司的某个项目才启动时，启动初期并不一定有很大的用户量，因此可以先用一组物理数据库服务器，在上面部署多个实例，方便后续架构扩展、迁移； 2.2、缺点 资源互相抢占问题 &emsp;&emsp; 当某个服务实例并发很高或者有慢查询时，整个实例会消耗更多的内存、CPU和IO资源，这将导致服务器上的其它实例提供服务的质量下降。这就比如说合租房的各个租客，每当早晨上班时，都会洗漱，此时卫生间的占用率就大，各个租客总会发生等待。 3、部署mysql多实例的两种方式 ① 基于多配置文件 &emsp;&emsp; 通过使用多个配置文件来启动不同的进程，以此来实现多实例。 &emsp;&emsp; 优点：逻辑简单，配置简单 &emsp;&emsp; 缺点：管理起来不方便 ② 基于mysqld_multi &emsp;&emsp; 通过官方自带的 mysqld_multi 工具，使用单独配置文件来实现多实例 &emsp;&emsp; 优点： 便于集中管理管理 &emsp;&emsp; 缺点： 不方便针对每个实例配置进行定制 4、同一开发环境下安装两个数据库，必须处理以下问题 &emsp;&emsp; （1） 配置文件安装路径不能相同 &emsp;&emsp; （2）数据库目录不能相同 &emsp;&emsp; （3）启动脚本不能同名 &emsp;&emsp; （4）端口不能相同 &emsp;&emsp; （5）socket文件的生成路径不能相同5、配置搭建&emsp;&emsp; 实现目标：&emsp;&emsp; 1、源码编译安装或者二进制安装或者yum安装mysql或mariadb客户端以及server端,若没有创建mysql用户、组则创建。&emsp;&emsp; 2、在指定路径下创建3个数据库目录&emsp;&emsp;mkdir -p /data/mysql330{789}&emsp;&emsp;挂载在不同的三块硬盘上 123mount /dev/sdb /data/mysql3307mount /dev/sdc /data/mysql3308mount /dev/sdd /data/mysql3309 &emsp;&emsp; 3、用server端带的初始化脚本生成三个数据库 123scripts/mariadb-install-db --datadir=/data/mysql3307/ --user=mysqlscripts/mariadb-install-db --datadir=/data/mysql3308/ --user=mysqlscripts/mariadb-install-db --datadir=/data/mysql3309/ --user=mysql &emsp;&emsp; 4、准备三个配置文件 123cp /etc/my.cnf /data/mysql3307/my.cnfcp /etc/my.cnf /data/mysql3308/my.cnfcp /etc/my.cnf /data/mysql3309/my.cnf &emsp;&emsp; 修改分别其中配置（以下以实例3307为例，3308、3309将下面所有数字对应改成自己的端口号） 12345678910111213141516171819[client]#password = your_passwordport = 3307socket = /data/mysql3307/mysql.sock[mysqld]datadir=/data/mysql3307/innodb_file_per-table=onskip_name_resolve=onport = 3307socket = /data/mysql3307/mysql.socklog-bin=mysql-binlog-slave-updatesserver-id = 3307 #每个数据库server-id全局唯一default-character-set=utf8read_only=ON #3307特有选项-开启中继日志relay_log=relay-log #3307特有选项relay_log_index=relay-log.index #3307特有选项 &emsp;&emsp; 5、编写服务启动脚本（并加执行权限和修改PATH路径） &emsp;&emsp;vim mysqld 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/bin/bashport=$1mysql_user="root"mysql_pwd="password"cmd_path="/usr/local/mysql/bin"mysql_basedir="/data/mysql"mysql_sock="$&#123;mysql_basedir&#125;$&#123;port&#125;/mysql.sock"function_start_mysql()&#123; if [ ! -e "$mysql_sock" ];then printf "Starting MySQL...\n" $&#123;cmd_path&#125;/mysqld_safe --defaults-file=$&#123;mysql_basedir&#125;$&#123;port&#125;/my.cnf &amp;&gt; /dev/null &amp; else printf "MySQL is running...\n" exit fi&#125;function_stop_mysql()&#123; if [ ! -e "$mysql_sock" ];then printf "MySQL is stopped...\n" exit else printf "Stoping MySQL...\n" $&#123;cmd_path&#125;/mysqladmin -u $&#123;mysql_user&#125; -p$&#123;mysql_pwd&#125; -S $&#123;mysql_sock&#125; shutdown fi&#125;function_restart_mysql()&#123; printf "Restarting MySQL...\n" function_stop_mysql sleep 1 function_start_mysql&#125;if [ ! -n "$2" ];then printf "Usage: $&#123;mysql_basedir&#125;$&#123;port&#125;/bin/mysqld [PORT] &#123;start|stop|restart&#125;\n"else case $2 in start) function_start_mysql ;; stop) function_stop_mysql ;; restart) function_restart_mysql ;; *) printf "Usage: $&#123;mysql_basedir&#125;$&#123;port&#125;/bin/mysqld &#123;start|stop|restart&#125;\n" esacfi &emsp;&emsp; 6、现在就可以实现执行mysqld 3307 start启动数据库服务了。启动三台数据库后（可运行安全加固脚本去掉test数据库以及多余账户），在主机数据库及这3个数据库中分别增加主从配置。&emsp;&emsp; 192.168.32.71主机数据库: 12MariaDB [(none)]&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repluser&apos;@&apos;192.168.32.72&apos; IDENTIFIED BY &apos;replpasswd&apos;;MariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; show master status;+———————-+—————–+——————-+————————-+|&emsp;&emsp; &emsp;File&emsp;&emsp;&emsp;&emsp; | &emsp;Position &emsp;| Binlog_Do_DB | Binlog_Ignore_DB |+———————-+—————–+——————-+————————-+| mysql-bin.000026 | &emsp; 1136 &emsp;&emsp;|&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+———————-+—————–+——————-+————————-+ &emsp;&emsp; 查看并记录主机当前二进制日志文件信息及位置。&emsp;&emsp; 用mysqldump (或者物理备份)，并还原至3个从节点。&emsp;&emsp; 192.168.32.71主机: 12mysqldump -uroot -ppassword -A --default-character-set=utf8 --master-data=1 --hex-blob &gt;/data/fullbak_`date +%F`.sqlscp /data/fullbak_`date +%F`.sql 192.168.32.72:/data/ &emsp;&emsp; 192.168.32.72主机: &emsp;&emsp; 启动3个实例的服务 &emsp;&emsp;mysqld 3307 start；mysqld 3308 start；mysqld 3309 start &emsp;&emsp; 连接3307实例 &emsp;&emsp;mysql -S /data/mysql3307/mysql.sock 12MariaDB [(none)]&gt; source /data/fullbak_XXX.sqlMariaDB [(none)]&gt; SHOW MASTER STATUS; MariaDB [(none)]&gt; show master status;+———————–+—————-+——————-+————————-+|&emsp;&emsp; &emsp;File&emsp;&emsp;&emsp;&emsp; | &emsp;Position &emsp;| Binlog_Do_DB | Binlog_Ignore_DB |+———————–+—————-+——————-+————————-+| mysql-bin.000006 | &emsp; 1167 &emsp;&emsp;|&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+———————–+—————-+——————-+————————-+ &emsp;&emsp; 记录3307实例的当前二进制日志文件信息及位置。 &emsp;&emsp; 在从节点3307添加主节点配置信息。 123456MariaDB [(none)]&gt; change master to master_host='192.168.32.71',master_user='repluser',master_password='replpasswd',master_port=3306,master_log_file='mysql-bin.000026',master_log_pos=1136;MariaDB [(none)]&gt;start slave; &emsp;&emsp; 连接3308实例mysql -S /data/mysql3308/mysql.sock&emsp;&emsp; 在从节点3308添加主节点配置信息。 1234567MariaDB [(none)]&gt; source /data/fullbak_XXX.sqlMariaDB [(none)]&gt; change master to master_host='192.168.32.72,master_user='repluser',master_password='replpasswd',master_port=3307,master_log_file='mysql-bin.000006',master_log_pos=1167;MariaDB [(none)]&gt;start slave; &emsp;&emsp; 连接3309实例mysql -S /data/mysql3309/mysql.sock&emsp;&emsp; 在从节点3309添加主节点配置信息。 1234567MariaDB [(none)]&gt; source /data/fullbak_XXX.sqlMariaDB [(none)]&gt; change master to master_host='192.168.32.72,master_user='repluser',master_password='replpasswd',master_port=3307,master_log_file='mysql-bin.000006',master_log_pos=1167;MariaDB [(none)]&gt;start slave; &emsp;&emsp; 三个从节点数据库依次&emsp;&emsp;show slave status\G查看主从状态信息，确认主从配置无误且均已启动，至此，多实例主从级联配置就完成了。&emsp;&emsp;二、读写分离1、什么是读写分离？ &emsp;&emsp; 读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。 2、为什么要实现读写分离？ &emsp;&emsp; 因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。&emsp;&emsp; 但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。所以读写分离，解决的是，数据库的写入，影响了查询的效率。 3、什么时候要读写分离？ &emsp;&emsp; 数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。 4、部署读写分离&emsp;&emsp; 本次使用proxy实现读写分离，最终实现下图所示&emsp;&emsp; 1、部署代理机ip：192.168.32.70&emsp;&emsp; 安装proxy及mysql客户端 123456789cat /etc/yum.repos.d/proxysql.repo &lt;&lt;EOF [proxysql_repo]name= ProxySQL YUM repositorybaseurl=http://repo.proxysql.com/ProxySQL/proxysql-1.4.x/centos/\$releasevergpgcheck=1gpgkey=http://repo.proxysql.com/ProxySQL/repo_pub_keyEOFyum install proxysql -yyum install mysql -y &emsp;&emsp; 修改代理机配置文件端口号 6033 改为 3306（方便客户机连接,其他保持默认） &emsp;&emsp;sed -ri ‘s@(interfaces=”0.0.0.0:)6033@\13306@’ /etc/proxysql.cnf &emsp;&emsp; 登陆proxysql数据库 &emsp;&emsp;mysql -uadmin -padmin -P6032 -h127.0.0.1 &emsp;&emsp; 在代理服务器上增加主机信息 &emsp;&emsp; MySQL [(none)]&gt; 1234insert into mysql_servers(hostgroup_id,hostname,port) values(10,&apos;192.168.32.71&apos;,3306),(10,&apos;192.168.32.72&apos;,3307),(10,&apos;192.168.32.72&apos;,3308),(10,&apos;192.168.32.72&apos;,3309); &emsp;&emsp; 加载:MySQL [(none)]&gt; load mysql servers to runtime&emsp;&emsp; 保存:MySQL [(none)]&gt; save mysql servers to disk &emsp;&emsp; #设置监控帐号（使用默认监控账号(账号:密码=monitor:monitor)的话，此步可跳过）&emsp;&emsp; MySQL [(none)]&gt; 1234set mysql-monitor_username=&apos;username&apos;set mysql-monitor_password=&apos;password&apos;MySQL [(none)]&gt; load mysql variables to runtime;MySQL [(none)]&gt; save mysql variables to disk; &emsp;&emsp; 2、在主服务器上增加创建proxy的监控帐号并授权(从节点会自动复制创建，无需再创) &emsp;&emsp; MySQL [(none)]&gt; grant replication client on . to monitor@’192.168.32.71’identified by ‘monitor’; &emsp;&emsp; 3、在代理机上查看监控连接是否正常的 (对connect指标的监控)：&emsp;&emsp; 如果connect_error的结果为NULL则表示正常&emsp;&emsp; MySQL&gt;select * from mysql_server_connect_log;&emsp;&emsp; 查看监控心跳信息 (对ping指标的监控)：&emsp;&emsp; MySQL&gt; select * from mysql_server_ping_log;&emsp;&emsp; (如果显示连接失败，可尝试在从节点刷新权限flush privileges;)&emsp;&emsp; 4、设置分组信息&emsp;&emsp; 需要修改的是main库中的mysql_replication_hostgroups表，该表有3个字段：writer_hostgroup，reader_hostgroup，comment, 指定写组的id为10，读组的id为20&emsp;&emsp; MySQL&gt;insert into mysql_replication_hostgroups values(10,20,”CentOS7”);&emsp;&emsp; 将mysql_replication_hostgroups表的修改加载到RUNTIME生效&emsp;&emsp; MySQL&gt; load mysql servers to runtime;&emsp;&emsp; MySQL&gt; save mysql servers to disk;&emsp;&emsp; Monitor模块监控后端的read_only值，按照read_only的值将节点自动移动到读/写组&emsp;&emsp;查看添加的主机分组表，应该已经自动分组了：&emsp;&emsp; MySQL&gt;select hostgroup_id,hostname,port,status,weight from mysql_servers;&emsp;&emsp; 5、在proxysql上配置路由规则，实现读写分离&emsp;&emsp; 与规则有关的表：mysql_query_rules和mysql_query_rules_fast_routing，后者是前者的扩展表，1.4.7之后支持&emsp;&emsp; 插入路由规则：将select语句分离到20的读组，select语句中有一个特殊语句&emsp;&emsp; SELECT…FOR UPDATE它会申请写锁，应路由到10的写组&emsp;&emsp; MySQL&gt;insert into mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply) VALUES(1,1,’^SELECT.FOR UPDATE$’,10,1),(2,1,’^SELECT’,20,1);&emsp;&emsp; MySQL&gt; load mysql query rules to runtime;&emsp;&emsp; MySQL&gt; save mysql query rules to disk;*注意：因ProxySQL根据rule_id顺序进行规则匹配，select … for update规则的rule_id必须要小于普通的select规则的rule_id** &emsp;&emsp;在代理机上用命令测试相应读写的是哪个数据库：&emsp;&emsp;mysql -uroot -pPASSWORD -P3306 -h127.0.0.1 -e ‘start transaction;select @@server_id;commit;select @@server_id’+———————+| @@server_id&emsp; |+———————+| &emsp; &emsp; 3306&emsp; &emsp; |+———————++———————+| @@server_id&emsp; |+———————+| &emsp; &emsp; 3307 &emsp; &emsp; |+———————+&emsp;&emsp;说明读写分离，在两个终端上成功实现~]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>多实例</tag>
        <tag>mysql</tag>
        <tag>级联复制</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于mariadb10.4.8二进制安装及源码编译后设置密码无效的一些发现]]></title>
    <url>%2F%2Fblog%2F4f0efae7.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前安装了最新版的mariadb10.4.8后，无论是二进制编译安装还是源码编译安装，设定完密码之后启动mysqld服务，结果都不需要密码就可以登陆进去，无论怎么执行mysql_secure_installation数据库初始化脚本或者mysql_secure_installation安全加固脚本，进入mysql都无需密码，用命令直接设置密码也无效，都是直接一敲mysql就可以进入数据库了。my.cnf配置文件查看了无数遍，也没发现任何蛛丝马迹。今天终于在无意中查看mysql数据库权限时意外有所收获，写出来与大家分享，让大家少走弯路。 &emsp;&emsp;当我进入mysql数据库，打开user表时，查看了下用户没有任何问题。MariaDB [mysql]&gt; select user,host,password from user;+———-+————+———————————————————–+| user &emsp;&emsp;| host &emsp;&emsp; | &emsp; password &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+———-+————+———————————————————–+| &emsp;root&emsp; | localhost | 54D9A58CB44735F80AC5AD29961814D6D12B8746 || &emsp;root &emsp;| 127.0.0.1 | 54D9A58CB44735F80AC5AD29961814D6D12B8746 || &emsp;root&emsp; | ::1 &emsp;&emsp;&emsp; | *54D9A58CB44735F80AC5AD29961814D6D12B8746 |+———-+————+———————————————————–+3 rows in set (0.001 sec)|user | host |password ||–|–|–||root | localhost | *54D9A58CB44735F80AC5AD29961814D6D12B8746 ||root | 127.0.0.1 | *54D9A58CB44735F80AC5AD29961814D6D12B8746 ||root |::1| *54D9A58CB44735F80AC5AD29961814D6D12B8746 |&emsp;&emsp;可当我突发奇想打算看看他们这几个用户有什么权限上的区别时，就发现问题了：*MariaDB [mysql]&gt; show grants for ‘root’@’localhost’;**+—————————————————————————————————————+| &emsp;Grants for root@localhost&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; |+—————————————————————————————————————+| GRANT ALL PRIVILEGES ON *. TO ‘root’@’localhost’ IDENTIFIED VIA mysql_native_password USING ‘invalid’ OR unix_socket WITH GRANT OPTION &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|| GRANT PROXY ON ‘’@’%’ TO ‘root’@’localhost’ WITH GRANT OPTION &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|+—————————————————————————————————————+2 rows in set (0.000 sec)MariaDB [mysql]&gt; show grants for ‘root’@’127.0.0.1’;ERROR 1141 (42000): There is no such grant defined for user ‘root’ on host ‘127.0.0.1’MariaDB [mysql]&gt; show grants for ‘root’@’::1’;ERROR 1141 (42000): There is no such grant defined for user ‘root’ on host ‘::1’MariaDB [mysql]&gt;&emsp;&emsp;root用户竟然查不到权限，这就很奇怪了。在之前的mariadb10.2.27上尝试了下，都是正常的，如下图所示：&emsp;&emsp;于是我就尝试对那两个异常的用户账号授权。&emsp;&emsp;竟然也无法授权。这种情况跟我之前尝试过的直接用insert命令向user表中加的user条目情况有点相似。当时我用 1insert user set Host='192.168.32.7',User='root',Password='54D9A58CB44735F80AC5AD29961814D6D12B8746',ssl_cipher='',x509_subject='',x509_issuer='',authentication_string=''; 命令在user表中创建了一个用户条目‘root’@’192.168.32.7’。&emsp;&emsp;这个条目看起来和真正的用户一样，可等到授权时就发现没法授权了，且这个用户也没法远程在192.168.32.7主机登录，尝试insert了一个新的非root用户，也是同样的情况。说明create user 命令不单单只是在这个表上创建了新的用户条目，在其他关联的表上也有条目的增加。OK ，话题扯远了，继续说之前的无法加密的问题。&emsp;&emsp;既然是同样的情况，我想到会不会是说明我这个新装好的mariadb上的这两个用户没有创建成功，是不是像上面提到的两个异常用户只是在这表中“徒有其表”呢？&emsp;&emsp;那就尝试创建用户，并查看了下权限。&emsp;&emsp;竟然创建用户成功了，而且权限也显示出来了（我记得我还没有授权呢啊！！！看来是root用户不用授权）。好像一切都恢复正常了。&emsp;&emsp;赶紧退出看下是不是真的恢复正常了，结果失望的发现还是一敲mysql就可以登陆进去了！！！&emsp;&emsp;不过又尝试了下 用127.0.0.1登陆，发现竟然需要密码验证了，且用之前设置的密码才可以登录。我好像发现了什么~&emsp;&emsp;删除用户‘root’@’localhost’，不让删，需要至少一个有CREATE USER权限用户，看来之前的‘root’@’127.0.0.1’用户没有权限。&emsp;&emsp;那就先给‘root’@’127.0.0.1’用户授权 12grant all on *.* to 'root'@'127.0.0.1'; &emsp;&emsp;再删除用户‘root’@’localhost’，成功了，再重新创建‘root’@’localhost’用户并指定密码，再授权。OK，退出重新登陆一下。&emsp;&emsp;果然数据库加密成功了！问题解决！**——————————————-（以上封存，警醒自己的无知）——————————————–**&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后记：&emsp;&emsp;原来是mariadb10.4.8版本默认是可以本地使用使用unix_socket登陆无需密码，才导致密码无效，在上面的图片里显示得清清楚楚。MariaDB [mysql]&gt; show grants for ‘root’@’localhost’; 1234567891011+---------------------------------------------------------------------------------------------------------------+| &amp;emsp;Grants for root@localhost&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; |+---------------------------------------------------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING 'invalid' **OR unix_socket** WITH GRANT OPTION &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;|| GRANT PROXY ON ''@'%' TO 'root'@'localhost' WITH GRANT OPTION &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;|+---------------------------------------------------------------------------------------------------------------+2 rows in set (0.000 sec)**MariaDB [mysql]&gt; show grants for 'root'@'127.0.0.1';**ERROR 1141 (42000): There is no such grant defined for user 'root' on host '127.0.0.1'**MariaDB [mysql]&gt; show grants for 'root'@'::1';**ERROR 1141 (42000): There is no such grant defined for user 'root' on host '::1' MariaDB [mysql]&gt;&emsp;&emsp;当然，也存在用户不存在，而user表中有条目的情况。所以想最终解决这个问题，实际上最直接的命令是： 1GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING '*54D9A58CB44735F80AC5AD29961814D6D12B8746' WITH GRANT OPTION; &emsp;&emsp;重新对root@localhost用户授权取消unix_sock登陆，并设置密码。&emsp;&emsp;至此，问题才真正解决。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后记写于 2019.9.23。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>mysql</tag>
        <tag>mariadb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制安装及源码编译安装mariadb数据库]]></title>
    <url>%2F%2Fblog%2Fb124800c.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 &emsp;&emsp;MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，它使用了Percona的 XtraDB，InnoDB的变体，分支的开发者希望提供访问即将到来的MySQL 5.4 InnoDB性能。这个版本还包括了 PrimeBase XT (PBXT) 和 FederatedX存储引擎。&emsp;&emsp;开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 过去一年中，大型互联网用户以及Linux发行商纷纷抛弃MySQL，转投MariaDB阵营。MariaDB是目前最受关注的MySQL数据库衍生版，也被视为开源数据库MySQL的替代品。&emsp;&emsp;MariaDB虽然被视为MySQL数据库的替代品，但它在扩展功能、存储引擎以及一些新的功能改进方面都强过MySQL。而且从MySQL迁移到MariaDB也是非常简单的：&emsp;&emsp;1、数据和表定义文件（.frm）是二进制兼容的&emsp;&emsp;2、所有客户端API、协议和结构都是完全一致的&emsp;&emsp;3、所有文件名、二进制、路径、端口等都是一致的&emsp;&emsp;4、所有的MySQL连接器，比如PHP、Perl、Python、Java、.NET、MyODBC、Ruby以及MySQL C connector等在MariaDB中都保持不变&emsp;&emsp;5、mysql-client包在MariaDB服务器中也能够正常运行&emsp;&emsp;6、共享的客户端库与MySQL也是二进制兼容的也就是说，在大多数情况下，你完全可以卸载MySQL然后安装MariaDB，然后就可以像之前一样正常的运行。(以上摘自百度百科)&emsp;&emsp;作为目前比较热门的开源数据库软件，一般常见有三种安装方式：yum或rpm包安装、二进制安装以及源码包安装，包安装过于简单，也很难符合一般企业定制需要，故不做叙述，本文详细讲述后两种安装方式。 二进制安装1.先创建mysql用户及mysql组，并制定家目录为/data/mysql 12groupadd -r -g 306 mysql #指定属组gid为306useradd -r -g 306 -u 306 -d /data/mysql mysql #指定属主uid为306，家目录为/data/mysql 2.准备数据目录(mysq用户家目录),并修正权限 1mkdir /data/mysql;chown mysql:mysql /data/mysql 3.去官网下载mariadb 二进制tar包（链接是CentOS7X86_64的10.4.8稳定版）&emsp;&emsp;http://ftp.igh.cnrs.fr/pub/mariadb//mariadb-10.4.8/bintar-linux-systemd-x86_64/mariadb-10.4.8-linux-systemd-x86_64.tar.gz4.解压tar包指/usr/local目录下,递归改属主为root、属组为mysql，并在/usr/local目录下创建一个名为mysql的软链接指向解压好的mariadb目录 1234tar xzf mariadb-10.4.8-linux-systemd-x86_64.tar.gz -c /usr/localcd /usr/localln -sv mariadb-10.4.8-linux-systemd-x86_64 mysql`chown -R root:mysql /usr/local/mysql/ 5.创建配置文件,并修改 1234mkdir /etc/mysql/cp /etc/my.cnf /etc/mysql/my.cnfsed -ri '/datadir=\//s@(.*=).*@\1\/data\/mysql@' /etc/mysql/my.cnf #修改配置文件，指定数据库储存路径sed -ri '/datadir/a\innodb_file_per-table=on\nskip_name_resolve=on' /etc/mysql/my.cnf #设置每个表独立文件 和 禁用主机名解析 6.创建数据库文件 1/usr/local/scripts/mysql_install_db --datadir=/data/mysql --user=mysql 7.创建服务脚本并启动服务 123cp /usr/local/support-files/mysql.server /etc/rc.d/init.d/mysqldchkconfig --add mysqldservice mysqld start 8.增加PATH环境变量路径,并生效。 12echo 'PATH=/usr/local/mysql/bin:$PATH' &gt;/etc/profile.d/mysql.sh. /etc/profile.d/mysql.sh 9.运行安全初始化脚本，设置root口令、禁用匿名登陆、禁用远程主机登陆、删除test数据库，并立即生效(根据提示操作)。 12ln -s /var/lib/mysql/mysql.sock /tmp/usr/local/mysql/bin/mysql_secure_installation &emsp;&emsp;至此，二进制安装mariadb数据库就完成了~ 源码编译安装1.先创建mysql用户及mysql组，并制定家目录为/data/mysql 12groupadd -r -g 306 mysql #指定属组gid为306useradd -r -g 306 -u 306 -d /data/mysql mysql #指定属主uid为306，家目录为/data/mysql 2.准备数据目录(mysq用户家目录),并修正权限 1mkdir /data/mysql;chown mysql:mysql /data/mysql 3.去官网下载mariadb 源码tar包（链接是CentOS7X86_64的10.4.8稳定版）&emsp;&emsp;http://ftp.igh.cnrs.fr/pub/mariadb//mariadb-10.4.8/source/mariadb-10.4.8.tar.gz4.解压源码包，并进入源码包目录 12tar xvf mariadb-10.4.8.tar.gzcd mariadb-10.4.8/l 5.CMAKE编译源码包&emsp;&emsp;需要的依赖包有cmake openssldevel ncurses-devel bison bison-devel zlib-devel libcurl-devel libarchive-devel boostdevel gcc gcc-c++ gnutls-devel libxml2-devel libevent-devel libaio-devel ，一口气yum装上。 1yum install cmake openssldevel ncurses-devel bison bison-devel zlib-devel libcurl-devel libarchive-devel boostdevel gcc gcc-c++ gnutls-devel libxml2-devel libevent-devel libaio-devel 然后编译 12345678910111213141516171819cmake . \-DCMAKE_INSTALL_PREFIX=/data/apps/mysql \-DMYSQL_DATADIR=/data/mysql/ \-DSYSCONFDIR=/etc/ \-DMYSQL_USER=mysql \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_ARCHIVE_STORAGE_ENGINE=1 \-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \-DWITH_PARTITION_STORAGE_ENGINE=1 \-DWITHOUT_MROONGA_STORAGE_ENGINE=1 \-DWITH_DEBUG=0 \-DWITH_READLINE=1 \-DWITH_SSL=system \-DWITH_ZLIB=system \-DWITH_LIBWRAP=0 \-DENABLED_LOCAL_INFILE=1 \-DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci 6.安装 1make -j 4 &amp;&amp; make install 7.创建配置文件,并修改 1234mkdir /etc/mysql/cp /etc/my.cnf /etc/mysql/my.cnfsed -ri '/datadir=\//s@(.*=).*@\1\/data\/mysql@' /etc/mysql/my.cnf #修改配置文件，指定数据库储存路径sed -ri '/datadir/a\innodb_file_per-table=on\nskip_name_resolve=on' /etc/mysql/my.cnf #设置每个表独立文件 和 禁用主机名解析 8.创建数据库文件 12chown -R root:mysql /data/apps/mysql//usr/local/scripts/mysql_install_db --datadir=/data/mysql --user=mysql 9.创建服务脚本并启动服务 123cp /data/apps/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqldchkconfig --add mysqldservice mysqld start 10.增加PATH环境变量路径,并生效。 12echo 'PATH=/data/apps/mysql/bin:$PATH' &gt;/etc/profile.d/mysql.sh. /etc/profile.d/mysql.sh 11.运行安全初始化脚本，设置root口令、禁用匿名登陆、禁用远程主机登陆、删除test数据库，并立即生效(根据提示操作)。 1/data/apps/mysql/bin/mysql_secure_installation &emsp;&emsp;报错：Can’t connect to local MySQL server through socket ‘/data/mysql/mysql.sock’ (2)&emsp;&emsp;用ll看了下/data/mysql/mysql.sock确实不存在，而我记得我配置文件/etc/mysql/my.cnf中定义的sosck是在 下&emsp;&emsp;那就把/var/lib/mysql/mysql.sock文件创建一个软链接至/data/mysql/目录 1/ln -s /var/lib/mysql/mysql.sock /data/mysql/ &emsp;&emsp;再次尝试安全初始化脚本。 1/data/apps/mysql/bin/mysql_secure_installation &emsp;&emsp;果然成功了。&emsp;&emsp;至此，源码编译安装mariadb数据库就完成了~]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编译安装</tag>
        <tag>mysql</tag>
        <tag>mariadb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署自动化安装及cobber(Http+TFTP+PXE+kickstart无人职守批量安装精简版Linux系统)]]></title>
    <url>%2F%2Fblog%2F8ddda8e.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;为了简化每台服务器的系统的装机过程和统一服务器配置，可以采用一键自动化安装系统的方式，实现新机器接上网线开机便可批量安装相同配置的系统，便于以后统一管理。&emsp;&emsp;想要实现自动化安装系统，&emsp;&emsp;1.搭建dhcp服务器，给新机器网卡分配IP地址，并引导机器去搭建好的tftp站点下载引导程序及内核文件；&emsp;&emsp;2.搭建tftp服务器，提供引导程序及内核文件；复制内核文件至服务器目录；&emsp;&emsp;3.搭建http服务器，提供应答kickstart文件、系统安装包程序的下载；挂载光盘或拷贝安装包至目录文件；&emsp;&emsp;4生成ks应答kickstart文件（放置于ftp服务器中）；&emsp;&emsp;5.复制光盘中的/cdrom/isolinux/isolinux.cfg文件至目录pxelinux.cfg/，改名为pxelinux.cfg/fault文件，即为安装菜单（之后目录pxelinux.cfg/整体放入tftp服务器中）。 &emsp;&emsp;演示环境：CentOS7 Kernel Version: 3.10.0-957.el7.x86_64 本机IP:192.168.32.7 1. 配置DHCP服务器&emsp;&emsp;1.首先安装dhcp服务。 1yum install dhcp &emsp;&emsp;2.启动dhcp服务。但直接启动，会报错，如下图所示，须先修改dhcpd的配置文件。&emsp;&emsp;打开/etc/dhcp/dhcpd.conf配置文件后发现，配置文件是空的，难怪报错，有一行“see /usr/share/doc/dhcpd.conf.example”，原来要我们参考这个模版来自己写配置文件。&emsp;&emsp;于是先复制模版至原配置文件目录。&emsp;&emsp;选择覆盖，再打开配置文件。&emsp;&emsp;修改⑴网段⑵租期时长⑶网关⑷DNS⑸DNS域后缀⑹提供资源下载站点IP⑺需要下载的引导文件&emsp;&emsp;此时重启DHCP服务成功，查看DHCP服务状态，已经启动（状态信息的提示，是指另一块网卡没有被DHCP服务器网段分配地址，分配一个就足够了，可以无视）。 2.搭建tftp服务器&emsp;&emsp;1.首先安装tftp服务端 1yum install tftp-server -y &emsp;&emsp;2.生成pxelinux.0引导程序，并放入tftp服务器&emsp;&emsp;&emsp;⑴先确定引导程序所在的安装包； 1yum search pxelinux &emsp;&emsp;&emsp;⑵安装syslinux.x86_64； 1yum install syslinux.x86_64 &emsp;&emsp;&emsp;⑶找到引导程序pxelinux.0的所在路径； 1rpm -ql syslinux.x86_64|grep pxelinux.0 &emsp;&emsp;&emsp;⑷将引导程序pxelinux.0及菜单背景模版文件menu.c32拷贝到服务器 1cp /usr/share/syslinux/pxelinux.0 /usr/share/syslinux/menu.c32 /var/lib/tftpboot/ &emsp;&emsp;3.将准备好的内核文件和initrd.img文件拷贝到服务器 12cp /cdrom6/isolinux/vmlinuz /cdrom6/isolinux/initrd.img /var/lib/tftpboot/6/cp /cdrom7/isolinux/vmlinuz /cdrom7/isolinux/initrd.img /var/lib/tftpboot/7/ &emsp;&emsp;最终效果如下： 3.搭建http服务器&emsp;&emsp;1.首先安装httpd服务端 1yum install httpd -y &emsp;&emsp;2.启动httpd服务 1systemctl start httpd &emsp;&emsp;3.查看httpd服务状态是否启动 1systemctl status httpd &emsp;&emsp;4.创建安装包文件目录 1mkdir -pv /var/www/html/CentOS/&#123;6,7&#125;/os/x86_64/ &emsp;&emsp;5.挂载光盘安装包至目录或拷贝安装文件至目录 12mount /dev/sr0 /var/www/html/CentOS/7/os/x86_64/mount /dev/sr1 /var/www/html/CentOS/6/os/x86_64/ &emsp;&emsp;效果图如下：&emsp;&emsp;6.挂载光盘安装包至目录或拷贝安装文件至目录 4.生成kickstart应答文件&emsp;&emsp;ks文件的生成一般有两种方法：&emsp;&emsp;①：之前手动安装后系统自动生成的的记录文件/root/anaconda-ks.cfg文件是可以直接复制过来修改使用的。&emsp;&emsp;②：用kickstart工具生成。我们这里采用第二种。执行命令。（这是一个在图形化界面操作的选项命令，如果用的是Xshell工具连接虚拟机，需要开启Xmanager - Passive，来转发图形化界面） 1system-config-kickstart &emsp;&emsp;第一步，选择语言，键盘布局，时区，设置root口令（是否加密存储），安装完成后重启，命令行模式安装；&emsp;&emsp;第二步，选择选择系统安装方式，通过HTTP服务站点安装，输入已经搭好的服务器IP和安装包路径；&emsp;&emsp;第三步，选择安装grub引导安装程序，（先不对grub进行加密了，据说会有加密方式不符的话会有报错），加内核参数net.innames=0实现不更改网卡名称；&emsp;&emsp;第四步，清除原有分区，清除分区标签，设置新分区表；&emsp;&emsp;第五步，设置网卡名eth0，及获取IP方式为DHCP；&emsp;&emsp;第六步，默认关闭SELINUX策略和防火墙；&emsp;&emsp;第七步，选择需要的系统服务；&emsp;&emsp;第八步，附加装机前后脚本；&emsp;&emsp;第九步，将ks应答文件复制到http服务器&emsp;&emsp; 1mkdir -p /var/www/html/ksdir/;cp ~/centos7-ks.cfg /var/www/html/ksdir/ &emsp;&emsp;（CentOS6的KS同样方式生成） 1cp ~/centos6-ks.cfg /var/www/html/ksdir/ 5.创建安装菜单&emsp;&emsp;菜单文件的一般有两种方法：&emsp;&emsp;①：复制修改光盘中的菜单文件/cdrom/isolinux/lisolinux.cfg文件是可以直接复制过来修改使用的。&emsp;&emsp;①：VIM手工输入。 123456789101112131415default menu.c32timeout 600menu title Auto Install CentOSlabel linux 7 mennu label Install CentOS^7 menu default kernel 7/vmlinuz append initrd=7/initrd.img ks=http://192.168.32.7/ksdir/centos7-ks.cfglabel linux 6 mennu label Install CentOS^6 kernel 6/vmlinuz append initrd=6/initrd.img ks=http://192.168.32.7/ksdir/centos6-ks.cfglabel linux local mennu label Boot from ^local drive localboot Oxffff &emsp;&emsp;再将菜单文件存入tftp服务器中 /linux.cfg目录 下 重命名为fault文件。tftp服务器最终目录机构如下图所示：&emsp;&emsp;至此，基于PXE网卡，无人职守批量安装CentOS系统的配置就完成了。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cobber</tag>
        <tag>kickstart</tag>
        <tag>pxe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6源码编译 安装linunx内核最新版5.2.9]]></title>
    <url>%2F%2Fblog%2F133d68.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前在CentOS7 上源码编译安装过新内核，不过有次在6上编译就遇到问题了，提示错误如下1make[2]: *** [scripts/sign-file] Error 1 make[1]: *** [scripts] Error 2 make搞了好久，好像是参数设置不正确。1error: #error Sorry, your compiler is too old - please upgrade it &emsp;&emsp;好像是说gcc版本过低。&emsp;&emsp;去epel源找了一下，已经是最新版了啊~&emsp;&emsp;查看了下之前CentOS7的gcc版本，是gcc-4.8.5，再去一查这个CentOS6的gcc版本，是gcc-4.4.7，可能就差在这几个小版本上了。&emsp;&emsp;于是升级gcc版本就成了当务之急。&emsp;&emsp;那就源码编译安装个新版的gcc吧。（后来朋友说可以直接把CentOS7上gcc的rpm包直接拿来用的，未尝试） 编译安装gcc&emsp;&emsp;gcc有三个依赖包gmp、mpfr、mpc,要首先编译安装（虽然原本就有，不过如果编译高版本gcc，这三个依赖包不装新版本的话也会报错）&emsp;&emsp;先去下载好三个依赖包源码包及gcc源码包 123456mkdir /data/gcc #创建目录/data/gcccd /data/gccwget https://gmplib.org/download/gmp/gmp-6.1.2.tar.xz #下载gmp6.1.2wget http://www.mpfr.org/mpfr-current/mpfr-3.1.5.tar.gz #下载mpfr3.1.5wget ftp://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gz #下载mpc1.0.3wget ftp://ftp.gnu.org/gnu/gcc/gcc-6.3.0/gcc-6.3.0.tar.gz #下载gcc6.3.0 &emsp;&emsp;再挨个编译安装三个依赖包（注意这三个依赖包也有依赖关系，需先安装gmp，再安装mpfr，之后再装mpc） gmp&emsp;&emsp;先来第一个，编译安装装gmp 1234tar -xJf gmp-6.1.2.tar.xz gmp-6.1.2cd gmp-6.1.2./configure --prefix=/usr/local/gcc/gmp --build=x86_64-linuxmake &amp;&amp; make install &emsp;&emsp;这当时有报错&emsp;&emsp;error: could not find a working compiler&emsp;&emsp;当时没有加参数 –build=x86_64-linux，加上之后成功解决，参考: 原文地址. http://www.voidcn.com/article/p-zsgyngma-ug.html mpfr&emsp;&emsp;之后编译安装mpfr 1234tar -xJf mpfr-3.1.5.tar.xz mpfr-3.1.5cd mpfr-3.1.5./configure --prefix=/usr/local/gcc/mpfr --with-gmp=/usr/local/gcc/gmpmake &amp;&amp; make install &emsp;&emsp;然后编译安装mpc 1234tar -xzf mpc-1.0.3.tar.gz mpc-1.0.3cd mpc-1.0.3./configure --prefix=/usr/local/gcc/mpc --with-gmp=/usr/local/gcc/gmp -with-mpfr=/usr/local/gcc/mpfrmake &amp;&amp; make install gcc&emsp;&emsp;之后也没有报错，那就开始编译安装gcc。 1234tar xvf gcc-6.3.0.tar.gzcd gcc-6.3.0./configure --prefix=/usr/local/gcc --enable-threads=posix --disable-checking --disable-multilib --enable-languages=c,c++ --with-gmp=/usr/local/gcc/gmp --with-mpfr=/usr/local/gcc/mpfr --with-mpc=/usr/local/gcc/mpcmake &amp;&amp; make install &emsp;&emsp;gcc中途有几次报错，不过也都解决了。错误提示[1]： 1make: *** [sub-make] Error 2 &emsp;&emsp;显示这个问题编译不过去。这是因为找不到gmp依赖包导致的，可是我明明装了依赖包的，看来是路径设置有问题，因为当时我是把这三个依赖包都装在gcc下，不过在编译gcc的时候忘记改依赖包的地址了。错误提示[2]： 1configure: error: cannot compute suffix of object files: cannot compile &emsp;&emsp;解决办法是：&emsp;&emsp;在/etc/profile里面加上以下内容： 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gcc/mpc-0.9/lib:/usr/local/gcc/gmp-5.0.1/lib:/usr/local/gcc/mpfr-3.1.0/lib &emsp;&emsp;然后重新加载配置文件/etc/profile 1source /etc/profile 添加变量&emsp;&emsp;/usr/local/lib &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; #这个是默认系统的变量&emsp;&emsp;/usr/local/gmp/lib&emsp;&emsp;/usr/local/mpfr/lib&emsp;&emsp;/usr/local/mpc/lib&emsp;&emsp;/usr/local/mysql/lib&emsp;&emsp;/usr/local/openssl/lib &emsp; &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#openssl变量 &emsp;&emsp;添加保存后记得更新动态库的缓存：&emsp;&emsp;ldconfig -v 备份系统默认的gcc版本123mv /usr/bin/gcc /usr/bin/gcc-bakmv /usr/bin/g++ /usr/bin/g++-bakmv /usr/bin/c++ /usr/bin/c++-bak 建新的gcc软连接1234ln -s /usr/local/gcc/bin/gcc /usr/bin/gccln -s /usr/local/gcc/bin/c++ /usr/bin/c++ln -s /usr/local/gcc/bin/g++ /usr/bin/g++ln -s /usr/local/gcc/lib64/libstdc++.so.6.0.22 /usr/lib64/libstdc++.so.6 编译安装linux kernel 5.2.9&emsp;&emsp;高高兴兴cd linux-5.2.9，进入解压好的内核目录，做好.config配置文件，准备用make menuconfig对内核进行自定义配置的时候，报错了： 1error while loading shared libraries: libmpc.so.3: cannot open shared object file: No such file or directory &emsp;&emsp;这又是怎么回事。好像是gcc出问题了。返回去检查。&emsp;&emsp;原来添加完库忘了更新动态库,输入命令: 1ldconfig -v ~结果还报错： 123456scripts/kconfig/mconf KconfigYour display is too small to run Menuconfig!It must be at least 19 lines by 80 columns.make[2]: *** [menuconfig] Error 1make[1]: *** [menuconfig] Error 2make: *** [sub-make] Error 2 这是因为我的XSELL窗口太小了，把XSHELL放大最大化，果然就打开了熟悉的蓝色界面~修改一些个性化的设置（例如改名、加NFS文件系统），就可以保存了。 编译内核&emsp;&emsp;因为编译内核时间比较长，为防止发生断网或者断电等意外，我们创建一个SCREEN来编译。&emsp;&emsp; 12screen -S linuxkernelyes | make -j 16 &emsp;&emsp;用一个yes命令省去一直手动y了，等待他编译完成就好了。&emsp;&emsp;&emsp;&emsp;在这又遇到一个报错，贴出来和大家分享下： 1You are building kernel with non-retpoline compiler. &emsp;&emsp;去查了下，网上都说是因为gcc版本过低，或内核版本过高。可我这明显不是gcc版本低的问题（都那么高了），问题是内核版本应该也不是问题，毕竟之前CentOS7编译就没这么多事。正犯愁不知道怎么解决的时候，发现了一篇文章查看原文，发现这个报错可以通过修改参数直接不启用RETPOLINE从而跳过（具体后果未知），于是修改配置文件重新来过： 123make cleansed -ri 's@(CONFIG_RETPOLINE=).*@\1n@' .configmake -j 16 &emsp;&emsp;果然就顺利编译成功了。 编译模块&emsp;&emsp;然后安装模块：&emsp;&emsp; 1make modules_ install &emsp;&emsp;安装模块的时候，有报错：&emsp;&emsp; 1ERROR: modinfo: could not find module * &emsp;&emsp;不过查了相关文章查看原文，好像这些模块也都可以正常使用，于是乎无视之~&emsp;&emsp;最后，安装内核相关文件。&emsp;&emsp; 1make install &emsp;&emsp;至此，新内核就装完啦~重启切换去去体验一下！]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编译安装</tag>
        <tag>kernel</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环实现的小脚本]]></title>
    <url>%2F%2Fblog%2Fa96e917a.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;用for循环写了个小脚本，可以输出不同大小的图案，能力有限，输出了一个不太规则的字符图案，希望可以早日写出一个脚本可以自动填充放大任何ASCII图案。&emsp;&emsp;效果图如下： &emsp;&emsp;脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#!/bin/bashread -p "please input the size :" n[ "$n" -ge 0 ] 2&gt;/dev/null || &#123; echo "please input a right num!";exit 10;&#125;mkdir -p ~/best/bestN=`echo $n-1|bc`J=`echo $N/2+1|bc`K=`echo $N/4+1|bc`L=`echo $N/5|bc`#第一行echo -e '88888\c' &gt;~/best/best.f1for i in $(seq $N);do echo -e '888\c' &gt;&gt;~/best/best.f1donefor i in $(seq $L);do echo -e '88\c' &gt;&gt;~/best/best.f1doneecho '888ba' &gt;&gt;~/best/best.f1#第二行echo -e '8\c' &gt;~/best/best.f2for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f2doneecho -e '8 \c' &gt;&gt;~/best/best.f2for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f2doneecho -e ' "8\c' &gt;&gt;~/best/best.f2for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f2doneecho -e 'b \c' &gt;&gt;~/best/best.f2for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f2doneecho ',d' &gt;&gt;~/best/best.f2#第三行echo -e '8\c' &gt;~/best/best.f3for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f3doneecho -e '8 \c' &gt;&gt;~/best/best.f3for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f3doneecho -e ' "8\c' &gt;&gt;~/best/best.f3for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f3doneecho -e 'P \c' &gt;&gt;~/best/best.f3for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f3doneecho '88' &gt;&gt;~/best/best.f3#第四行echo -e '8\c' &gt;~/best/best.f4for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f4doneecho -e '8aaa\c' &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e 'aaa\c' &gt;&gt;~/best/best.f4doneecho -e 'aaa8\c' &gt;&gt;~/best/best.f4for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f4doneecho -e 'P'"'"' ,adP\c' &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e 'PP\c' &gt;&gt;~/best/best.f4doneecho -e 'PYba, ,adP\c' &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e 'PP\c' &gt;&gt;~/best/best.f4doneecho -e 'PYba, MM\c' &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e 'M\c' &gt;&gt;~/best/best.f4doneecho -e '88MM\c' &gt;&gt;~/best/best.f4for i in $(seq $N);do echo -e 'M\c' &gt;&gt;~/best/best.f4doneecho &gt;&gt;~/best/best.f4#第五行echo -e '8\c' &gt;~/best/best.f5for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f5doneecho -e '8 \c' &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f5doneecho -e ' 8\c' &gt;&gt;~/best/best.f5for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f5doneecho -e 'b, a8P \c' &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f5doneecho -e ' `8 I8[ \c' &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f5doneecho -e ' "'"'"' \c' &gt;&gt;~/best/best.f5for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f5doneecho -e ' 88' &gt;&gt;~/best/best.f5#第六行echo -e '8\c' &gt;~/best/best.f6for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f6doneecho -e '8 \c' &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f6doneecho -e ' `8\c' &gt;&gt;~/best/best.f6for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f6doneecho -e 'b 8PP""\c' &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e '""\c' &gt;&gt;~/best/best.f6doneecho -e '"""`'"'"' `"Y8\c' &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e '88\c' &gt;&gt;~/best/best.f6doneecho -e 'ba, \c' &gt;&gt;~/best/best.f6for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f6doneecho -e ' 88\c' &gt;&gt;~/best/best.f6echo &gt;&gt;~/best/best.f6#第七行echo -e '8\c' &gt;~/best/best.f7for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f7doneecho -e '8 \c' &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f7doneecho -e ' a8\c' &gt;&gt;~/best/best.f7for i in $(seq $L);do echo -e '8\c' &gt;&gt;~/best/best.f7doneecho -e 'P "8b, \c' &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f7doneecho -e ' ,aa aa \c' &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f7doneecho -e ' ]8I \c' &gt;&gt;~/best/best.f7for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f7doneecho -e ' 88,' &gt;&gt;~/best/best.f7#第八行echo -e '88888\c' &gt;~/best/best.f8for i in $(seq $N);do echo -e '888\c' &gt;&gt;~/best/best.f8donefor i in $(seq $L);do echo -e '88\c' &gt;&gt;~/best/best.f8doneecho -e '888P" `"Ybb\c' &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e 'oo\c' &gt;&gt;~/best/best.f8doneecho -e 'd8"'"'"' `"Ybb\c' &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e 'oo\c' &gt;&gt;~/best/best.f8doneecho -e 'dP"'"'"' \c' &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e ' \c' &gt;&gt;~/best/best.f8doneecho -e ' "Y888\c' &gt;&gt;~/best/best.f8for i in $(seq $N);do echo -e '8\c' &gt;&gt;~/best/best.f8doneecho &gt;&gt;~/best/best.f8for j in $(seq $K);do cat ~/best/best.f1donefor j in $(seq $J);do cat ~/best/best.f2donefor j in $(seq $J);do cat ~/best/best.f3donefor j in $(seq $K);do cat ~/best/best.f4donefor j in $(seq $J);do cat ~/best/best.f5donefor j in $(seq $K);do cat ~/best/best.f6donefor j in $(seq $J);do cat ~/best/best.f7donefor j in $(seq $K);do cat ~/best/best.f8done\rm -rf ~/best/best &emsp;&emsp;脚本写的太复杂，可读性太差，等日后水平提升再来改进，留存！]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7磁盘分区及文件系统]]></title>
    <url>%2F%2Fblog%2F2bae1e5c.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;一般来说，硬盘上的空间，想要被我们利用，都要经过几个步骤： 1设备识别 2磁盘分区 3创建文件系统（并标记文件系统） 4挂载新的文件系统 5在/etc/fstab文件中创建新条目&emsp; &emsp;&emsp;只有当设备被挂载到文件系统中，才可以被我们访问且使用。&emsp; 1 设备识别 新插入硬盘设备，没法被系统立马识别到，需要手动扫描，才可以发现并识别新设备echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan/sys/class/scsi_host/ 目录下面有几个host 就扫描几次。&emsp;&emsp; 2 磁盘分区2.1为什么要分区 优化I/O性能 实现磁盘空间配额限制 提高修复速度 隔离系统和程序 安装多个OS 采用不同文件系统 2.2分区方式&emsp;&emsp;一般来说有两种分区方式 ：MBR和GPT。 MBR：全程Master Boot Record，1982年，使用32位表示扇区，单个分区不超过2T。 如何分区：按柱面 0磁道0扇面：512bytes&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;446byets：boot loader&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;64bytes ： 分区表，其中每16bytes标识一个分区&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2byetes&emsp;：55AA MBR分区中一块硬盘最多有4个主分区，也可以三主分区+1拓展（N个逻辑分区）&emsp; MBR分区结构 MBR分区表&emsp;&emsp;硬盘主导记录MBR由4个部分组成 主引导程序（偏移地址0000H–0088H），它负责从活动分区中装载，并运行系统引导程序 出错信息数据区，偏移地址0089H-00E1H为出错信息，00E2H-01BDH全为0字节 分区表（DPT,Disk Partition Table）含4个分区项，偏移地址01BEH–01FDH，每个分区表长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4 结束标志字，偏移地址01FE–01FF的2个字节值为结束标志55AA&emsp; GPT：GUID（Globals Unique Identifiers） partition table 支持128个分区，使用64位，支持8Z（ 512Byte/block ）64Z （ 4096Byte/block） 使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区表自动备份在头和尾两份，并有CRC校验位 UEFI (Unified Extensible Firmware Interface 统一可扩展固件接口)硬件支持GPT，使操作系统启动&emsp;GPT分区结构2.3管理分区2.31列出块设备2.32创建新分区&emsp;&emsp;parted命令：parted [选项]… [设备 [命令 [参数]…]…]&emsp;&emsp;parted /dev/sdb mklabel gpt|msdos&emsp;&emsp;parted /dev/sdb print&emsp;&emsp;parted /dev/sdb mkpart primary 1 200 （默认M）&emsp;&emsp;parted /dev/sdb rm 1&emsp;&emsp;parted –l 列出分区信息 parted的操作都是实时生效的，小心使用&emsp;&emsp;&emsp; fdisk -l [-u] [device…] 查看分区&emsp;&emsp; fdisk /dev/sdb 管理分区子命令：&emsp;&emsp;&emsp;&emsp;&emsp;p 查看分区列表&emsp;&emsp;&emsp;&emsp;&emsp;t 更改分区类型&emsp;&emsp;&emsp;&emsp;&emsp;n 创建新分区&emsp;&emsp;&emsp;&emsp;&emsp;d 删除分区&emsp;&emsp;&emsp;&emsp;&emsp;v 校验分区&emsp;&emsp;&emsp;&emsp;&emsp;u 转换单位&emsp;&emsp;&emsp;&emsp;&emsp;w 保存并退出&emsp;&emsp;&emsp;&emsp;&emsp;q 不保存并退出&emsp;gdisk命令与fdisk用法相同，用于创建GPT分区。 2.33同步内核与硬盘的分区表查看内核是否已经识别新的分区cat /proc/partationscentos6通知内核重新读取硬盘分区表新增分区用partx -a /dev/DEVICEkpartx -a /dev/DEVICE -f: force删除分区用partx -d –nr M-N /dev/DEVICECentOS 5，7: 使用partprobepartprobe [/dev/DEVICE] 3 创建文件系统3.1文件系统&emsp;&emsp;文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，安全控制，日志，压缩，加密等&emsp;&emsp;&emsp;支持的文件系统：/lib/modules/`uname –r`/kernel/fs&emsp;&emsp;&emsp;各种文件系统：https://en.wikipedia.org/wiki/Comparison_of_file_systems 3.11文件系统类型Linux文件系统：&emsp;&emsp;ext2(Extended file system)：适用于那些分区容量不是太大，更新也不频繁的情况，例如 /boot 分区&emsp;&emsp;ext3：是 ext2 的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中恢复。它通常被用作通用的文件系统&emsp;&emsp;ext4：是 ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件(16TB)、最大1EB的文件系统，以及速度的提升&emsp;&emsp;xfs：SGI，支持最大8EB的文件系统&emsp;&emsp;btrfs（Oracle）, reiserfs, jfs（AIX）, swap光盘：iso9660Windows：FAT32, NTFS，exFATUnix：FFS（fast）, UFS（unix）, JFS2网络文件系统：NFS, CIFS集群文件系统：GFS2, OCFS2（oracle）分布式文件系统：fastdfs,ceph, moosefs, mogilefs, glusterfs, LustreRAW：未经处理或者未经格式化产生的文件系统 3.12文件系统分类根据其是否支持”journal”功能：&emsp;&emsp;日志型文件系统: ext3, ext4, xfs, …&emsp;&emsp;非日志型文件系统: ext2, vfat文件系统的组成部分：&emsp;&emsp;内核中的模块：ext4, xfs, vfat&emsp;&emsp;用户空间的管理工具：mkfs.ext4, mkfs.xfs,mkfs.vfatLinux的虚拟文件系统：VFS查前支持的文件系统：cat /proc/filesystems查前目前的文件系统：lsblk -f 3.2创建文件系统mkfs命令：(1) mkfs.FS_TYPE /dev/DEVICE&emsp;&emsp;&emsp;&emsp;ext4&emsp;&emsp;&emsp;&emsp;xfs&emsp;&emsp;&emsp;&emsp;btrfs&emsp;&emsp;&emsp;&emsp;vfat(2) mkfs -t FS_TYPE /dev/DEVICE&emsp;&emsp;&emsp;&emsp;-L ‘LABEL’ 设定卷标&emsp;mke2fs命令：ext系列文件系统专用管理工具&emsp;&emsp;&emsp;-t {ext2|ext3|ext4} 指定文件系统类型&emsp;&emsp;&emsp;-b {1024|2048|4096} 指定块大小&emsp;&emsp;&emsp;-L ‘LABEL’ 设置卷标&emsp;&emsp;&emsp;-j 相当于 -t ext3 (mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3)`&emsp;&emsp;&emsp;-i # 为数据空间中每多少个字节创建一个inode；不应该小于block大小&emsp;&emsp;&emsp;-N # 指定分区中创建多少个inode&emsp;&emsp;&emsp;-I 一个inode记录占用的磁盘空间大小，128—4096&emsp;&emsp;&emsp;-m # 默认5%,为管理人员预留空间占总空间的百分比&emsp;&emsp;&emsp;-O FEATURE[,…] 启用指定特性&emsp;&emsp;&emsp;-O ^FEATURE 关闭指定特性 3.3文件系统标签文件系统标签是指向设备的另一种方法。与设备无关blkid：块设备属性信息查看blkid [OPTION]… [DEVICE]&emsp;&emsp;&emsp;-U UUID 根据指定的UUID来查找对应的设备&emsp;&emsp;&emsp;-L LABEL 根据指定的LABEL来查找对应的设备e2label：管理ext系列文件系统的LABELe2label DEVICE [LABEL]findfs ：查找分区findfs [options] LABEL= &lt; label &gt;findfs [options] UUID= &lt; uuid &gt; 3.4文件系统检测和修复文件系统夹故障常发生于死机或者非正常关机之后，挂载为文件系统标记为“no clean” 注意：一定不要在挂载状态下执行下面命令修复 fsck: File System Check&emsp;&emsp;fsck.FS_TYPE&emsp;&emsp;fsck -t FS_TYPE注意：FS_TYPE 一定要与分区上已经文件类型相同-a 自动修复-r 交互式修复错误 e2fsck：ext系列文件专用的检测修复工具-y 自动回答为yes-f 强制修复-p 自动进行安全的修复文件系统问题xfs_repair：xfs文件系统专用检测修复工具-f 修复文件，而设备-n 只检查-d 允许修复只读的挂载设备，在单用户下修复 / 时使用，然后立即reboot 4 挂载新的文件系统挂载： 将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为卸载： 为解除此关联关系的过程把设备关联挂载点：mount Point&emsp;&emsp;mount 设备名 挂载点卸载时：可使用设备，也可以使用挂载点&emsp;&emsp;umount 设备名|挂载点PS：挂载点下原有文件在挂载完成后会被临时隐藏&emsp;&emsp; 挂载点目录一般为空 4.1用mount命令挂载文件系统挂载方法：mount DEVICE MOUNT_POINT&emsp;&emsp;mount：通过查看/etc/mtab文件显示当前已挂载的所有设备&emsp;&emsp;mount [-fnrsvw] [-t vfstype] [-o options] device dirdevice：指明要挂载的设备；&emsp;&emsp;(1) 设备文件：例如/dev/sda5&emsp;&emsp;(2) 卷标：-L ‘LABEL’, 例如 -L ‘MYDATA’&emsp;&emsp;(3) UUID, -U ‘UUID’：例如 -U ‘0c50523c-43f1-45e7-85c0-a126711d406e’&emsp;&emsp;(4) 伪文件系统名称：proc, sysfs, devtmpfs, configfsdir：挂载点需事先存在，建议使用空目录；进程正在使用中的设备无法被卸载。mount常用命令选项&emsp;&emsp;-t vsftype 指定要挂载的设备上的文件系统类型&emsp;&emsp;-r readonly，只读挂载&emsp;&emsp;-w read and write, 读写挂载&emsp;&emsp;-n 不更新/etc/mtab，mount不可见&emsp;&emsp;-a 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中，且挂载选项中有auto功能)&emsp;&emsp;-L ‘LABEL’ 以卷标指定挂载设备&emsp;&emsp;-U ‘UUID’ 以UUID指定要挂载的设备&emsp;&emsp;-B, –bind 绑定目录到另一个目录上&emsp;&emsp;查看内核追踪到的已挂载的所有设备：cat /proc/mounts &emsp;&emsp;-o options：(挂载文件系统的选项)，多个选项使用逗号分隔&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;async 异步模式 sync 同步模式,内存更改时，同时写磁盘&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;包含目录和文件&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;diratime/nodiratime 目录的访问时间戳&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;auto/noauto 是否支持自动挂载,是否支持-a选项&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;exec/noexec 是否支持将文件系统上运行应用程序&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dev/nodev 是否支持在此文件系统上使用设备文件&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;suid/nosuid 是否支持suid和sgid权限&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;remount 重新挂载&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ro 只读 rw 读写&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;user/nouser 是否允许普通用户挂载此设备，/etc/fstab使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;acl 启用此文件系统上的acl功能&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;loop 使用loop设备&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;_netdev 当网络可用时才对网络资源进行挂载，如：NFS文件系统&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;defaults 相当于rw, suid, dev, exec, auto, nouser, async 4.2卸载命令查看挂载情况&emsp;&emsp;findmnt MOUNT_POINT|device查看正在访问指定文件系统的进程&emsp;&emsp;lsof MOUNT_POINT&emsp;&emsp;fuser -v MOUNT_POINT终止所有在正访问指定的文件系统的进程&emsp;&emsp;fuser -km MOUNT_POINT卸载&emsp;&emsp;umount DEVICE&emsp;&emsp;umount MOUNT_POINT 5 修改/etc/fstab配置文件&emsp;&emsp;使用mount命令挂载设备都是临时挂载，每次开机后需要手动重新挂载，比较费时费力，如果需要实现自动挂载，就要修改文件系统挂载配置文件/etc/fstab文件。/etc/fstab文件 下面的每行定义一个要挂载的文件系统&emsp;&emsp;总共六列，分别对应设备、挂载点、文件系统类型、挂载选项、转储频率及是否自检。 1、要挂载的设备或伪文件系统设备文件LABEL：LABEL=””UUID：UUID=””伪文件系统名称：proc, sysfs 2、挂载点 一般为某文件或目录 3、文件系统类型：ext4，xfs，iso9660，nfs，none 4、挂载选项：defaults（包括rw suidi dev exac auto nouser async） ，acl，bind 5、转储频率：0：不做备份 1：每天转储 2：每隔一天转储 6、fsck检查的文件系统的顺序：允许的数字是0 1 2&emsp;&emsp;0：不自检&emsp;&emsp;1：首先自检；一般只有rootfs才用&emsp;&emsp;2：非rootfs使用&emsp;&emsp;可以使用cat 、echo 等命令 将这6个信息 追加至/etc/fstab文件中，也可以用sed 命令 。 &emsp;&emsp;使用mount -a 命令可以立即挂载/etc/fstab中的所有文件系统]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的一键个性化系统脚本]]></title>
    <url>%2F%2Fblog%2F92724e23.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;经常要把虚拟机上的系统搞崩，总是各种报错，有次yum安装gcc程序都报错，一旦折腾半天解决不了，只好选择最笨却最有效的方法——还原vrm虚拟机的快照！可是还原快照到干净系统，就导致之前做的喜欢的配置又都没了 还要去慢慢设置开机图案、别名以及各种环境变量比较麻烦，于是就费了点时间，写了下面这个脚本，每次都可以一键实现让新系统恢复自己当初个性化的各种设置。&emsp;&emsp;先传效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#!/bin/bashread -p &quot;please input a name for the address:&quot; USERDIR#输入用户名，方便在/etc目录下存放生成的配置文件[ -a /etc/$USERDIR ] &amp;&amp; [ -d /etc/$USERDIR ] ||&#123; \rm -rf /etc/$USERDIR; mkdir /etc/$USERDIR; &#125;#mkdir /etc/$USERDIR#生成配置文件目录，若已存在则直接使用此目录cat &gt; /etc/$USERDIR/motd &lt;&lt; ENDoooooooooooo oooooooooo. ooooooooooooo oooo oooooooooo. . 8&apos; 888 &apos;8 &apos;888&apos; &apos;Y8b 8&apos; 888 &apos;8 &apos;888 &apos;888&apos; &apos;Y8b .o8 888 &apos;ooooo. 888 888 .ooooo. 888 888 .oo. .ooooo. 888 888 .ooooo. .oooo.o .o888oo 888 d88&apos; &apos;88b 888oooo888&apos; d88&apos; &apos;88b 888 888P&quot;Y88b d88&apos; &apos;88b 888oooo888&apos; d88&apos; &apos;88b d88( &quot;8 888 888 888 888 888 &apos;88b 888ooo888 888 888 888 888ooo888 888 &apos;88b 888ooo888 &apos;&quot;Y88b. 888 888 888 888 888 .88P 888 .o 888 888 888 888 .o 888 .88P 888 .o o. )88b 888 . o888o &apos;Y8bod8P&apos; o888bood8P&apos; &apos;Y8bod8P&apos; o888o o888o o888o &apos;Y8bod8P&apos; o888bood8P&apos; &apos;Y8bod8P&apos; 8&quot;&apos;888P&apos; &quot;888&quot;END#生成开机欢迎动画，可以随意修改#创建/etc/$USERDIR/login.sh配置文件[ -a /etc/$USERDIR ] &amp;&amp; [ -d /etc/$USERDIR ]&amp;&amp; [ -w /etc/$USERDIR ] ||&#123; \rm -rf /etc/$USERDIR; mkdir /etc/$USERDIR; &#125;#确认文件目录存在且可用,开始写配置文件。#因为水平有限，不知道怎么把命令以及变量通过脚本生成到新脚本里#只能采用最笨的方法——一行一行的写入，希望各位大佬可以指点一二。echo &apos;#!/bin/bash &apos;&gt;/etc/$USERDIR/login.shecho &apos;cat /etc/$USERDIR/motd&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;date=`date &quot;+%F %T&quot;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;head=&quot;System information as of: $date&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;kernel=`uname -r`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;hostname=`echo $HOSTNAME`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Cpu load&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load1=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $1&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load5=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load15=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $3&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#System uptime&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;uptime=`cat /proc/uptime | cut -f1 -d.`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upDays=$((uptime/60/60/24))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upHours=$((uptime/60/60%24))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upMins=$((uptime/60%60))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upSecs=$((uptime%60))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;up_lastime=`date -d &quot;$(awk -F. &apos;&quot;&apos;&quot;&apos;&#123;print $1&#125;&apos;&quot;&apos;&quot;&apos; /proc/uptime) second ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Memory Usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;mem_usage=`free -m | awk &apos;&quot;&apos;&quot;&apos;/Mem:/&#123;total=$2&#125; /buffers\/cache/ &#123;used=$3&#125; END &#123;printf(&quot;%3.2f%%&quot;,used/total*100)&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;swap_usage=`free -m | awk &apos;&quot;&apos;&quot;&apos;/Swap/&#123;printf &quot;%.2f%&quot;,$3/$2*100&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Processes&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;processes=`ps aux | wc -l`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#User&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;users=`users | wc -w`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;USER=`whoami`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#System fs usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;Filesystem=$(df -h | awk &apos;&quot;&apos;&quot;&apos;/^\/dev/&#123;print $6&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Interfaces&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;INTERFACES=$(ip -4 ad | grep &apos;&quot;&apos;&quot;&apos;state &apos;&quot;&apos;&quot;&apos; | awk -F&quot;:&quot; &apos;&quot;&apos;&quot;&apos;!/^[0-9]*: ?lo/ &#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;|grep e)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;$head&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;----------------------------------------------&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Kernel Version:\t%s\n&quot; $kernel&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;HostName:\t%s\n&quot; $hostname&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;System Load:\t%s %s %s\n&quot; $load1, $load5, $load15&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;System Uptime:\t%s &quot;days&quot; %s &quot;hours&quot; %s &quot;min&quot; %s &quot;sec&quot;\n&quot; $upDays $upHours $upMins $upSecs&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Memory Usage:\t%s\t\t\tSwap Usage:\t%s\n&quot; $mem_usage $swap_usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Login Users:\t%s\t\t\tWhoami:\t\t%s\n&quot; $users $USER&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Processes:\t%s\n&quot; $processes&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Filesystem\tUsage\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;for f in $Filesystem&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;do&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; Usage=$(df -h | awk &apos;&quot;&apos;&quot;&apos;&#123;if($NF==&quot;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;$f&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&quot;) print $5&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; echo -e &quot;$f\t\t$Usage&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;done&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Interface\tMAC Address\t\tIP Address\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;for i in $INTERFACES&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;do&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; MAC=$(ip ad show dev $i | grep &quot;link/ether&quot; | awk &apos;&quot;&apos;&quot;&apos;&#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; IP=$(ip ad show dev $i | awk &apos;&quot;&apos;&quot;&apos;/inet / &#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; printf $i&quot;\t\t&quot;$MAC&quot;\t$IP\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;done&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo&apos;&gt;&gt;/etc/$USERDIR/login.sh#生成脚本设置常用命令符以及别名及命令历史cat &gt; /etc/profile.d/env.sh &lt;&lt; ENDPS1=&quot;\e[1;36m[\u@\h \W]\\\\$\e[0m&quot;HISTTIMEFORMAT=&quot;%F %T &quot;HISTCONTROL=ignorebothalias rm=&apos;mkdir -p /date/delete/`date +%F`;\mv -t /date/delete/`date +%F` -f&apos;bash /etc/$USERDIR/login.shENDsed -i &apos;s/^alias rm/#&amp;/&apos; ~/.bashrc#取消用户定义的alias rm。#生成VIM的格式脚本cat &gt; ~/.vimrc &lt;&lt; END#!/bin/bash&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle()&quot;&quot;如果文件类型为.sh文件 if &amp;filetype == &apos;sh&apos; call setline(1,&quot;\##########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1,&quot;\# Author: Name &quot;) call append(line(&quot;.&quot;)+2,&quot;\# QQ: xxxxxxxxx&quot;) call append(line(&quot;.&quot;)+3,&quot;\# mail: xxxxxxxxxx@xxx.com&quot;) call append(line(&quot;.&quot;)+4,&quot;\# Description: The test script&quot;) call append(line(&quot;.&quot;)+5,&quot;\# Created Time: &quot;.strftime(&quot;%F %H:%M:%S&quot;)) call append(line(&quot;.&quot;)+6,&quot;\# Copyright（C）: &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;) call append(line(&quot;.&quot;)+7,&quot;\##########################################################################&quot;) call append(line(&quot;.&quot;)+8,&quot;\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+9,&quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot; &gt; Author: Name&quot;) call append(line(&quot;.&quot;)+2, &quot; &gt; Mail: xxxxxxxxxx@xxx.com&quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;)endif if &amp;filetype == &apos;cpp&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+8, &quot;&quot;)endif if &amp;filetype == &apos;c&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;)endif if &amp;filetype == &apos;java&apos; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+7,&quot;&quot;)endif&quot;&quot;新建文件后，自动定位到文件末尾endfuncautocmd BufNewFile * normal GENDmkdir -p /etc/yum.repos.d/backup\mv -f /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup/#禁用已有其他epel源，并做备份。umount /dev/cdrom#[ `cat /etc/fstab|grep -o iso` ]||sed -i &apos;/iso/c\&apos; /etc/fstab #解挂其他光盘CDUUID=`blkid|sed -nr &apos;/sr0/s/.*\bUUID=&quot;([^&quot;]+).*&quot;/\1/p&apos;`CDTYPE=`blkid|sed -nr &apos;/sr0/s/.*\bTYPE=&quot;([^&quot;]+).*&quot;/\1/p&apos;`[ `cat /etc/fstab|grep -o iso` ]||mkdir -p /cdrom #创建光盘目录[ `cat /etc/fstab|grep -o iso` ]||echo -e &quot;UUID=$CDUUID /cdrom $CDTYPE defaults 0 0&quot; &gt;&gt;/etc/fstab #修改fstab文件，方便以后自动挂载光盘#[ `cat /etc/fstab|grep -o iso` ]|| mount -o ro /dev/sr0 /cdrom #挂载光盘#mount -a #挂载光盘mount -o ro /dev/sr0 /cdrom #挂载光盘#生成常用yum源和epel源，这里选用阿里云的cat &gt; /etc/yum.repos.d/cdrom.repo &lt;&lt; END[cdrom]name=cdrom-repobaseurl=file:///cdromgpgcheck=0enabled=1ENDcat &gt; /etc/yum.repos.d/aliyun.repo &lt;&lt; &quot;END&quot;[aliyun]name=aliyun-epelbaseurl=https://mirrors.aliyun.com/epel/$releasever/$basearch/gpgcheck=1gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-7enabled=1END#新建本地及阿里云epel源.#修改网卡配置，根据个人情况修改cat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; ENDTYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=29126291-418f-4a08-b33e-c5cfa659d9b8DEVICE=ens33ONBOOT=yesIPADDR=172.18.32.7PREFIX=16GATEWAY=172.18.0.1DNS1=114.114.114.114ENDsystemctl restart network.service#重启网络服务，让刚才修改的配置生效mkdir -p /date/apps[ -z `cat ~/.bash_profile|grep apps` ] &amp;&amp; echo &apos;PATH=/date/apps:$PATH&apos; &gt;&gt;~/.bash_profile#修改PAT变量，方便以后装软件。`` &emsp;&emsp;水平有限，都是简单代码，留存记录，方便日后查看整理改进。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>script</tag>
        <tag>init</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由闷骚书生与假正经小姐的古典爱情故事说起]]></title>
    <url>%2F%2Fblog%2F1b0b2a49.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;城南外湖畔边，天气下着小雨，刮起微风，吹起茶铺门前的风铃叮铃作响让人昏昏欲睡，但铺子里舒缓轻柔的抚琴声却给人自然清醒的感觉，立锥之地，瞥一眼便一览无遗，简单的陈设透露出古朴淡雅，一长发清秀女子品一壶热茶望着这淅淅沥沥的小雨。&emsp;&emsp;“姑娘有心事？”一身穿白袍英俊书生抿嘴品茶问到。少女：“公子与城北唐公子可是熟识？”&emsp;&emsp;“书生：“我与他乃世交，有何事？”少女：“那下次你与他一同前来我这品茶可好？”书生：“他不喜品茶。”少女：“无妨，那公子可知他喜欢什么，我可以慢慢学。”书生：“我其实也不喜品茶。”少女：“公子莫说谎，不喜为何天天早晨都跑我这茶铺。” var ap = new APlayer({ element: document.getElementById("aplayer-SCIqMFsn"), narrow: false, autoplay: true, showlrc: false, music: { title: "我又想你了", author: "陈信喆", url: "https://hewanyue.com/mp3/woyouxiangnile.mp3", pic: "https://hewanyue.com/mp3/cover/woyouxiangnile.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); &emsp;&emsp;“书生撒下铜钱置于木桌上起身离开，未曾回答。少女见状只心生奇怪，也未曾再问，便转身，从容煎茶。&emsp;&emsp;“书生一路默不作声回到家中书房，文房四宝安静置于桌上，拿起笔挥出：小生不才，未得姑娘青睐，扰姑娘良久，姑娘勿怪，自此所有爱慕之意止于唇齿，匿与年华。饮完这杯酒，还有一杯，就此别过，愿你此生无波澜，敬我余生无悲欢。 &emsp;&emsp;“谁又懂书生的心意？但凡经历过那种暗恋相思之苦，才会理解。 &emsp;&emsp;“他生莫作有情痴，人间无地著相思。下辈子不要做个多情的人，在人世间的相思之苦是难以承受的。&emsp;&emsp;我们都曾经为一个得不到的人付出过，心酸过，伤神过。那种滋味充满着酸甜苦辣，叫做喜欢过你的感觉。 &emsp;&emsp;喜欢一个的人时候，我们每时每刻都会翻看ta的每一条朋友圈动态，也总会把自己给带进去，想看看是不是在说自己，就好像你在做阅读理解一样，做完这些题目后，才发现不是为你准备的。 &emsp;&emsp;Ta为你点个赞，你可以开心到不行，小鹿乱撞。什么啊，为什么就给我点赞，ta也喜欢我吗？Ta为什么不跟我表白？Ta这是暗示我要去表白吗？戏精这个词在我们身上表现的淋漓尽致，永远都不会想到是不是别人手滑点赞，因为我们接受不了这个事实。&emsp;&emsp;天天傻傻地期盼他心血来潮的问候一句，然后装作平淡和缓不慌不忙的应答，其实心里能开心一整天。要是没有秒回我的信息，我会觉得自卑，会觉得ta不喜欢跟我这样的人聊天。我曾经发了句晚安给ta，一晚上醒来七次看手机信息。就是那种可怕的朦朦胧胧的意识，梦里都梦到ta好像回了我信息，然后意识带我从梦境里挣扎出来立马去翻看手机。你看，这大概就是喜欢深入骨髓，竟连梦境都不愿放过了吧。 &emsp;&emsp;看到ta跟其他人走得近玩的好开心时心里酸的要命，却发现自己根本没有吃醋的立场。Ta对你说过的每一句都有认认真真记在心里，反复琢磨，却不敢表现出来。偶遇的时候心里高兴得飞了出来，却只能冷静的压抑，给ta一个体面的招呼,我们太过卑微的去追求我认为的爱情，没有去想结果怎样。&emsp;&emsp;而事实是这样的结果就像一场游戏，你拼命练到满级，可ta却不知何时会删了游戏。 &emsp;&emsp;但暗恋这种感情模式和对方其实关系并不大，更多是自我感动。和真爱没有什么关系，不管付出再多，忍受的再多，也不会有人看见，一个人的独角戏确实很累，你也会变得越来越不像自己，真爱是建立在双方对彼此深入了解的基础上的。 &emsp;&emsp;《大话西游》里有一幕：孙悟空与紫霞仙子在围墙上无言告别，围墙下围着一大帮吃瓜群众看戏，曾经我们的喜欢，会让自己误以为是孙悟空或者是至尊宝，其实都不是，我们终究成了围墙下的那帮人，看着别人的爱情，咀嚼着自己的青春。&emsp;&emsp;不知不觉，时间过了很久，我们已经渐渐明白在机场里等船是不会有结果的，有些人我们也不必再等。换个角度看，彼此幸福或许才是最好的结局，未曾拥有的不是遗憾，相反却是青春的美好。 &emsp;&emsp;哪一天你回过头看，微笑着对自己说道：那个人，我曾经喜欢过，很喜欢的那种。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;转载自豆瓣情感私塾&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动备份配置文件脚本（screen后台执行）]]></title>
    <url>%2F%2Fblog%2Fb580c8f5.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux中配置文件很多，各种需要设置的各种参数很多，有些自定义选项为了方便使用，都会自己修改使用，不过有时候配置文件或者用户参数属性不小心误删掉或者日后想找回当时的参数设置，没有备份肯定是不行的，所以闲暇之余自己写了一个专门备份/etc目录的脚本，以备不时之需。&emsp;&emsp;下面贴代码~ 12345678910111213141516#!/bin/bashecho "Backup is start!" #显示备份开始ScreenName=$"backup" #设置变量定义窗口名screen -dmS $ScreenName #创建一个出于断开模式下的窗口并指定名字screen -S $ScreenName -p 0 -X stuff $"\cp -ap /etc /date/back`date +%F`" #向窗口传递命令备份/etc目录且命名为当前日期screen -S $ScreenName -p 0 -X stuff $'\n' #执行命令，相当于回车echo "backing up，please wait~" #等待备份完成，并提示等待screen -S $ScreenName -p 0 -X stuff $'exit' #备份完后传递退出窗口命令screen -S $ScreenName -p 0 -X stuff $'\n' #执行命令echo "Backup is finshed!" #提示备份完成，脚本结束。 &emsp;&emsp;之前写的脚本总是在创建完screen就停住了，之后的命令没法自动执行，必须Ctrl+A+D暂离screen之后才可以继续执行，不过这样就没法实现自动的初衷了。后来转换思路打算用screen -X的选项从原shell向screen中传递命令却总是失败，后来是参考了大神关于screen传递命令的方法（原文链接），才创建成功的。&emsp;&emsp;此脚本原理大体如下：&emsp;&emsp;脚本中执行screen命令，相当于打开了新的shell，而脚本上的命令都在老shell上，要让备份cp命令在screen上的新shell上跑起来，必须采用向新screen传递命令的方法，才可以实现后台备份，无需担心断网断电的问题。 1screen -S $ScreenName -p 0 -X stuff $'cp -ap /etc /date/back`date +%F`' &emsp;&emsp;这条命令单独执行，只会传递在screen中输出cp命令却并不执行，需要screen -S $ScreenName -p 0 -X stuff $&#39;\n&#39;&emsp;&emsp;命令执行时cp命令才会生效。exit命令亦是如此。&emsp;&emsp;各位大佬如果还有别的更好的方法可以实现功能，希望可以多多交流，不吝赐教。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>script</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM编辑器的整理总结]]></title>
    <url>%2F%2Fblog%2F8dcd5ad7.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;VIM是linux中功能强大的文本编辑工具，因为功能强大，所以各种参数快捷键也很复杂，为方便记忆，特整理如下：vim命令基本格式与参数 vim [OPTION] FILE 常见参数： +# :打开文件后，让光标处于第#行，(+ 默认为行尾)。 +/PATTERN :打开文件后，让光标处于第一个被PATTERN匹配到的行的行首。 -b file :以二进制方式打开文件。 -d file1/file2 :比较多个文件的不同。 -m file :以只读方式打开文件。 -e file 或 ex file :直接进入ex模式（扩展命令模式或叫做末行模式）。 vim的几种工作模式 command模式下的光标跳转：字符间跳转：h 左；j下；k 上；l 右。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#command 可以执行#次命令。单词间跳转：w：下一个单词的词首；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e：当前或下一个单词的词尾。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b：当前或前一个单词的词首。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#command 可以执行#次命令。当前页跳转：H：跳转至页首。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;M：跳转至页中间行。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;L：跳转至页底。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zt：将光别所在行移到屏幕顶端；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zz：将光标所在行移到屏幕中间；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zb：将光标所在行移到屏幕低端。行首行尾跳转：^:跳转至行首的第一个非空的字符；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;0:跳转至行首；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$:跳转至行尾。行间移动：#G :移动至第#行行首。（相当于扩展命令模式下 #）&emsp;&emsp;&emsp;&emsp;&emsp; G ：移至最后一行行首。&emsp;&emsp;&emsp;1G 或gg:移至第一行行首。句间移动 : ) : 下一句；&emsp;&emsp;&emsp;&emsp;&emsp;( : 上一句。段间移动 : } : 下一段；&emsp;&emsp;&emsp;&emsp;&emsp;{ : 上一段。翻屏操作：Ctrl+f 向文件尾部翻一屏（向前翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+b 向文件首部翻一屏（向后翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+d 向文件尾部翻半屏（向下翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+u 向文件尾部翻半屏（向上翻屏）； command模式下的字符编辑：x ： 删除（可认为是剪切，并非真的删除）光标处的字符；#x：删除光标处起始的#个字符；p ：在光标所在处的后面插入储存的字符；xp：交换光标所在处的字符及后面字符的位置；~ ： 转换大小写；J ： 删除当前行后的换行符； 替换命令12r ： 替换光标所在处的字符（只能替换一个字符）；R： 切换为REPLACE模式，可持续替换多个字符。 删除命令12345678910d ： 删除命令（可结合光标跳转字符，实现范围删除）；d$: 从光标所在处，删除到行尾；d^: 从光标所在处，删除到非空行首；d0: 从光标所在处，删除到行首；dw: 从光标所在处，删除到下一个单词的词首；de: 从光标所在处，删除到下一个单词的词尾；db: 从光标所在处，删除到前一个单词的词首；dd: 删除光标所在的行；#dd：多行删除；D ： 从当前光标位置一直删除到行尾，等同于d$。 改变命令12345678910c ： 改变命令（与d命令类似，执行删除后进入插入模式）；c$: 从光标所在处，删除到行尾，并进入插入模式；c^: 从光标所在处，删除到非空行首，并进入插入模式；c0: 从光标所在处，删除到行首，并进入插入模式；cw: 从光标所在处，删除到下一个单词的词首，并进入插入模式；ce: 从光标所在处，删除到下一个单词的词尾，并进入插入模式；cb: 从光标所在处，删除到前一个单词的词首，并进入插入模式；cc: 删除光标所在的行，并进入插入模式；#cc：多行删除，并进入插入模式；C ： 从当前光标位置一直删除到行尾，并进入插入模式，等同于c$。 复制命令12345678910y ： 复制(yank)命令（可结合光标跳转字符，实现范围复制）；y$: 从光标所在处，复制到行尾；y^: 从光标所在处，复制到非空行首；y0: 从光标所在处，复制到行首；yw: 从光标所在处，复制到下一个单词的词首；ye: 从光标所在处，复制到下一个单词的词尾；yb: 从光标所在处，复制到前一个单词的词首；yy: 复制光标所在的行；#yy：多行复制； Y ： 从当前光标位置一直复制到行尾，等同于y$。 命令模式下常用用法汇总 效果 #ihello[ESC] 插入“hello”#次 0y$ 复制本行 gU 变为大写 gu 变为小写 di” 当光标在” “之间时，则删除” “的内容 yi( 当光标在( )之间时，则复制( )的内容 vi[ 当光标在[ ]之间时，则选中[ ]的内容 dtx 删除字符直到遇到光标之后的第一个x字符 ytx 复制字符直到遇到光标之后的第一个x字符 撤销更改命令123456u ： 撤销命令（可撤销最近的更改）；#u： 撤销多次之前的更改； U ： 撤销光标落在这行后的所有此行的修改。Ctrl+r:重做最后的撤销，取消撤销。. ： 重复前一个操作。#.： 重复前一个操作#次。 调整文本颜色1Ctrl+v[[031mCOLORCtrl+v[[0m 输出红色COLOR 取消高亮显示1set nohlsearch 取消搜索后的高亮显示]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不忘初心，方得始终]]></title>
    <url>%2F%2Fblog%2Fb84a93e4.html</url>
    <content type="text"><![CDATA[奔跑吧年轻人 &emsp;&emsp;你走了几年弯路了，也迷茫了好久了，已经落后很远了，甚至也已不再年轻了，不能再选择安逸了！ &emsp;&emsp;你已经不是一个人了，妻子要靠你，孩子也要长大了，父母也要老了，生活上你已经是唯一的支撑了！ &emsp;&emsp;生活已经如此了，唯有努力奔跑，才不会被压倒；选择已经如此了，唯有努力学习，才能不虚此行！ &emsp;&emsp;现状就是这样了，后悔没用，你得变得更好！ 拼搏吧挑战者&emsp;&emsp;你敢于跳出自己的舒适区，来北京从零开始，这已经是一个巨大的成功，同时这也是一个巨大的挑战，爱挑战的你，绝对不会轻易认输，难道不是吗？你会永远相信，你是最棒的，你可以做到你想做好的任何事。&emsp;&emsp;趁自己还年轻。趁此时还不晚，去拼一下，为了那一切的一切，将来的你，一定会感激现在拼命的自己！ 坚持吧追梦人&emsp;&emsp;从来没有人可以轻易成功，不经历挫折，怎么能成长，不经历磨砺，怎么能成器，不经历风雨，怎能见彩虹！&emsp;&emsp;遇到挫折与痛苦，不要放弃，想一想自己，当初为什么要来这里？&emsp;&emsp;既然选择了远方，便只顾风雨兼程！]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>初心不负</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下find命令的一般用法。]]></title>
    <url>%2F%2Fblog%2Fbc40fcc0.html</url>
    <content type="text"><![CDATA[find和locate介绍在linux中，查找文件一般使用locate和find，locate是根据事先构建好的缩影库或者数据库中的数据查找文件名（非实时，速度快，模糊查找），而find作为一个实时查找命令，通过遍历指定起始路径下文件系统层级结构完成文件查找，功能更加强大（实时查找，速度略慢，精确查找）。 find 命令一般用法find [OPTIONS] [查找起始路径] [查找条件] [处理动作][查找起始路径] ：制定具体搜索目标起始路径；默认为当前目录。[查找条件]：指定的查找标准，可以根据文件名，大小，类型，从属关系，时间戳，权限等标准进行；默认为找出指定目录下的所有文件。[处理动作]：对符合查找条件的文件做出的操作，例如删除等操作；默认为输出至标准输出。 查找条件 根据文件名查找：-name，-iname（不区分文件名中的大小写） ps：不支持正则表达式，支持globe风格的通配符如*、?、[]、[^] **根据文件大小查找**：-size (+/-) #UNIT 常用单位：c、k、M、G#UNIT :(#-1,#] 为精确查找#大小的文件（大于#-1大小的文件数值显示为#也符合）-#UNIT:[0,#-1] 为查找小于等于#-1大小的文件+#UNTI:(#,∞)为查找大于#大小的文件 **根据文件类型查找**： -type [文件类型] f：普通文件 d：目录文件 l：符号链接文件 b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 **根据从属关系查找**： -user USERNAME 或 -uid UID -group GROUPNAME 或 -gid GID 查找无属主属组文件：-nouser , -nogroup **根据时间戳查找**： 以“天”为单位：-atime(访问时间)，-mtime(修改时间)（指文件内容修改），-ctime(改变时间)（指权限及从属关系等修改） 以“分钟”为单位：-amin(访问时间)，-mmin(修改时间)（指文件内容修改），-cmin(改变时间)（指权限及从属关系等修改） -atime (+/-) # ，其中#为以现在开始向过去计时的某时间数值。 #：[#，#-1) -#：(#,0] +#：(-∞,#-1) ![ #：[#，#-1) -#：(#,0] +#：(-∞,#-1)](https://img-blog.csdnimg.cn/20190505164447686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70) 根据权限查找 -perm mode 指明确定权限； -perm /mode 任何一类用户(u,g,o)的权限中的任何一项(r,w,x)符合条件即满足； -perm -mode 每一个用户(u,g,o)的权限中的每一项(r,w,x)都同时符合条件即满足。 权限 二进制 八进制 - - - 0 0 0 0 - - x 0 0 1 1 - w - 0 1 0 2 - w x 0 1 1 3 r - - 1 0 0 4 r - x 1 0 1 5 r w - 1 1 0 6 r w x 1 1 1 7 mode形式 &emsp;可以为 -perm /220 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;也可以为-perm /u+w,g+w 或 -perm /u=w,g=w 组合条件查找：同时满足：与：-a，-and;默认满足任一：或：-o，-or不满足：非：-not，! #]find /… ! A -a ! B →→ #]find /… ! ( A -o B ) 或 #]find /… -not ( A -o B )#]find /… ! A -o ! B →→ #]find /… ! ( A -a B ) 或 #]find /… -not ( A -a B ) 处理动作 -print：输出至标准输出；默认动作-ls：类似对查找到的文件执行“ls-l”-delete：删除查找到的文件-fls /PATH/TO/SOMEFILE 将查找到的文件信息长格式保存至指定路径。-ok COMMAND {} ; 对找到的每个文件执行COMMAND命令（可能需要确认）-exec COMMAND {} ; 对找到的每个文件执行COMMAND命定（无需确认）ps：find传递查找到的文件路径之后面的命令时。实现查找出所有符合的文件路径，并一次性传递给后面的命令。但是有些命令不能接受过长的参数，此时命令执行会失效，可用管道find /… | xargs COMMAND执行。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>find命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2Fblog%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
