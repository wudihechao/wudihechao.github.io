<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的一键个性化系统脚本]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%88%91%E7%9A%84%E4%B8%80%E9%94%AE%E4%B8%AA%E6%80%A7%E5%8C%96%E7%B3%BB%E7%BB%9F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;经常要把虚拟机上的系统搞崩，总是各种报错，有次yum安装gcc程序都报错，一旦折腾半天解决不了，只好选择最笨却最有效的方法——还原vrm虚拟机的快照！可是还原快照到干净系统，就导致之前做的喜欢的配置又都没了 还要去慢慢设置开机图案、别名以及各种环境变量比较麻烦，于是就费了点时间，写了下面这个脚本，每次都可以一键实现让新系统恢复自己当初个性化的各种设置。&emsp;&emsp;先传效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#!/bin/bashread -p &quot;please input a name for the address:&quot; USERDIR#输入用户名，方便在/etc目录下存放生成的配置文件[ -a /etc/$USERDIR ] &amp;&amp; [ -d /etc/$USERDIR ] ||&#123; \rm -rf /etc/$USERDIR; mkdir /etc/$USERDIR; &#125;#mkdir /etc/$USERDIR#生成配置文件目录，若已存在则直接使用此目录cat &gt; /etc/$USERDIR/motd &lt;&lt; ENDoooooooooooo oooooooooo. ooooooooooooo oooo oooooooooo. . 8&apos; 888 &apos;8 &apos;888&apos; &apos;Y8b 8&apos; 888 &apos;8 &apos;888 &apos;888&apos; &apos;Y8b .o8 888 &apos;ooooo. 888 888 .ooooo. 888 888 .oo. .ooooo. 888 888 .ooooo. .oooo.o .o888oo 888 d88&apos; &apos;88b 888oooo888&apos; d88&apos; &apos;88b 888 888P&quot;Y88b d88&apos; &apos;88b 888oooo888&apos; d88&apos; &apos;88b d88( &quot;8 888 888 888 888 888 &apos;88b 888ooo888 888 888 888 888ooo888 888 &apos;88b 888ooo888 &apos;&quot;Y88b. 888 888 888 888 888 .88P 888 .o 888 888 888 888 .o 888 .88P 888 .o o. )88b 888 . o888o &apos;Y8bod8P&apos; o888bood8P&apos; &apos;Y8bod8P&apos; o888o o888o o888o &apos;Y8bod8P&apos; o888bood8P&apos; &apos;Y8bod8P&apos; 8&quot;&apos;888P&apos; &quot;888&quot;END#生成开机欢迎动画，可以随意修改#创建/etc/$USERDIR/login.sh配置文件[ -a /etc/$USERDIR ] &amp;&amp; [ -d /etc/$USERDIR ]&amp;&amp; [ -w /etc/$USERDIR ] ||&#123; \rm -rf /etc/$USERDIR; mkdir /etc/$USERDIR; &#125;#确认文件目录存在且可用,开始写配置文件。#因为水平有限，不知道怎么把命令以及变量通过脚本生成到新脚本里#只能采用最笨的方法——一行一行的写入，希望各位大佬可以指点一二。echo &apos;#!/bin/bash &apos;&gt;/etc/$USERDIR/login.shecho &apos;cat /etc/$USERDIR/motd&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;date=`date &quot;+%F %T&quot;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;head=&quot;System information as of: $date&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;kernel=`uname -r`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;hostname=`echo $HOSTNAME`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Cpu load&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load1=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $1&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load5=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;load15=`cat /proc/loadavg | awk &apos;&quot;&apos;&quot;&apos;&#123;print $3&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#System uptime&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;uptime=`cat /proc/uptime | cut -f1 -d.`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upDays=$((uptime/60/60/24))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upHours=$((uptime/60/60%24))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upMins=$((uptime/60%60))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;upSecs=$((uptime%60))&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;up_lastime=`date -d &quot;$(awk -F. &apos;&quot;&apos;&quot;&apos;&#123;print $1&#125;&apos;&quot;&apos;&quot;&apos; /proc/uptime) second ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Memory Usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;mem_usage=`free -m | awk &apos;&quot;&apos;&quot;&apos;/Mem:/&#123;total=$2&#125; /buffers\/cache/ &#123;used=$3&#125; END &#123;printf(&quot;%3.2f%%&quot;,used/total*100)&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;swap_usage=`free -m | awk &apos;&quot;&apos;&quot;&apos;/Swap/&#123;printf &quot;%.2f%&quot;,$3/$2*100&#125;&apos;&quot;&apos;&quot;&apos;`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Processes&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;processes=`ps aux | wc -l`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#User&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;users=`users | wc -w`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;USER=`whoami`&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#System fs usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;Filesystem=$(df -h | awk &apos;&quot;&apos;&quot;&apos;/^\/dev/&#123;print $6&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;#Interfaces&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;INTERFACES=$(ip -4 ad | grep &apos;&quot;&apos;&quot;&apos;state &apos;&quot;&apos;&quot;&apos; | awk -F&quot;:&quot; &apos;&quot;&apos;&quot;&apos;!/^[0-9]*: ?lo/ &#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;|grep e)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;$head&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;----------------------------------------------&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Kernel Version:\t%s\n&quot; $kernel&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;HostName:\t%s\n&quot; $hostname&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;System Load:\t%s %s %s\n&quot; $load1, $load5, $load15&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;System Uptime:\t%s &quot;days&quot; %s &quot;hours&quot; %s &quot;min&quot; %s &quot;sec&quot;\n&quot; $upDays $upHours $upMins $upSecs&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Memory Usage:\t%s\t\t\tSwap Usage:\t%s\n&quot; $mem_usage $swap_usage&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Login Users:\t%s\t\t\tWhoami:\t\t%s\n&quot; $users $USER&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Processes:\t%s\n&quot; $processes&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Filesystem\tUsage\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;for f in $Filesystem&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;do&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; Usage=$(df -h | awk &apos;&quot;&apos;&quot;&apos;&#123;if($NF==&quot;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;$f&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&apos;&quot;&apos;&quot;&apos;&quot;) print $5&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; echo -e &quot;$f\t\t$Usage&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;done&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;printf &quot;Interface\tMAC Address\t\tIP Address\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;for i in $INTERFACES&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;do&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; MAC=$(ip ad show dev $i | grep &quot;link/ether&quot; | awk &apos;&quot;&apos;&quot;&apos;&#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; IP=$(ip ad show dev $i | awk &apos;&quot;&apos;&quot;&apos;/inet / &#123;print $2&#125;&apos;&quot;&apos;&quot;&apos;)&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos; printf $i&quot;\t\t&quot;$MAC&quot;\t$IP\n&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;done&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo &quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;&apos;&gt;&gt;/etc/$USERDIR/login.shecho &apos;echo&apos;&gt;&gt;/etc/$USERDIR/login.sh#生成脚本设置常用命令符以及别名及命令历史cat &gt; /etc/profile.d/env.sh &lt;&lt; ENDPS1=&quot;\e[1;36m[\u@\h \W]\\\\$\e[0m&quot;HISTTIMEFORMAT=&quot;%F %T &quot;HISTCONTROL=ignorebothalias rm=&apos;mkdir -p /date/delete/`date +%F`;\mv -t /date/delete/`date +%F` -f&apos;bash /etc/$USERDIR/login.shENDsed -i &apos;s/^alias rm/#&amp;/&apos; ~/.bashrc#取消用户定义的alias rm。#生成VIM的格式脚本cat &gt; ~/.vimrc &lt;&lt; END#!/bin/bash&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle()&quot;&quot;如果文件类型为.sh文件 if &amp;filetype == &apos;sh&apos; call setline(1,&quot;\##########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1,&quot;\# Author: Name &quot;) call append(line(&quot;.&quot;)+2,&quot;\# QQ: xxxxxxxxx&quot;) call append(line(&quot;.&quot;)+3,&quot;\# mail: xxxxxxxxxx@xxx.com&quot;) call append(line(&quot;.&quot;)+4,&quot;\# Description: The test script&quot;) call append(line(&quot;.&quot;)+5,&quot;\# Created Time: &quot;.strftime(&quot;%F %H:%M:%S&quot;)) call append(line(&quot;.&quot;)+6,&quot;\# Copyright（C）: &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;) call append(line(&quot;.&quot;)+7,&quot;\##########################################################################&quot;) call append(line(&quot;.&quot;)+8,&quot;\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+9,&quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot; &gt; Author: Name&quot;) call append(line(&quot;.&quot;)+2, &quot; &gt; Mail: xxxxxxxxxx@xxx.com&quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;)endif if &amp;filetype == &apos;cpp&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+8, &quot;&quot;)endif if &amp;filetype == &apos;c&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;)endif if &amp;filetype == &apos;java&apos; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+7,&quot;&quot;)endif&quot;&quot;新建文件后，自动定位到文件末尾endfuncautocmd BufNewFile * normal GENDmkdir -p /etc/yum.repos.d/backup\mv -f /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup/#禁用已有其他epel源，并做备份。umount /dev/cdrom#[ `cat /etc/fstab|grep -o iso` ]||sed -i &apos;/iso/c\&apos; /etc/fstab #解挂其他光盘CDUUID=`blkid|sed -nr &apos;/sr0/s/.*\bUUID=&quot;([^&quot;]+).*&quot;/\1/p&apos;`CDTYPE=`blkid|sed -nr &apos;/sr0/s/.*\bTYPE=&quot;([^&quot;]+).*&quot;/\1/p&apos;`[ `cat /etc/fstab|grep -o iso` ]||mkdir -p /cdrom #创建光盘目录[ `cat /etc/fstab|grep -o iso` ]||echo -e &quot;UUID=$CDUUID /cdrom $CDTYPE defaults 0 0&quot; &gt;&gt;/etc/fstab #修改fstab文件，方便以后自动挂载光盘#[ `cat /etc/fstab|grep -o iso` ]|| mount -o ro /dev/sr0 /cdrom #挂载光盘#mount -a #挂载光盘mount -o ro /dev/sr0 /cdrom #挂载光盘#生成常用yum源和epel源，这里选用阿里云的cat &gt; /etc/yum.repos.d/cdrom.repo &lt;&lt; END[cdrom]name=cdrom-repobaseurl=file:///cdromgpgcheck=0enabled=1ENDcat &gt; /etc/yum.repos.d/aliyun.repo &lt;&lt; &quot;END&quot;[aliyun]name=aliyun-epelbaseurl=https://mirrors.aliyun.com/epel/$releasever/$basearch/gpgcheck=1gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-7enabled=1END#新建本地及阿里云epel源.#修改网卡配置，根据个人情况修改cat &gt; /etc/sysconfig/network-scripts/ifcfg-ens33 &lt;&lt; ENDTYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=29126291-418f-4a08-b33e-c5cfa659d9b8DEVICE=ens33ONBOOT=yesIPADDR=172.18.32.7PREFIX=16GATEWAY=172.18.0.1DNS1=114.114.114.114ENDsystemctl restart network.service#重启网络服务，让刚才修改的配置生效mkdir -p /date/apps[ -z `cat ~/.bash_profile|grep apps` ] &amp;&amp; echo &apos;PATH=/date/apps:$PATH&apos; &gt;&gt;~/.bash_profile#修改PAT变量，方便以后装软件。`` &emsp;&emsp;水平有限，都是简单代码，留存记录，方便日后查看整理改进。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>script</tag>
        <tag>init</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM编辑器的整理总结]]></title>
    <url>%2F2019%2F10%2F04%2FVIM%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;VIM是linux中功能强大的文本编辑工具，因为功能强大，所以各种参数快捷键也很复杂，为方便记忆，特整理如下：vim命令基本格式与参数 vim [OPTION] FILE 常见参数： +# :打开文件后，让光标处于第#行，(+ 默认为行尾)。 +/PATTERN :打开文件后，让光标处于第一个被PATTERN匹配到的行的行首。 -b file :以二进制方式打开文件。 -d file1/file2 :比较多个文件的不同。 -m file :以只读方式打开文件。 -e file 或 ex file :直接进入ex模式（扩展命令模式或叫做末行模式）。 vim的几种工作模式 command模式下的光标跳转：字符间跳转：h 左；j下；k 上；l 右。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#command 可以执行#次命令。单词间跳转：w：下一个单词的词首；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e：当前或下一个单词的词尾。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b：当前或前一个单词的词首。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#command 可以执行#次命令。当前页跳转：H：跳转至页首。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;M：跳转至页中间行。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;L：跳转至页底。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zt：将光别所在行移到屏幕顶端；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zz：将光标所在行移到屏幕中间；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;zb：将光标所在行移到屏幕低端。行首行尾跳转：^:跳转至行首的第一个非空的字符；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;0:跳转至行首；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$:跳转至行尾。行间移动：#G :移动至第#行行首。（相当于扩展命令模式下 #）&emsp;&emsp;&emsp;&emsp;&emsp; G ：移至最后一行行首。&emsp;&emsp;&emsp;1G 或gg:移至第一行行首。句间移动 : ) : 下一句；&emsp;&emsp;&emsp;&emsp;&emsp;( : 上一句。段间移动 : } : 下一段；&emsp;&emsp;&emsp;&emsp;&emsp;{ : 上一段。翻屏操作：Ctrl+f 向文件尾部翻一屏（向前翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+b 向文件首部翻一屏（向后翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+d 向文件尾部翻半屏（向下翻屏）；&emsp;&emsp;&emsp;&emsp;&emsp;Ctrl+u 向文件尾部翻半屏（向上翻屏）； command模式下的字符编辑： x ： 删除（可认为是剪切，并非真的删除）光标处的字符；#x：删除光标处起始的#个字符；p ：在光标所在处的后面插入储存的字符；xp：交换光标所在处的字符及后面字符的位置；~ ： 转换大小写；J ： 删除当前行后的换行符； 替换命令12r ： 替换光标所在处的字符（只能替换一个字符）；R： 切换为REPLACE模式，可持续替换多个字符。 删除命令12345678910d ： 删除命令（可结合光标跳转字符，实现范围删除）；d$: 从光标所在处，删除到行尾；d^: 从光标所在处，删除到非空行首；d0: 从光标所在处，删除到行首；dw: 从光标所在处，删除到下一个单词的词首；de: 从光标所在处，删除到下一个单词的词尾；db: 从光标所在处，删除到前一个单词的词首；dd: 删除光标所在的行；#dd：多行删除；D ： 从当前光标位置一直删除到行尾，等同于d$。 改变命令12345678910c ： 改变命令（与d命令类似，执行删除后进入插入模式）；c$: 从光标所在处，删除到行尾，并进入插入模式；c^: 从光标所在处，删除到非空行首，并进入插入模式；c0: 从光标所在处，删除到行首，并进入插入模式；cw: 从光标所在处，删除到下一个单词的词首，并进入插入模式；ce: 从光标所在处，删除到下一个单词的词尾，并进入插入模式；cb: 从光标所在处，删除到前一个单词的词首，并进入插入模式；cc: 删除光标所在的行，并进入插入模式；#cc：多行删除，并进入插入模式；C ： 从当前光标位置一直删除到行尾，并进入插入模式，等同于c$。 复制命令12345678910y ： 复制(yank)命令（可结合光标跳转字符，实现范围复制）；y$: 从光标所在处，复制到行尾；y^: 从光标所在处，复制到非空行首；y0: 从光标所在处，复制到行首；yw: 从光标所在处，复制到下一个单词的词首；ye: 从光标所在处，复制到下一个单词的词尾；yb: 从光标所在处，复制到前一个单词的词首；yy: 复制光标所在的行；#yy：多行复制； Y ： 从当前光标位置一直复制到行尾，等同于y$。 命令模式下常用用法汇总 效果 #ihello[ESC] 插入“hello”#次 0y$ 复制本行 gU 变为大写 gu 变为小写 di” 当光标在” “之间时，则删除” “的内容 yi( 当光标在( )之间时，则复制( )的内容 vi[ 当光标在[ ]之间时，则选中[ ]的内容 dtx 删除字符直到遇到光标之后的第一个x字符 ytx 复制字符直到遇到光标之后的第一个x字符 ##### 撤销更改命令 123456u ： 撤销命令（可撤销最近的更改）；#u： 撤销多次之前的更改； U ： 撤销光标落在这行后的所有此行的修改。Ctrl+r:重做最后的撤销，取消撤销。. ： 重复前一个操作。#.： 重复前一个操作#次。 调整文本颜色1Ctrl+v[[031mCOLORCtrl+v[[0m 输出红色COLOR 取消高亮显示1set nohlsearch 取消搜索后的高亮显示]]></content>
      <tags>
        <tag>linux</tag>
        <tag>vim编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[由闷骚书生与假正经小姐的古典爱情故事说起]]></title>
    <url>%2F2019%2F08%2F01%2F%E7%94%B1%E9%97%B7%E9%AA%9A%E4%B9%A6%E7%94%9F%E4%B8%8E%E5%81%87%E6%AD%A3%E7%BB%8F%E5%B0%8F%E5%A7%90%E7%9A%84%E5%8F%A4%E5%85%B8%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;城南外湖畔边，天气下着小雨，刮起微风，吹起茶铺门前的风铃叮铃作响让人昏昏欲睡，但铺子里舒缓轻柔的抚琴声却给人自然清醒的感觉，立锥之地，瞥一眼便一览无遗，简单的陈设透露出古朴淡雅，一长发清秀女子品一壶热茶望着这淅淅沥沥的小雨。&emsp;&emsp;“姑娘有心事？”一身穿白袍英俊书生抿嘴品茶问到。少女：“公子与城北唐公子可是熟识？” &emsp;&emsp;“书生：“我与他乃世交，有何事？”少女：“那下次你与他一同前来我这品茶可好？”书生：“他不喜品茶。”少女：“无妨，那公子可知他喜欢什么，我可以慢慢学。”书生：“我其实也不喜品茶。”少女：“公子莫说谎，不喜为何天天早晨都跑我这茶铺。” &emsp;&emsp;“书生撒下铜钱置于木桌上起身离开，未曾回答。少女见状只心生奇怪，也未曾再问，便转身，从容煎茶。&emsp;&emsp;“书生一路默不作声回到家中书房，文房四宝安静置于桌上，拿起笔挥出：小生不才，未得姑娘青睐，扰姑娘良久，姑娘勿怪，自此所有爱慕之意止于唇齿，匿与年华。饮完这杯酒，还有一杯，就此别过，愿你此生无波澜，敬我余生无悲欢。 &emsp;&emsp;“谁又懂书生的心意？但凡经历过那种暗恋相思之苦，才会理解。 &emsp;&emsp;“他生莫作有情痴，人间无地著相思。下辈子不要做个多情的人，在人世间的相思之苦是难以承受的。&emsp;&emsp;我们都曾经为一个得不到的人付出过，心酸过，伤神过。那种滋味充满着酸甜苦辣，叫做喜欢过你的感觉。 &emsp;&emsp;喜欢一个的人时候，我们每时每刻都会翻看ta的每一条朋友圈动态，也总会把自己给带进去，想看看是不是在说自己，就好像你在做阅读理解一样，做完这些题目后，才发现不是为你准备的。 &emsp;&emsp;Ta为你点个赞，你可以开心到不行，小鹿乱撞。什么啊，为什么就给我点赞，ta也喜欢我吗？Ta为什么不跟我表白？Ta这是暗示我要去表白吗？戏精这个词在我们身上表现的淋漓尽致，永远都不会想到是不是别人手滑点赞，因为我们接受不了这个事实。&emsp;&emsp;天天傻傻地期盼他心血来潮的问候一句，然后装作平淡和缓不慌不忙的应答，其实心里能开心一整天。要是没有秒回我的信息，我会觉得自卑，会觉得ta不喜欢跟我这样的人聊天。我曾经发了句晚安给ta，一晚上醒来七次看手机信息。就是那种可怕的朦朦胧胧的意识，梦里都梦到ta好像回了我信息，然后意识带我从梦境里挣扎出来立马去翻看手机。你看，这大概就是喜欢深入骨髓，竟连梦境都不愿放过了吧。 &emsp;&emsp;看到ta跟其他人走得近玩的好开心时心里酸的要命，却发现自己根本没有吃醋的立场。Ta对你说过的每一句都有认认真真记在心里，反复琢磨，却不敢表现出来。偶遇的时候心里高兴得飞了出来，却只能冷静的压抑，给ta一个体面的招呼,我们太过卑微的去追求我认为的爱情，没有去想结果怎样。&emsp;&emsp;而事实是这样的结果就像一场游戏，你拼命练到满级，可ta却不知何时会删了游戏。 &emsp;&emsp;但暗恋这种感情模式和对方其实关系并不大，更多是自我感动。和真爱没有什么关系，不管付出再多，忍受的再多，也不会有人看见，一个人的独角戏确实很累，你也会变得越来越不像自己，真爱是建立在双方对彼此深入了解的基础上的。 &emsp;&emsp;《大话西游》里有一幕：孙悟空与紫霞仙子在围墙上无言告别，围墙下围着一大帮吃瓜群众看戏，曾经我们的喜欢，会让自己误以为是孙悟空或者是至尊宝，其实都不是，我们终究成了围墙下的那帮人，看着别人的爱情，咀嚼着自己的青春。&emsp;&emsp;不知不觉，时间过了很久，我们已经渐渐明白在机场里等船是不会有结果的，有些人我们也不必再等。换个角度看，彼此幸福或许才是最好的结局，未曾拥有的不是遗憾，相反却是青春的美好。 &emsp;&emsp;哪一天你回过头看，微笑着对自己说道：那个人，我曾经喜欢过，很喜欢的那种。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;转载自豆瓣情感私塾&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动备份配置文件脚本（screen后台执行）]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%EF%BC%88screen%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux中配置文件很多，各种需要设置的各种参数很多，有些自定义选项为了方便使用，都会自己修改使用，不过有时候配置文件或者用户参数属性不小心误删掉或者日后想找回当时的参数设置，没有备份肯定是不行的，所以闲暇之余自己写了一个专门备份/etc目录的脚本，以备不时之需。&emsp;&emsp;下面贴代码~ 12345678910111213141516#!/bin/bashecho &quot;Backup is start!&quot; #显示备份开始ScreenName=$&quot;backup&quot; #设置变量定义窗口名screen -dmS $ScreenName #创建一个出于断开模式下的窗口并指定名字screen -S $ScreenName -p 0 -X stuff $&quot;\cp -ap /etc /date/back`date +%F`&quot; #向窗口传递命令备份/etc目录且命名为当前日期screen -S $ScreenName -p 0 -X stuff $&apos;\n&apos; #执行命令，相当于回车echo &quot;backing up，please wait~&quot; #等待备份完成，并提示等待screen -S $ScreenName -p 0 -X stuff $&apos;exit&apos; #备份完后传递退出窗口命令screen -S $ScreenName -p 0 -X stuff $&apos;\n&apos; #执行命令echo &quot;Backup is finshed!&quot; #提示备份完成，脚本结束。 &emsp;&emsp;之前写的脚本总是在创建完screen就停住了，之后的命令没法自动执行，必须Ctrl+A+D暂离screen之后才可以继续执行，不过这样就没法实现自动的初衷了。后来转换思路打算用screen -X的选项从原shell向screen中传递命令却总是失败，后来是参考了大神关于screen传递命令的方法（原文链接），才创建成功的。&emsp;&emsp;此脚本原理大体如下：&emsp;&emsp;脚本中执行screen命令，相当于打开了新的shell，而脚本上的命令都在老shell上，要让备份cp命令在screen上的新shell上跑起来，必须采用向新screen传递命令的方法，才可以实现后台备份，无需担心断网断电的问题。 -S $ScreenName -p 0 -X stuff $'cp -ap/date/back`date +%F`'```12&amp;emsp;&amp;emsp;这条命令单独执行，只会传递在screen中输出cp命令却并不执行，需要```screen -S $ScreenName -p 0 -X stuff $&apos;\n&apos; &emsp;&emsp;命令执行时cp命令才会生效。exit命令亦是如此。&emsp;&emsp;各位大佬如果还有别的更好的方法可以实现功能，希望可以多多交流，不吝赐教。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>backup</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不忘初心，方得始终]]></title>
    <url>%2F2019%2F07%2F16%2F%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%EF%BC%8C%E6%96%B9%E5%BE%97%E5%A7%8B%E7%BB%88%2F</url>
    <content type="text"><![CDATA[奔跑吧年轻人 &emsp;&emsp;你走了几年弯路了，也迷茫了好久了，已经落后很远了，甚至也已不再年轻了，不能再选择安逸了！ &emsp;&emsp;你已经不是一个人了，妻子要靠你，孩子也要长大了，父母也要老了，生活上你已经是唯一的支撑了！ &emsp;&emsp;生活已经如此了，唯有努力奔跑，才不会被压倒；选择已经如此了，唯有努力学习，才能不虚此行！ &emsp;&emsp;现状就是这样了，后悔没用，你得变得更好！ 拼搏吧挑战者&emsp;&emsp;你敢于跳出自己的舒适区，来北京从零开始，这已经是一个巨大的成功，同时这也是一个巨大的挑战，爱挑战的你，绝对不会轻易认输，难道不是吗？你会永远相信，你是最棒的，你可以做到你想做好的任何事。&emsp;&emsp;趁自己还年轻。趁此时还不晚，去拼一下，为了那一切的一切，将来的你，一定会感激现在拼命的自己！ 坚持吧追梦人&emsp;&emsp;从来没有人可以轻易成功，不经历挫折，怎么能成长，不经历磨砺，怎么能成器，不经历风雨，怎能见彩虹！&emsp;&emsp;遇到挫折与痛苦，不要放弃，想一想自己，当初为什么要来这里？&emsp;&emsp;既然选择了远方，便只顾风雨兼程！]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>初心不负</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下find命令的一般用法。]]></title>
    <url>%2F2019%2F05%2F05%2FLinux%E4%B8%8Bfind%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95%E3%80%82%2F</url>
    <content type="text"><![CDATA[find和locate介绍在linux中，查找文件一般使用locate和find，locate是根据事先构建好的缩影库或者数据库中的数据查找文件名（非实时，速度快，模糊查找），而find作为一个实时查找命令，通过遍历指定起始路径下文件系统层级结构完成文件查找，功能更加强大（实时查找，速度略慢，精确查找）。 find 命令一般用法find [OPTIONS] [查找起始路径] [查找条件] [处理动作][查找起始路径] ：制定具体搜索目标起始路径；默认为当前目录。[查找条件]：指定的查找标准，可以根据文件名，大小，类型，从属关系，时间戳，权限等标准进行；默认为找出指定目录下的所有文件。[处理动作]：对符合查找条件的文件做出的操作，例如删除等操作；默认为输出至标准输出。 查找条件 根据文件名查找：-name，-iname（不区分文件名中的大小写） ps：不支持正则表达式，支持globe风格的通配符如*、?、[]、[^] **根据文件大小查找**：-size (+/-) #UNIT 常用单位：c、k、M、G#UNIT :(#-1,#] 为精确查找#大小的文件（大于#-1大小的文件数值显示为#也符合）-#UNIT:[0,#-1] 为查找小于等于#-1大小的文件+#UNTI:(#,∞)为查找大于#大小的文件 **根据文件类型查找**： -type [文件类型] f：普通文件 d：目录文件 l：符号链接文件 b：块设备文件 c：字符设备文件 p：管道文件 s：套接字文件 **根据从属关系查找**： -user USERNAME 或 -uid UID -group GROUPNAME 或 -gid GID 查找无属主属组文件：-nouser , -nogroup **根据时间戳查找**： 以“天”为单位：-atime(访问时间)，-mtime(修改时间)（指文件内容修改），-ctime(改变时间)（指权限及从属关系等修改） 以“分钟”为单位：-amin(访问时间)，-mmin(修改时间)（指文件内容修改），-cmin(改变时间)（指权限及从属关系等修改） -atime (+/-) # ，其中#为以现在开始向过去计时的某时间数值。 #：[#，#-1) -#：(#,0] +#：(-∞,#-1) ![ #：[#，#-1) -#：(#,0] +#：(-∞,#-1)](https://img-blog.csdnimg.cn/20190505164447686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70) 根据权限查找 -perm mode 指明确定权限； -perm /mode 任何一类用户(u,g,o)的权限中的任何一项(r,w,x)符合条件即满足； -perm -mode 每一个用户(u,g,o)的权限中的每一项(r,w,x)都同时符合条件即满足。 权限 二进制 八进制 - - - 0 0 0 0 - - x 0 0 1 1 - w - 0 1 0 2 - w x 0 1 1 3 r - - 1 0 0 4 r - x 1 0 1 5 r w - 1 1 0 6 r w x 1 1 1 7 mode形式 &emsp;可以为 -perm /220 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;也可以为-perm /u+w,g+w 或 -perm /u=w,g=w 组合条件查找：同时满足：与：-a，-and;默认满足任一：或：-o，-or不满足：非：-not，! #]find /… ! A -a ! B →→ #]find /… ! ( A -o B ) 或 #]find /… -not ( A -o B )#]find /… ! A -o ! B →→ #]find /… ! ( A -a B ) 或 #]find /… -not ( A -a B ) 处理动作 -print：输出至标准输出；默认动作-ls：类似对查找到的文件执行“ls-l”-delete：删除查找到的文件-fls /PATH/TO/SOMEFILE 将查找到的文件信息长格式保存至指定路径。-ok COMMAND {} ; 对找到的每个文件执行COMMAND命令（可能需要确认）-exec COMMAND {} ; 对找到的每个文件执行COMMAND命定（无需确认）ps：find传递查找到的文件路径之后面的命令时。实现查找出所有符合的文件路径，并一次性传递给后面的命令。但是有些命令不能接受过长的参数，此时命令执行会失效，可用管道find /… | xargs COMMAND执行。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>find命令</tag>
      </tags>
  </entry>
</search>
