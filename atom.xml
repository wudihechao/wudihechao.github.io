<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BOHC!</title>
  
  <subtitle>blog of hechao!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wudihechao.github.io/"/>
  <updated>2020-01-26T15:43:19.806Z</updated>
  <id>https://wudihechao.github.io/</id>
  
  <author>
    <name>Hechao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux使用vmware虚拟机玩LOL</title>
    <link href="https://wudihechao.github.io//blog/c1add9f7.html"/>
    <id>https://wudihechao.github.io//blog/c1add9f7.html</id>
    <published>2020-01-26T15:16:49.000Z</published>
    <updated>2020-01-26T15:43:19.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;自从入坑linux系统，便越陷越深，操作起来确实方便很多。不过linux系统有一个致命的问题，那就是没法玩游戏！<br><a id="more"></a><br>&emsp;&emsp;平常也有罢了，不玩也就算了。不过这一阵子，恰逢春节，却又赶上疫情不能出门，几乎排行榜所有的电影都扫遍了，无可奈何又想起了早就删除了的英雄联盟。<br>&emsp;&emsp;但是现在系统已经是Deepin系统了。用起来很简洁，也比较方便，桌面也很漂亮，给大家看看桌面哈～<br><img src="https://img-blog.csdnimg.cn/20200126220032514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="vmware"><a href="#vmware" class="headerlink" title="vmware"></a>vmware</h2><p>&emsp;&emsp;言归正传，我们需要安装一个window的虚拟机。因为本地已有vmware，所以直接用vmware创建。<br>&emsp;&emsp;没有安装vmware的去官网下载一个linux版本的，网上找一个个激化码就可以正常使用了。链接为<code>https://download3.vmware.com/software/wkst/file/VMware-Workstation-Full-15.5.1-15018445.x86_64.bundle</code>。可以用迅雷或者谷歌自带下载工具下载，也可以用命令行<code>wget</code>命令下载。<br>&emsp;&emsp;这是一个可执行程序文件，在命令行中对此文件，加执行权限，执行<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./VMware-Workstation-Full<span class="number">-15.5</span><span class="number">.1</span><span class="number">-15018445.</span>x86_64.bundle</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;安装完毕VMware后，找到window的iso镜像包（要是没有，提前去下载一个）正常安装window系统即可。至少分配4个G内存，开启3D选项（一般是默认开启的）。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="3D支持"><a href="#3D支持" class="headerlink" title="3D支持"></a>3D支持</h3><p>&emsp;&emsp;开机之后很有可能会vmware的又下角会报错，提示3D不可用<br><img src="https://img-blog.csdnimg.cn/20200126223536120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;需要我们进入虚拟机的安装目录，找到vmx文件，<code>vim</code>打开编辑，在最后加一行<code>mks.gl.allowBlacklistedDrivers = &quot;TRUE&quot;</code>来强制开启3D加速。再开启虚拟机，就不会报<code>No 3D support is available from host</code>了。如果报<code>mks.gl.allowBlacklistedDrivers</code>之类的错误，可能是引号格式不正确，重新检查修改一下引号就可以了。</p><h3 id="game-error-directx"><a href="#game-error-directx" class="headerlink" title="game_error_directx"></a>game_error_directx</h3><p>&emsp;&emsp;当我下载好wegame，安装好英雄联盟客户端，也能正常组队及开始游戏时，载入进度条到100%后，意外给我弹一个这个报错。<br><img src="https://img-blog.csdnimg.cn/20200126224807765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;然后游戏也无法重连了，一直报错<code>game_error_directx</code>。<br><img src="https://img-blog.csdnimg.cn/20200126224914381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;这上来就坑队友了啊，我也很无奈。赶紧用directx修复工具修复一下directx，果然可以进入游戏了。（首先确保第一步的3D支持已开启，否则单独用修复工具修复是无效的）</p><h3 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h3><p>&emsp;&emsp;进入游戏后，我发现虽然可以流畅游戏，也没有延迟，问题是每隔几分钟就会有个10秒钟左右的画面卡顿，甚至掉线，然后屏幕就黑了。。。这谁顶得住啊。只能停下，赶紧排查原因。<br>&emsp;&emsp;开始以为是网络卡顿，不过检查了下，发现虚拟机的网络一直没有掉，于是猜测是虚拟机的CPU不响应，于是检测了下CPU的使用率，发现果然在卡顿的几秒钟内，宿主机的CPU使用率很高，难道是有进程占用了CPU，导致虚拟机的程序无法得到响应？<br>&emsp;&emsp;于是查找CPU优化，初步拟定方向是，将CPU核心绑定至虚拟机进程，修改虚拟机优先级等等。不过linux版的VMware没法设置优先级，并不像window版本的可以设置优先级。<br><img src="https://img-blog.csdnimg.cn/20200126230139406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;于是，可优化选项，只有设置预留内存，以及不使用交换分区了。这时我注意到，默认是使用交换分区的，可能导致我不时卡顿的元凶就是这里了。不过无法直接修改内存选项，提示<code>You must be running Workstation as root to change these preferences.</code>。<br>&emsp;&emsp;于是，只能从命令行切换root用户权限执行vmware，修改后（将默认的Allow some virtual machine memory to be swapped改为第一个），在用普通用户启动vmware，发现果然是继续生效的。<img src="https://img-blog.csdnimg.cn/20200126230657876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;再次启动虚拟机，进入游戏之后，果然再也没有出现卡顿了。</p><h3 id="关闭工具条"><a href="#关闭工具条" class="headerlink" title="关闭工具条"></a>关闭工具条</h3><p>&emsp;&emsp;在虚拟机中全屏之后，上面还隐藏一个白色的工具条，打游戏偶尔会点到就会切出去，很影响游戏体验。于是我们要想办法将他去掉。<br>&emsp;&emsp;在Edit，Preferences选项下的Display标签中，将全屏显示选项栏这个选项勾选取消。<br><img src="https://img-blog.csdnimg.cn/20200126231230154.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200126231141489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;现在就可以愉快的进行游戏了，你们能看出来我是在虚拟机中游戏吗<br><img src="https://img-blog.csdnimg.cn/2020012623140020.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;自从入坑linux系统，便越陷越深，操作起来确实方便很多。不过linux系统有一个致命的问题，那就是没法玩游戏！&lt;br&gt;
    
    </summary>
    
      <category term="故障记录" scheme="https://wudihechao.github.io/categories/%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="linux" scheme="https://wudihechao.github.io/tags/linux/"/>
    
      <category term="vmware" scheme="https://wudihechao.github.io/tags/vmware/"/>
    
      <category term="LOL" scheme="https://wudihechao.github.io/tags/LOL/"/>
    
  </entry>
  
  <entry>
    <title>K8s进阶——java集群服务搭建</title>
    <link href="https://wudihechao.github.io//blog/a9b6fadd.html"/>
    <id>https://wudihechao.github.io//blog/a9b6fadd.html</id>
    <published>2020-01-14T13:36:56.000Z</published>
    <updated>2020-01-19T16:28:02.041Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;K8s集群搭建完成后，真正完成我们业务的是那些跑在k8s上的pod们。将业务跑在k8s集群只上，我们可以实现根据负载或者资源利用率动态扩容或者缩容我们的后端服务器，更加灵活高效的利用我们的物理设备，且能够实现服务的高可用及故障自治愈，本文将详细介绍以上的具体实现。<br><a id="more"></a></p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>&emsp;&emsp;本次演示使用主机系统均为ubuntu1804。</p><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">IP</th></tr></thead><tbody><tr><td style="text-align:center">master节点</td><td style="text-align:center">192.168.32.18、192.168.32.19</td></tr><tr><td style="text-align:center">node节点</td><td style="text-align:center">192.168.32.21、192.168.32.22</td></tr><tr><td style="text-align:center">etcd</td><td style="text-align:center">192.168.32.23、192.168.32.24、192.168.32.25</td></tr><tr><td style="text-align:center">harbor</td><td style="text-align:center">192.168.32.20</td></tr><tr><td style="text-align:center">NFS服务器</td><td style="text-align:center">192.168.32.20（复用）</td></tr></tbody></table><p>&emsp;&emsp;如果机器不够，可以选择复用，例如将etcd的三台主机与master主机和harbor主机复用，可以省下来3台主机。推荐node节点的性能高一些，因为一般之后的pod都将运行在node节点上，如果node节点的资源不足，则很有可能无法创建pod，导致服务启动或者扩容失败。<br>&emsp;&emsp;具体K8s集群的搭建，可以参考我之前文章<a href="https://hewanyue.com/blog/8f374cb8.html" rel="noopener" target="_blank">使用kubeasz自动化部署K8s</a>。harbor服务器的搭建和部署配置，也可以参考我之前文章<a href="https://hewanyue.com/blog/6187894.html" rel="noopener" target="_blank">Docker（五）——Docker镜像仓库</a>。<br>&emsp;&emsp;因为是均为内网环境，建议将网络组件calico的IPIP模式（ip-in-ip叠加模式）关掉，使用calico的BGP模式，以节约大量主机内部访问时封装的性能损耗。具体操作可以参考之前博客<a href="https://hewanyue.com/blog/8f374cb8.html" rel="noopener" target="_blank">使用kubeasz自动化部署K8s</a>。</p><h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p>&emsp;&emsp;我们设计一个简单架构为例，如下图所示。<br><img src="https://img-blog.csdnimg.cn/2020011414135532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="k8s架构-java服务集群"><br>&emsp;&emsp;一般负载层是使用物理机上的haproxy服务来实现4层负载，而不是在K8s集群内部pod 实现。我们这里也就将他省略不再细说。<br>所以我们需要创建一个nginx集群，以及一个tomcat集群。将动态资源，转发给后端的tomcat服务，前端的静态页面由nginx来处理。为了方便我们对后端服务的修改以及部署，我们还需要一个NFS服务器，来共享静态资源以及动态资源，以实现后端服务数据的实时同步。</p><h2 id="搭建业务镜像架构"><a href="#搭建业务镜像架构" class="headerlink" title="搭建业务镜像架构"></a>搭建业务镜像架构</h2><p>&emsp;&emsp;镜像一般是按层次一级一级实现的，可实现多个业务复用。所以，例如我们将要实现的业务为app1，则我们需要的的镜像，就有对应的app1-nginx及app1-tomcat的业务镜像，以及nginx及tomcat的基础镜像，以及基础系统镜像，我们要一层层的来制作镜像。详细可以参考之前文章<a href="https://hewanyue.com/blog/ddd838e7.html" rel="noopener" target="_blank">Docker（三）——镜像制作</a>。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span></span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> k8s/&#123;app1,dockerfile,yaml&#125;</span><br><span class="line"><span class="keyword">cd</span> k8s/dockerfile</span><br><span class="line"><span class="built_in">mkdir</span> &#123;app1,pub-image,<span class="built_in">system</span>&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;最终结构如下图所示。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu18:/opt/k8s/dockerfile# tree -d</span><br><span class="line">.</span><br><span class="line">├── app1</span><br><span class="line">│   ├── app1-nginx</span><br><span class="line">│   └── app1-tomcat</span><br><span class="line">├── pub-images</span><br><span class="line">│   ├── jdk</span><br><span class="line">│   │   └── 8</span><br><span class="line">│   ├── nginx-base</span><br><span class="line">│   └── tomcat-base</span><br><span class="line">└── system</span><br><span class="line">    └── centos</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;打好的镜像如下所示。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu18:/opt/k8s/dockerfile# docker images</span><br><span class="line">REPOSITORY                                          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">harbor.micepro.net/base/app1-tomcat                  v1                  c7d87d05f8a4        <span class="number">3</span> days ago          <span class="number">1.19</span>GB</span><br><span class="line">harbor.micepro.net/base/tomcat-base                  v8<span class="number">.5</span><span class="number">.47</span>             <span class="number">12</span>cf3e12f2d0        <span class="number">3</span> days ago          <span class="number">1.19</span>GB</span><br><span class="line">harbor.micepro.net/base/jdk-base                     v8<span class="number">.212</span>              <span class="number">1582</span>b1e9cfe4        <span class="number">3</span> days ago          <span class="number">1.16</span>GB</span><br><span class="line">harbor.micepro.net/base/app1-nginx                   v1                  <span class="number">4836f</span>9aed79b        <span class="number">3</span> days ago          <span class="number">940</span>MB</span><br><span class="line">harbor.micepro.net/base/nginx-base                   v1<span class="number">.16</span><span class="number">.1</span>             bfc05a5c23ed        <span class="number">5</span> days ago          <span class="number">940</span>MB</span><br><span class="line">harbor.micepro.net/base/centos-base                  v7<span class="number">.6</span>                bc7e922a8352        <span class="number">5</span> days ago          <span class="number">753</span>MB</span><br><span class="line">harbor.micepro.net/base/centos                       base                f1cb7c7d58b7        <span class="number">10</span> months ago       <span class="number">202</span>MB</span><br></pre></td></tr></table></figure></p><h2 id="配置NFS服务器"><a href="#配置NFS服务器" class="headerlink" title="配置NFS服务器"></a>配置NFS服务器</h2><p>&emsp;&emsp;我们计划将动态资源和静态资源都放置至我们的NFS共享存储上，也就是我们的harbor上（任意主机，端口不冲突就可以~）<br>&emsp;&emsp;可以通过包管理工具快速安装一个NFS服务，毕竟这只是一个辅助工具，无需过多关注。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">install</span> -y nfs-<span class="keyword">server</span></span><br><span class="line">mkdir /<span class="keyword">data</span>/app1/&#123;images,<span class="keyword">static</span>,ROOT&#125; -p</span><br><span class="line">echo <span class="string">"/data/app1 *(rw,no_root_squash)"</span> &gt;&gt; /etc/exports</span><br><span class="line">systemctl <span class="keyword">enable</span> <span class="comment">--now nfs-server</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;将<code>/data/app1</code>目录整个共享出去即可，之后我们可以直接将NFS挂载至pod中，也可以通过PV/PVC的方式挂载到pod中。<br>&emsp;&emsp;我们需要修改权限，通过指定uid的方式，使某个UID在多个主机之间都具有权限。这就要求我们之前在创建基础镜像时，也使用的是相同的UID启动程序。例如我们统一都使用<code>www</code>用户，指定UID为2020。（之前创建的容器以及基础镜像中都要修改服务以UID为2020的www用户启动）</p><h2 id="编写yaml文件"><a href="#编写yaml文件" class="headerlink" title="编写yaml文件"></a>编写yaml文件</h2><p>&emsp;&emsp;此时我们就可以开始着手准备yaml文件，来规划我们的服务pod了。</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>&emsp;&emsp;首先我们需要新创建一个namespace，来实现与其他服务隔离。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/k8s/</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> yaml/namespace</span><br></pre></td></tr></table></figure></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim yaml<span class="meta-keyword">/namespace/</span>app1.yaml</span><br><span class="line"><span class="symbol">apiVersion:</span> v1 <span class="meta">#API版本</span></span><br><span class="line"><span class="symbol">kind:</span> Namespace <span class="meta">#类型为namespac</span></span><br><span class="line"><span class="symbol">metadata:</span> <span class="meta">#定义元数据</span></span><br><span class="line"><span class="symbol">  name:</span> app1 <span class="meta">#namespace名称</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后将这个namespace创建出来，使用命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="regexp">/opt/</span>k8s<span class="regexp">/yaml/</span>namespace<span class="regexp">/app1.yaml</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时使用命令<code>kubectl get ns</code>可以看到我们新创建的namespace<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu18:/opt/k8s# kubectl <span class="builtin-name">get</span> ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">app1              Active   20s</span><br><span class="line">default           Active   3d</span><br><span class="line">kube-node-lease   Active   3d</span><br><span class="line">kube-public       Active   3d</span><br><span class="line">kube-system       Active   3d</span><br></pre></td></tr></table></figure></p><h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>&emsp;&emsp;先创建好对应的目录，方便后期管理维护。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/k8s</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> app1/&#123;nginx,tomcat&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后我们就可以编写pod的yaml文件了。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/opt/</span>k8s<span class="regexp">/app1/</span>nginx</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以将<code>Deployment</code>和<code>server</code>写在一起，也可以分开写。我们这直接都写在一起。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">nginx.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">app1-nginx-deployment-label</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">app1-nginx-deployment</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">app1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span>  <span class="comment">#设置nginx集群数量</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">app1-nginx-selector</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">app1-nginx-selector</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">app1-nginx-container</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">harbor.micepro.net/base/app1-nginx:v1</span></span><br><span class="line">        <span class="comment">#command: ["/apps/tomcat/bin/run_tomcat.sh"]</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="comment">#imagePullPolicy: Always</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">"password"</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">"age"</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"18"</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">2</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="comment">#            memory: 1Gi</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">app1-images</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/local/nginx/html/webapp/images</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">app1-static</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/local/nginx/html/webapp/static</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">app1-images</span></span><br><span class="line"><span class="attr">        nfs:</span></span><br><span class="line"><span class="attr">          server:</span> <span class="number">192.168</span><span class="number">.32</span><span class="number">.20</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/data/app1/images</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">app1-static</span></span><br><span class="line"><span class="attr">        nfs:</span></span><br><span class="line"><span class="attr">          server:</span> <span class="number">192.168</span><span class="number">.32</span><span class="number">.20</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/data/app1/static</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">app1-nginx-service-label</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">app1-nginx-service</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">app1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">app1-nginx-selector</span></span><br></pre></td></tr></table></figure></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/opt/</span>k8s<span class="regexp">/app1/</span>tomcat</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编写tomcat的pod的yaml文件<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">app1-tomcat-app1-deployment-label</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">app1-tomcat-app1-deployment</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">app1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">app1-tomcat-app1-selector</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">app1-tomcat-app1-selector</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">app1-tomcat-app1-container</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">harbor.micepro.net/base/tomcat-app1:v1</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["/usr/local/tomcat/bin/run_tomcat.sh"]</span></span><br><span class="line">        <span class="comment">#imagePullPolicy: IfNotPresent</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">"password"</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">"age"</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"18"</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="string">"1000Mi"</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">app1-myapp</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/data/tomcat/webapps/ROOT</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">app1-myapp</span></span><br><span class="line"><span class="attr">        nfs:</span></span><br><span class="line"><span class="attr">          server:</span> <span class="number">192.168</span><span class="number">.32</span><span class="number">.19</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/data/app1/ROOT</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">app1-static</span></span><br><span class="line"><span class="attr">        nfs:</span></span><br><span class="line"><span class="attr">          server:</span> <span class="number">192.168</span><span class="number">.32</span><span class="number">.19</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/data/app1/static</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">app1-tomcat-app1-service-label</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">app1-tomcat-app1-service</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">app1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">38080</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">app1-tomcat-app1-selector</span></span><br></pre></td></tr></table></figure></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>&emsp;&emsp;因为要实现一个通用的nginx+tomcat动静分离web架构，即用户访问的静态页面和图片在由nginx直接响应，而动态请求则基于tomcat的service name转发用户请求到tomcat业务app。<br>&emsp;&emsp;所以我们需要修改当时创建镜像的nginx的配置文件，配置upstream服务器为tomcat的pod，配置如下<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcat_webserver &#123;</span><br><span class="line">    <span class="attribute">server</span> app1-tomcat-app1-service.app1.svc.app1.local:<span class="number">8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> /myapp &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://tomcat_webserver;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中pod间通信是基于K8s内部DNS实现的，一般是coreDNS或者kubeDNS，如果没有安装是无法解析的，可以使用kubeasz的第七个playbook安装，可参考之前文章<a href="https://hewanyue.com/blog/8f374cb8.html" rel="noopener" target="_blank">使用kubeasz自动化部署K8s</a>。<br>&emsp;&emsp;主机名默认组成结构为release-name-rancher.default.svc.cluster.local，也就是<code>ServerName.NameSpace.svc.CLUSTER_DNS_DOMAIN</code>。<code>ServerName</code>是我们在yaml文件中定义的，<code>NameSpace</code>是我们创建pod时选择的<code>namespace</code>，<code>CLUSTER_DNS_DOMAIN</code>是我们在创建K8s集群时设置的集群名，如果是用kubeasz工具创建的K8s集群，可以去<code>/etc/ansible/hosts</code>文件中查看。<br>&emsp;&emsp;我们可以在pod间测试通信，确保相互之间可以通过主机名通信。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@blog-tomcat-app1-deployment-5b4845ddd8-rr5dq /]#<span class="built_in"> ping </span>app1-nginx-service.app1.svc.cluster.local</span><br><span class="line">PING app1-nginx-service.app1.svc.cluster.local (10.68.101.60) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> app1-nginx-service.app1.svc.cluster.local (10.68.101.60): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.103 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> app1-nginx-service.app1.svc.cluster.local (10.68.101.60): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.314 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> app1-nginx-service.app1.svc.cluster.local (10.68.101.60): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=64 <span class="attribute">time</span>=0.077 ms</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;而且nginx及tomcat中最好将日志格式改为json格式，方便我们收集日志。<br>&emsp;&emsp;tomcat的配置文件<code>/usr/local/tomcat/conf/server.xml</code>，设置<code>appBase=&quot;/data/tomcat/webapps/</code>,日志格式修改如下<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</span></span><br><span class="line"><span class="params">       prefix="localhost_access_log" suffix=".txt"</span></span><br><span class="line"><span class="params">       pattern="&#123;<span class="variable">&amp;quot</span>;clientip<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%h<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;ClientUser<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%l<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;authenticated<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%u<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;AccessTime<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%t<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;method<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%r<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;status<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%s<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;SendBytes<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%b<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;Query?string<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%q<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;partner<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%&#123;Referer&#125;i<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;AgentVersion<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%&#123;User-Agent&#125;i<span class="variable">&amp;quot</span>;&#125;" /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="PV-PVC"><a href="#PV-PVC" class="headerlink" title="PV/PVC"></a>PV/PVC</h3><p>&emsp;&emsp;我们还可以通过创建一个创建PV/PVC的方式的方式来代替直接NFS挂载Volume。<br>&emsp;&emsp;PersistentVolume（PV）是集群中由管理员配置的一段网络存储。 它是集群中的资源，就像节点是集群资源一样。 PV是容量插件，如Volumes，但其生命周期独立于使用PV的任何单个pod。 此API对象捕获存储实现的详细信息，包括NFS，iSCSI或特定于云提供程序的存储系统。<br>&emsp;&emsp;PersistentVolumeClaim（PVC）是由用户进行存储的请求。 它类似于pod。 Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。声明可以请求特定的大小和访问模式（例如，可以一次读/写或多次只读）。<br>&emsp;&emsp;PVC和PV是一一对应的。Persistent Volume相对独立于Pods,单独创建。<br>&emsp;&emsp;Persistent Volume对具体的存储进行配置和分配，而Pods等则可以使用Persistent Volume抽象出来的存储资源，不需要知道集群的存储细节。<br>&emsp;&emsp;Persistent Volume和Persistent Volume Claim类似Pods和Nodes的关系，创建Pods需要消耗一定的Nodes的资源。而Persistent Volume则是提供了各种存储资源，而Persistent Volume Claim提出需要的存储标准，然后从现有存储资源中匹配或者动态建立新的资源，最后将两者进行绑定。<br>&emsp;&emsp;以我们这次的演示为例，PV和PVC如下所示。<br>&emsp;&emsp;PV的yaml文件示例<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> PersistentVolume</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> nfs</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  storageClassName:</span> manual</span><br><span class="line"><span class="symbol">  capacity:</span></span><br><span class="line"><span class="symbol">    storage:</span> <span class="number">10</span>Gi</span><br><span class="line"><span class="symbol">  accessModes:</span></span><br><span class="line">    - ReadWriteMany</span><br><span class="line"><span class="symbol">  nfs:</span></span><br><span class="line"><span class="symbol">    server:</span> <span class="number">192.168</span><span class="number">.32</span><span class="number">.19</span></span><br><span class="line"><span class="symbol">    path:</span> <span class="string">"/data/app1/static"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;PVC的yaml文件示例<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> PersistentVolumeClaim</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> nfs</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  accessModes:</span></span><br><span class="line">    - ReadWriteMany</span><br><span class="line"><span class="symbol">  storageClassName:</span> manual</span><br><span class="line"><span class="symbol">  resources:</span></span><br><span class="line"><span class="symbol">    requests:</span></span><br><span class="line"><span class="symbol">      storage:</span> <span class="number">10</span>Gi</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;pod中引用PVC<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: testpv</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">role</span>: web-frontend</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: web</span><br><span class="line">    <span class="attribute">image</span>: nginx</span><br><span class="line">    <span class="attribute">ports</span>:</span><br><span class="line">      - <span class="attribute">name</span>: web</span><br><span class="line">        <span class="attribute">containerPort</span>: <span class="number">80</span></span><br><span class="line">    <span class="attribute">volumeMounts</span>:</span><br><span class="line">        - <span class="attribute">name</span>: nfs</span><br><span class="line">          <span class="attribute">mountPath</span>: <span class="string">"/usr/local/nginx/html/webapp/static"</span></span><br><span class="line">  <span class="attribute">volumes</span>:</span><br><span class="line">  - <span class="attribute">name</span>: nfs</span><br><span class="line">    <span class="attribute">persistentVolumeClaim</span>:</span><br><span class="line">      <span class="attribute">claimName</span>: nfs</span><br></pre></td></tr></table></figure></p><h2 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h2><p>&emsp;&emsp;虽然我们可以使用命令<code>kubectl scale</code>对运行在k8s 环境中的pod 数量进行扩容(增加)或缩容(减小)。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# kubectl --help | grep -w scale</span><br><span class="line">  scale          Set a new size <span class="keyword">for</span> a Deployment, ReplicaSet, Replication Controller, <span class="keyword">or</span> Job</span><br><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# kubectl <span class="keyword">get</span> deployments -n app1</span><br><span class="line">NAME                     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">app1-nginx-deployment    <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">9</span>d</span><br><span class="line">app1-tomcat-deployment   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">3</span>d4h</span><br><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# kubectl scale deployment/app1-tomcat-deployment --replicas=<span class="number">2</span> -n app1</span><br><span class="line">deployment.extensions/app1-tomcat-deployment scaled</span><br><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# kubectl <span class="keyword">get</span> deployments -n app1</span><br><span class="line">NAME                     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">app1-nginx-deployment    <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">9</span>d</span><br><span class="line">app1-tomcat-deployment   <span class="number">2</span>/<span class="number">2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="number">74</span>s</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不过在实际生产中，我们肯定没法随时根据负载或者服务需要，手动动态伸缩我们的后端服务器数量，但是我们可以通过命令<code>kubectl autoscale</code>自动控制在k8s集群中运行的pod数量(水平自动伸缩)，想要实现自动上伸缩，需要我们提前设置pod范围及触发条件。<br>&emsp;&emsp;k8s从1.1版本开始增加了名称为HPA(Horizontal Pod Autoscaler)的控制器，用于实现基于pod中资源(CPU/Memory)利用率进行对pod的自动扩缩容功能的实现，早期的版本只能基于Heapster组件实现对CPU利用率做为触发条件，但是在k8s 1.11版本开始使用Metrices Server完成数据采集，然后将采集到的数据通过API（Aggregated API，汇总API），例如metrics.k8s.io、custom.metrics.k8s.io、external.metrics.k8s.io，然后再把数据提供给HPA控制器进行查询，以实现基于某个资源利用率对pod进行扩缩容的目的。<br>&emsp;&emsp;控制管理器默认每隔15s（可以通过–horizontal-pod-autoscaler-sync-period修改）查询metrics的资源使用情况<br>支持以下三种metrics指标类型：<br>&emsp;&emsp;-&gt;预定义metrics（比如Pod的CPU）以利用率的方式计算<br>&emsp;&emsp;-&gt;自定义的Pod metrics，以原始值（raw value）的方式计算<br>&emsp;&emsp;-&gt;自定义的object metrics<br>支持两种metrics查询方式：<br>&emsp;&emsp;-&gt;Heapster<br>&emsp;&emsp;-&gt;自定义的REST API<br>支持多metrics</p><p>（未完待续）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;K8s集群搭建完成后，真正完成我们业务的是那些跑在k8s上的pod们。将业务跑在k8s集群只上，我们可以实现根据负载或者资源利用率动态扩容或者缩容我们的后端服务器，更加灵活高效的利用我们的物理设备，且能够实现服务的高可用及故障自治愈，本文将详细介绍以上的具体实现。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="Dockerfile" scheme="https://wudihechao.github.io/tags/Dockerfile/"/>
    
      <category term="kubernetes" scheme="https://wudihechao.github.io/tags/kubernetes/"/>
    
      <category term="yaml" scheme="https://wudihechao.github.io/tags/yaml/"/>
    
      <category term="集群" scheme="https://wudihechao.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="java" scheme="https://wudihechao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>企业级应用——ELK（三）：filebeat</title>
    <link href="https://wudihechao.github.io//blog/bd240ad7.html"/>
    <id>https://wudihechao.github.io//blog/bd240ad7.html</id>
    <published>2020-01-06T09:47:24.000Z</published>
    <updated>2020-01-06T12:10:25.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;提到ELK，就不得不提到EFK，通常意义上说，EFK是指用filebeat代替logstash形成的新组合。（哈，也有是指Fluentd的，这个我们之后再说）<br>&emsp;&emsp;Filebeat 是基于原先 logstash-forwarder 的源码改造出来的，无需依赖 Java 环境就能运行，安装包10M不到。<br>&emsp;&emsp;而且如果日志的量很大，Logstash 会遇到资源占用高的问题，为解决这个问题，我们引入了Filebeat。Filebeat 是基于 logstash-forwarder 的源码改造而成，用 Golang 编写，无需依赖 Java 环境，效率高，占用内存和 CPU 比较少，非常适合作为 Agent 跑在服务器上，来实现日志转发的功能。<br><a id="more"></a><br>&emsp;&emsp;还是去官网下载<a href="https://www.elastic.co/cn/downloads/beats/filebeat" rel="noopener" target="_blank">https://www.elastic.co/cn/downloads/beats/filebeat</a>。本次演示还是以最新版的filebeat7.5.1为例（以前版本的filebeat配置文件格式参数上可能有一些改变，不过大同小异）。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.5.1-amd64.deb</span><br><span class="line">dpkg -i filebeat-7.5.1-amd64.deb</span><br></pre></td></tr></table></figure></p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>&emsp;&emsp;配置文件也很简单，如果想要写入文件，则配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">grep</span> <span class="bullet">-v</span> <span class="string">"#"</span> <span class="string">/etc/filebeat/filebeat.yml</span> <span class="string">| grep -v "^$"</span></span><br><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="string"></span><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/syslog</span></span><br><span class="line"><span class="attr">  exclude_lines:</span> <span class="string">["^DBG"]</span></span><br><span class="line"><span class="attr">  exclude_files:</span> <span class="string">[".gz$"]</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">"syslog-filebeat"</span></span><br><span class="line"><span class="string">output.file:</span> </span><br><span class="line"><span class="attr">  path:</span> <span class="string">"/tmp"</span></span><br><span class="line"><span class="attr">  filename:</span> <span class="string">"filebeat.txt"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>paths</code>路径支持正则通配符写法，exclude是设置不匹配的文件格式。而且filebeat也支持同时从多个路径收集写成如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/syslog</span></span><br><span class="line"><span class="attr">  exclude_lines:</span> <span class="string">["^DBG"]</span></span><br><span class="line"><span class="attr">  exclude_files:</span> <span class="string">[".gz$"]</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">"syslog-filebeat"</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/nginx/access.log</span></span><br><span class="line"><span class="attr">  exclude_lines:</span> <span class="string">["^DBG"]</span></span><br><span class="line"><span class="attr">  exclude_files:</span> <span class="string">[".gz$"]</span></span><br><span class="line"><span class="attr">  document_type:</span> <span class="string">"nginx-accesslog-filebeat</span></span><br><span class="line"><span class="string">output.file: </span></span><br><span class="line"><span class="string">  path: "</span><span class="string">/tmp"</span></span><br><span class="line"><span class="attr">  filename:</span> <span class="string">"filebeat.txt"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样，filebeat支持写入redis和kafka</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/syslog</span></span><br><span class="line"><span class="attr">  exclude_lines:</span> <span class="string">["^DBG"]</span></span><br><span class="line"><span class="attr">  exclude_files:</span> <span class="string">[".gz$"]</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="string">"filebeat-redis-syslog"</span></span><br><span class="line"><span class="string">output.redis:</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.32.31:6379"]</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"filebeat-system-log"</span> <span class="comment">#为了后期日志处理，建议自定义 key 名称</span></span><br><span class="line"><span class="attr">  db:</span> <span class="number">1</span> <span class="comment">#使用第几个库</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">5</span> <span class="comment">#超时时间</span></span><br><span class="line"><span class="attr">  password:</span> <span class="number">123456</span> <span class="comment">#redis 密码</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;想要写入kafka则添加output插件，配置如下<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/log/syslog</span></span><br><span class="line"><span class="attr">  exclude_lines:</span> <span class="string">["^DBG"]</span></span><br><span class="line"><span class="attr">  exclude_files:</span> <span class="string">[".gz$"]</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">"filebeat-kafka-syslog"</span></span><br><span class="line"><span class="string">output.kafka:</span> <span class="comment">#写入 kafka</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.15.11:9092","192.168.15.12:9092","192.168.15.13:9092"]</span></span><br><span class="line"><span class="attr">  topic:</span> <span class="string">"systemlog-1512-filebeat"</span></span><br><span class="line">  <span class="string">partition.round_robin:</span></span><br><span class="line"><span class="attr">    reachable_only:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  required_acks:</span> <span class="number">1</span> <span class="comment">#本地写入完成</span></span><br><span class="line"><span class="attr">  compression:</span> <span class="string">gzip</span> <span class="comment">#开启压缩</span></span><br><span class="line"><span class="attr">  max_message_bytes:</span> <span class="number">1000000</span> <span class="comment">#消息最大值</span></span><br></pre></td></tr></table></figure></p><h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>&emsp;&emsp;也就是设置日志收集的来源，需要的属性有<code>type</code>,<code>path</code>，根据<a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html" rel="noopener" target="_blank">官方文档</a>，现在版本常用写法为，<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  path<span class="variable">s:</span></span><br><span class="line">    - /var/<span class="built_in">log</span>/<span class="built_in">system</span>.<span class="built_in">log</span></span><br><span class="line">    - /var/<span class="built_in">log</span>/wifi.<span class="built_in">log</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  path<span class="variable">s:</span></span><br><span class="line">    - <span class="string">"/var/log/apache2/*"</span></span><br><span class="line">  field<span class="variable">s:</span></span><br><span class="line">    apache: true</span><br><span class="line">  fields_under_roo<span class="variable">t:</span> true</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中type的类型很多</p><ul><li>Log 日志文件，必须有PATH,官方示例如下：</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span> </span><br><span class="line">  path<span class="variable">s:</span></span><br><span class="line">    - /var/<span class="built_in">log</span>/<span class="built_in">system</span>.<span class="built_in">log</span></span><br><span class="line">    - /var/<span class="built_in">log</span>/wifi.<span class="built_in">log</span></span><br><span class="line">    - /var/<span class="built_in">log</span>/*.<span class="built_in">log</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span> </span><br><span class="line">  path<span class="variable">s:</span></span><br><span class="line">    - <span class="string">"/var/log/apache2/*"</span></span><br><span class="line">  field<span class="variable">s:</span></span><br><span class="line">    apache: true</span><br><span class="line">  fields_under_roo<span class="variable">t:</span> true</span><br></pre></td></tr></table></figure><ul><li>Stdin 标准输入，没有PATH，官方示例如下：</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: stdin</span><br></pre></td></tr></table></figure><ul><li>Container 容器中日志，必须有PATH，官方示例如下：</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: container</span><br><span class="line">  path<span class="variable">s:</span> </span><br><span class="line">    - <span class="string">'/var/lib/docker/containers/*/*.log'</span></span><br></pre></td></tr></table></figure><ul><li>Kafka 从kafka中读取数据，官方示例如下：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: kafka</span><br><span class="line"><span class="symbol">  hosts:</span> [<span class="string">"&lt;your event hub namespace&gt;.servicebus.windows.net:9093"</span>]</span><br><span class="line"><span class="symbol">  topics:</span> [<span class="string">"&lt;your event hub instance&gt;"</span>]</span><br><span class="line"><span class="symbol">  group_id:</span> <span class="string">"&lt;your consumer group&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  username:</span> <span class="string">"$ConnectionString"</span></span><br><span class="line"><span class="symbol">  password:</span> <span class="string">"&lt;your connection string&gt;"</span></span><br><span class="line">  ssl.enabled: true</span><br></pre></td></tr></table></figure><ul><li>Redis 从redis中读取数据，官方示例如下：</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: redis</span><br><span class="line">  host<span class="variable">s:</span> [<span class="string">"localhost:6379"</span>]</span><br><span class="line">  password: <span class="string">"$&#123;redis_pwd&#125;"</span></span><br></pre></td></tr></table></figure><ul><li>UDP 开放UDP端口来接受数据，可设置单条最大数据上限，不定义默认为20MiB。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: udp</span><br><span class="line">  max_message_size: <span class="number">10</span>KiB</span><br><span class="line">  hos<span class="variable">t:</span> <span class="string">"localhost:8080"</span></span><br></pre></td></tr></table></figure><ul><li>Docker 也支持直接从容器中读取数据， containers.ids是必须定义说明，可以用*代表所有容器。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- type: docker</span><br><span class="line">  containers.ids: </span><br><span class="line">    - '8b6fe7dc9e067b<span class="number">5847</span>6dc57d<span class="number">6986</span>dd96d<span class="number">710043</span>0c5de3b109a99cd56ac<span class="number">655347</span>'</span><br></pre></td></tr></table></figure><ul><li>TCP 用法与UDP相同，设置监听的主机和端口。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: tcp</span><br><span class="line">  max_message_size: <span class="number">10</span>MiB</span><br><span class="line">  hos<span class="variable">t:</span> <span class="string">"localhost:9000"</span></span><br></pre></td></tr></table></figure><ul><li>Syslog 监听系统日志，指定传输协议即可。类似TCP和UDP。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat<span class="selector-class">.inputs</span>:</span><br><span class="line">- type: syslog</span><br><span class="line">  protocol<span class="selector-class">.udp</span>:</span><br><span class="line">    host: <span class="string">"localhost:9000"</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filebeat<span class="selector-class">.inputs</span>:</span><br><span class="line">- type: syslog</span><br><span class="line">  protocol<span class="selector-class">.tcp</span>:</span><br><span class="line">    host: <span class="string">"localhost:9000"</span></span><br></pre></td></tr></table></figure><ul><li>s3 AWS的对象存储日志，不过多介绍</li><li>NetFlow Cisco设备网络设备的日志，不过多介绍</li><li>Google Pub/Sub google云的订阅发布模式协议数据，不过多介绍。</li></ul><p>&emsp;&emsp;一般来说，我们都写log，就可以满足我们绝大多数场景的使用了。除了<code>type</code>、<code>path</code>这俩常用的input属性外，还有两个设置属性，我们也经常会用到，就是<code>include_lines</code>、<code>exclude_lines</code>，顾名思义，就是包括和排除，配合path中的通配符，可以帮助我们更灵活的指定要收集的日志文件。<br>&emsp;&emsp;还有一个很常用的属性就是<code>tags</code>,可以写多个，用<code>[]</code>括起来就可以。因为在filebeat中因为有自带<code>type</code>关键字，所以我们在之后筛选日志的时候，无法通过type字段来区分不同的日志源了，所以我们可以通过自定义<code>tags</code>字段，来实现之前在logstash上type的功能，这样在我们收集到的日志中，会自动加入<code>tags</code> 标签属性，然后通过logstash的筛选时，就可以对<code>tags</code>关键字做判断了。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>&emsp;&emsp;输出选项有<code>Elasticsearch</code>、<code>Logstash</code>、<code>Kafka</code>、<code>Redis</code>、<code>File</code>、<code>Console</code>、<code>Elastic Cloud</code>。</p><ul><li><p>File<br>输出到文件中是最简单的设置了，一般用于测试。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output.file:</span><br><span class="line">  path: <span class="string">"/tmp/filebeat"</span>     #输出文件路径</span><br><span class="line">  filename: filebeat        #输出日志名称，超过大小限制后会自动添加数字后缀</span><br><span class="line">  #rotate_every_kb: <span class="number">10000</span>   #每个日志文件大小限制</span><br><span class="line">  #number_of_files: <span class="number">7</span>   #路径下最大的储存日志文件数量，超过此值后自动删除最早的日志文件，默认为<span class="number">7</span>。</span><br><span class="line">  #permissions: <span class="number">0600</span>    #创建的日志文件的权限</span><br></pre></td></tr></table></figure></li><li><p>Logstash<br>filebeat支持直接将数据输出值logstash主机。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output<span class="selector-class">.logstash</span>:</span><br><span class="line">  hosts: [<span class="string">"127.0.0.1:5044"</span>]</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;而logstash主机需要设置输入为beats，才可以顺利接收filebeat的数据。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">   <span class="built_in"> port </span>=&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"http://localhost:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;"</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>redis<br>输出值redis，上面有说明，这里就不详细介绍了。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output.redis:</span><br><span class="line"><span class="symbol">  hosts:</span> [<span class="string">"localhost"</span>]</span><br><span class="line"><span class="symbol">  password:</span> <span class="string">"my_password"</span></span><br><span class="line"><span class="symbol">  key:</span> <span class="string">"filebeat"</span></span><br><span class="line"><span class="symbol">  db:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">  timeout:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>kafka<br>输出至kafka。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">output.kafka:</span></span><br><span class="line">  <span class="comment"># initial brokers for reading cluster metadata</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["kafka1:9092",</span> <span class="string">"kafka2:9092"</span><span class="string">,</span> <span class="string">"kafka3:9092"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># message topic selection + partitioning</span></span><br><span class="line"><span class="attr">  topic:</span> <span class="string">'<span class="template-variable">%&#123;[fields.log_topic]&#125;</span>'</span></span><br><span class="line">  <span class="string">partition.round_robin:</span></span><br><span class="line"><span class="attr">    reachable_only:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  required_acks:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  compression:</span> <span class="string">gzip</span></span><br><span class="line"><span class="attr">  max_message_bytes:</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;也可以输出至kafka的不同的topic中</p><blockquote><p>Rule settings:<br>topic<br>   The topic format string to use. If this string contains field references, such as %{[fields.name]}, the fields must exist, or the rule fails.<br>mappings<br>   A dictionary that takes the value returned by topic and maps it to a new &gt;name.<br>default<br>   The default string value to use if mappings does not find a match.<br>when<br>   A condition that must succeed in order to execute the current rule. All the conditions supported by processors are also supported here. </p></blockquote><p>&emsp;&emsp;官方示例如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output<span class="selector-class">.kafka</span>:</span><br><span class="line">  hosts: [<span class="string">"localhost:9092"</span>]</span><br><span class="line">  topic: <span class="string">"logs-%&#123;[beat.version]&#125;"</span></span><br><span class="line">  topics:</span><br><span class="line">    - topic: <span class="string">"critical-%&#123;[beat.version]&#125;"</span></span><br><span class="line">      when<span class="selector-class">.contains</span>:</span><br><span class="line">        message: <span class="string">"CRITICAL"</span></span><br><span class="line">    - topic: <span class="string">"error-%&#123;[beat.version]&#125;"</span></span><br><span class="line">      when<span class="selector-class">.contains</span>:</span><br><span class="line">        message: <span class="string">"ERR"</span></span><br></pre></td></tr></table></figure></p><ul><li><p>Elaticsearch<br>可以直接将数据输出给elaticsearch服务器，不过一般来说我们不会这样做，一般是会经过logstash来筛选之后再传入elaticsearch。官方示例如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line"><span class="symbol">  hosts:</span> [<span class="string">"https://localhost:9200"</span>]</span><br><span class="line"><span class="symbol">  username:</span> <span class="string">"filebeat_internal"</span></span><br><span class="line"><span class="symbol">  password:</span> <span class="string">"YOUR_PASSWORD"</span></span><br></pre></td></tr></table></figure></li><li><p>Console<br>输出至屏幕终端显示。pretty官方的介绍为<code>If pretty is set to true, events written to stdout will be nicely formatted. The default is false</code>，示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">output.console:</span></span><br><span class="line"><span class="attr">  pretty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;提到ELK，就不得不提到EFK，通常意义上说，EFK是指用filebeat代替logstash形成的新组合。（哈，也有是指Fluentd的，这个我们之后再说）&lt;br&gt;&amp;emsp;&amp;emsp;Filebeat 是基于原先 logstash-forwarder 的源码改造出来的，无需依赖 Java 环境就能运行，安装包10M不到。&lt;br&gt;&amp;emsp;&amp;emsp;而且如果日志的量很大，Logstash 会遇到资源占用高的问题，为解决这个问题，我们引入了Filebeat。Filebeat 是基于 logstash-forwarder 的源码改造而成，用 Golang 编写，无需依赖 Java 环境，效率高，占用内存和 CPU 比较少，非常适合作为 Agent 跑在服务器上，来实现日志转发的功能。&lt;br&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="https://wudihechao.github.io/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="ELK" scheme="https://wudihechao.github.io/tags/ELK/"/>
    
      <category term="Elasticsearch" scheme="https://wudihechao.github.io/tags/Elasticsearch/"/>
    
      <category term="Logstash" scheme="https://wudihechao.github.io/tags/Logstash/"/>
    
      <category term="Filebeat" scheme="https://wudihechao.github.io/tags/Filebeat/"/>
    
  </entry>
  
  <entry>
    <title>企业级应用——ELK（二）：ELK进阶</title>
    <link href="https://wudihechao.github.io//blog/ee80297c.html"/>
    <id>https://wudihechao.github.io//blog/ee80297c.html</id>
    <published>2020-01-03T14:30:18.000Z</published>
    <updated>2020-01-06T12:10:25.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;之前我们部署好了ELK的基本架构，也实现了从系统日志以及nginx中收集日志，不过等待我们的问题依然很多：怎么讲收集好的日志放至临时缓存？或者怎么从缓存中提取日志？对于java应用等日志非单行的服务日志该如何收集等等。本文将继续讲解ELK的各种进阶用法。<br><a id="more"></a></p><h2 id="收集tomcat日志"><a href="#收集tomcat日志" class="headerlink" title="收集tomcat日志"></a>收集tomcat日志</h2><p>&emsp;&emsp;收集tomcat中的日志比较简单，跟nginx一样，将日志序列化为json格式即可。<br>&emsp;&emsp;修改tomcat配置文件,将日志格式修改为如下格式。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="keyword">local</span>/tomcat/conf/<span class="keyword">server</span>.xml</span><br></pre></td></tr></table></figure></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</span></span><br><span class="line"><span class="params">       prefix="localhost_access_log" suffix=".txt"</span></span><br><span class="line"><span class="params">       pattern="&#123;<span class="variable">&amp;quot</span>;clientip<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%h<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;ClientUser<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%l<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;authenticated<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%u<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;AccessTime<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%t<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;method<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%r<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;status<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%s<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;SendBytes<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%b<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;Query?string<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%q<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;partner<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%&#123;Referer&#125;i<span class="variable">&amp;quot</span>;,<span class="variable">&amp;quot</span>;AgentVersion<span class="variable">&amp;quot</span>;:<span class="variable">&amp;quot</span>;%&#123;User-Agent&#125;i<span class="variable">&amp;quot</span>;&#125;" /&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时查看新生成的访问日志，即可看到新生成的日志已经成json格式了。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /usr/local/tomcat/logs/localhost_access_log<span class="number">.2020</span><span class="number">-01</span><span class="number">-03.</span>txt</span><br></pre></td></tr></table></figure></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"clientip"</span>:<span class="string">"192.168.32.1"</span>,<span class="attr">"ClientUser"</span>:<span class="string">"-"</span>,<span class="attr">"authenticated"</span>:<span class="string">"-"</span>,<span class="attr">"AccessTime"</span>:<span class="string">"[03/Jan/2020:19:34:29 +0800]"</span>,<span class="attr">"method"</span>:<span class="string">"GET /bg-button.png HTTP/1.1"</span>,<span class="attr">"status"</span>:<span class="string">"304"</span>,<span class="attr">"SendBytes"</span>:<span class="string">"-"</span>,<span class="attr">"Query?string"</span>:<span class="string">""</span>,<span class="attr">"partner"</span>:<span class="string">"http://192.168.32.51:8080/tomcat.css"</span>,<span class="attr">"AgentVersion"</span>:<span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"</span>&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不过为了以防万一，可以去网上使用在线json格式校验工具，检查一下格式是否正确。<br><img src="https://img-blog.csdnimg.cn/20200103214555106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="JSON格式校验"><br>&emsp;&emsp;此时就可以使用logstash工具来收集我们的tomcat日志了。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/logstash/<span class="keyword">conf</span>.d/tomcat-<span class="keyword">el</span>.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不过，想必你们一定也发现了，tomcat访问日志中是带有日期格式的，每天的访问日志文件名是不同的，这要怎么写到path中呢？<br>&emsp;&emsp;哈，别慌，logstash的input-file插件也支持通配符的写法，我们可以写<code>path =&gt; &quot;/usr/local/tomcat/logs/localhost_access_log.*.txt&quot;</code>，如下所示。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/usr/local/tomcat/logs/localhost_access_log.*.txt"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"tomcat_accesslog"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line"><span class="comment">#  stdout &#123;</span></span><br><span class="line"><span class="comment">#    codec =&gt; rubydebug</span></span><br><span class="line"><span class="comment">#  &#125;</span></span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tomcat_accesslog"</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"tomcat_accesslog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;PS：可以分开至不同的配置文件，也可以合并至一个文件中，不过我们习惯不同服务用单独的配置文件来抓取，方便修改。<br>&emsp;&emsp;重启logstash服务，然后去kibana中创建tomcat_accesslog-*的索引，就可以看到tomcat的访问日志了。</p><h2 id="收集JAVA服务的日志"><a href="#收集JAVA服务的日志" class="headerlink" title="收集JAVA服务的日志"></a>收集JAVA服务的日志</h2><p>&emsp;&emsp;JAVA服务中的日志如果不报错还好，还可以是一行一条，但是一旦出现报错信息，一般都是小半屏幕N多行的报错信息，而我们收集日志的很重要的目的就是为了查看这些报错信息，而如果不对这些日志进行处理，还按照一行一条来收集的话，当我们查看这个日志的时候就会很崩溃了——这乱的几乎完全没法看。所以我们要想办法将JAVA服务的日志处理成一行。<br>&emsp;&emsp;刚好强大的logstash也支持换行匹配，我们刚好就以logstash服务本身日志为例<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/logstash/<span class="keyword">conf</span>.d/java-<span class="keyword">el</span>.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/logstash/logs/logstash-plain.log"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"java_accesslog"</span>    </span><br><span class="line">    <span class="attr">codec</span> =&gt; multiline &#123;</span><br><span class="line">    <span class="attr">pattern</span> =&gt; <span class="string">"^\["</span> <span class="comment">#当遇到[开头的行时候将多行进行合并</span></span><br><span class="line">    <span class="attr">negate</span> =&gt; <span class="keyword">true</span> <span class="comment">#true 为匹配成功进行操作， false 为不成功进行操作</span></span><br><span class="line">    <span class="attr">what</span> =&gt; <span class="string">"previous"</span> <span class="comment">#与以前的行合并，如果是下面的行合并就是 next</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">filter</span> &#123; <span class="comment">#日志过滤，如果所有的日志都过滤就写这里，如果只针对某一个过滤就写在 input 里面的日志输入里面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"java_accesslog"</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"java_accesslog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重启logstash服务，然后去kibana中创建java_accesslog-*的索引，就可以看到java的访问日志了。</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>&emsp;&emsp;从redis读取日志和将收集到的日志储存至redis缓存中，其实使用了input的redis插件和output的redis插件来实现。官方文档地址为： <a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputsredis.html" rel="noopener" target="_blank">https://www.elastic.co/guide/en/logstash/current/plugins-outputsredis.html</a></p><h3 id="写入redis"><a href="#写入redis" class="headerlink" title="写入redis"></a>写入redis</h3><p>&emsp;&emsp;我们还以tomcat日志及java日志logstash日志本身为例，写入redis缓存中。<br>&emsp;&emsp;先配置好redis服务器如下：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP：<span class="number">192.168</span><span class="number">.32</span><span class="number">.31</span></span><br><span class="line">PORT：<span class="number">6379</span></span><br><span class="line">auth：<span class="number">123456</span></span><br></pre></td></tr></table></figure></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/usr/local/tomcat/logs/localhost_access_log.*.txt"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"tomcat_redis_accesslog"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">file</span> &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/logstash/logs/logstash-plain.log"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"java_redis_accesslog"</span>    </span><br><span class="line">    <span class="attr">codec</span> =&gt; multiline &#123;</span><br><span class="line">    <span class="attr">pattern</span> =&gt; <span class="string">"^\["</span> <span class="comment">#当遇到[开头的行时候将多行进行合并</span></span><br><span class="line">    <span class="attr">negate</span> =&gt; <span class="keyword">true</span> <span class="comment">#true 为匹配成功进行操作， false 为不成功进行操作</span></span><br><span class="line">    <span class="attr">what</span> =&gt; <span class="string">"previous"</span> <span class="comment">#与以前的行合并，如果是下面的行合并就是 next</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tomcat_redis_accesslog"</span> &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">      <span class="attr">data_type</span> =&gt; <span class="string">"list"</span></span><br><span class="line">      <span class="attr">key</span> =&gt; <span class="string">"tomcat_redis_accesslog"</span></span><br><span class="line">      <span class="attr">host</span> =&gt; <span class="string">"192.168.32.31"</span></span><br><span class="line">      <span class="attr">port</span> =&gt; <span class="string">"6379"</span></span><br><span class="line">      <span class="attr">db</span> =&gt; <span class="string">"0"</span></span><br><span class="line">      <span class="attr">password</span> =&gt; <span class="string">"123456"</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">    if [type] == <span class="string">"java_redis_accesslog"</span> &#123;</span><br><span class="line">    <span class="keyword">redis</span> &#123;</span><br><span class="line">      <span class="attr">data_type</span> =&gt; <span class="string">"list"</span></span><br><span class="line">      <span class="attr">key</span> =&gt; <span class="string">"java_redis_accesslog"</span></span><br><span class="line">      <span class="attr">host</span> =&gt; <span class="string">"192.168.32.31"</span></span><br><span class="line">      <span class="attr">port</span> =&gt; <span class="string">"6379"</span></span><br><span class="line">      <span class="attr">db</span> =&gt; <span class="string">"1"</span></span><br><span class="line">      <span class="attr">password</span> =&gt; <span class="string">"123456"</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将日志数据以列表的形式储存在redis中，多个不同的日志，储存在不同数据库中。</p><h3 id="读取redis"><a href="#读取redis" class="headerlink" title="读取redis"></a>读取redis</h3><p>&emsp;&emsp;与写入用法大致相同，可以说是怎么写进去的就怎么读出来。形式如下<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    <span class="attr">data_type</span> =&gt; <span class="string">"list"</span></span><br><span class="line">    <span class="attr">key</span> =&gt; <span class="string">"tomcat_redis_accesslog"</span></span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">"192.168.32.31"</span></span><br><span class="line">    <span class="attr">port</span> =&gt; <span class="string">"6379"</span></span><br><span class="line">    <span class="attr">db</span> =&gt; <span class="string">"0"</span></span><br><span class="line">    <span class="attr">password</span> =&gt; <span class="string">"123456"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">  <span class="keyword">redis</span> &#123;</span><br><span class="line">    <span class="attr">data_type</span> =&gt; <span class="string">"list"</span></span><br><span class="line">    <span class="attr">key</span> =&gt; <span class="string">"java_redis_accesslog"</span></span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">"192.168.32.31"</span></span><br><span class="line">    <span class="attr">port</span> =&gt; <span class="string">"6379"</span></span><br><span class="line">    <span class="attr">db</span> =&gt; <span class="string">"1"</span></span><br><span class="line">    <span class="attr">password</span> =&gt; <span class="string">"123456"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tomat_redis_accesslog"</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"tomcat_redis_accesslog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">  if [type] == <span class="string">"java_redis_accesslog"</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"java_redis_accesslog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不过需要注意的是input中记得加<code>codec =&gt; &quot;json&quot;</code>，否则无法解析正确各项属性，不方便我们查看和统计日志。而且不知道大家有没有发现，当我们从redis中取出数据的时候，我们的input选项中没有像往常那样写上<code>type =&gt; &quot;tomcat_redis_accesslog&quot;</code>，而是直接在output中做了type的判断。这是因为，redis中的数据是在写入的时候，已经附加了type属性，它在redis中储存时还是会保留type属性的，所以取出来的时候，还是按照之前写入时的type类型取出即可。</p><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>&emsp;&emsp;在很多大型互联网公司，都喜欢使用kafka来作为缓存层，因为redis虽然效率很高，但数据不如kafka可靠，kafka更适合大数据量场景使用。这就要视业务实际情况而定了。不过使用kafa来作为中间缓冲区的企业还是大有人在的。<br>&emsp;&emsp;我们可以新开启一个kafka主机，IP为192.168.32.36，使用默认端口9092。kafak的使用方法与redis大致相同。配置文件示例如下<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/apps/nginx/logs/access_json.log"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"nginx_kafka_accesslog"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"nginx_kafka_accesslog"</span> &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    <span class="attr">bootstrap_servers</span> =&gt; <span class="string">"192.168.32.36:9092"</span> <span class="comment">#kafka 服务器地址</span></span><br><span class="line">    <span class="attr">topic_id</span> =&gt; <span class="string">"nginx_kafka_accesslog"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;与写入redis有些区别的就是，kafka中不是<code>key</code>了，而是<code>topic_id</code>。所以读取时也有一些区别，填写的关键字为<code>topics</code>，而且同样做判断时，<code>type</code>是当初写进去的那个属性。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    <span class="attr">bootstrap_servers</span> =&gt; <span class="string">"192.168.32.36:9092"</span></span><br><span class="line">    <span class="attr">topics</span> =&gt; <span class="string">"nginx_kafka_accesslog"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">    <span class="attr">consumer_threads</span> =&gt; <span class="number">1</span>  <span class="comment">#线程数，默认值为1，一般设置与分区数量相同</span></span><br><span class="line">    <span class="comment">#decorate_events =&gt; true #不写默认是关闭的，开启此属性可以将当前topic、offset、group、partition等信息也带到message中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"nginx_kafka_accesslog"</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"nginx_kafka_accesslog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;kafka也支持多文件同时写入，设置不同的<code>topic_id</code>就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前我们部署好了ELK的基本架构，也实现了从系统日志以及nginx中收集日志，不过等待我们的问题依然很多：怎么讲收集好的日志放至临时缓存？或者怎么从缓存中提取日志？对于java应用等日志非单行的服务日志该如何收集等等。本文将继续讲解ELK的各种进阶用法。&lt;br&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="https://wudihechao.github.io/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="ELK" scheme="https://wudihechao.github.io/tags/ELK/"/>
    
      <category term="Elasticsearch" scheme="https://wudihechao.github.io/tags/Elasticsearch/"/>
    
      <category term="Logstash" scheme="https://wudihechao.github.io/tags/Logstash/"/>
    
      <category term="Kibana" scheme="https://wudihechao.github.io/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>企业级应用——ELK（一）：ELK的部署</title>
    <link href="https://wudihechao.github.io//blog/a1b53f63.html"/>
    <id>https://wudihechao.github.io//blog/a1b53f63.html</id>
    <published>2020-01-03T10:00:54.000Z</published>
    <updated>2020-01-06T12:10:25.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;ELK是Elasticsearch、Logstash、Kibana的简称，这三者是核心套件，但并非全部。<br>&emsp;&emsp;Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。<br>&emsp;&emsp;Logstash是一个用来搜集、分析、过滤日志的工具。它支持几乎任何类型的日志，包括系统日志、错误日志和自定义应用程序日志。它可以从许多来源接收日志，这些来源包括 syslog、消息传递（例如 RabbitMQ）和JMX，它能够以多种方式输出数据，包括电子邮件、websockets和Elasticsearch。<br>&emsp;&emsp;Kibana是一个基于Web的图形界面，用于搜索、分析和可视化存储在 Elasticsearch指标中的日志数据。它利用Elasticsearch的REST接口来检索数据，不仅允许用户创建他们自己的数据的定制仪表板视图，还允许他们以特殊的方式查询和过滤数据。<br><a id="more"></a></p><h2 id="ELK架构"><a href="#ELK架构" class="headerlink" title="ELK架构"></a>ELK架构</h2><p>&emsp;&emsp;通常来说，只使用这三个组件就可以进行日志收集了，不过在企业实际生产中，需要用到ELK做集中日志收集的话，日志的产生量都是惊人的，所以通常情况下会需要缓存层来防止elasticsearch被压垮。架构如下图所示。（也可以通过filebeat来收集日志。）<br><img src="https://img-blog.csdnimg.cn/20200103144832731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="ELK架构"></p><h2 id="ELK的部署"><a href="#ELK的部署" class="headerlink" title="ELK的部署"></a>ELK的部署</h2><p>&emsp;&emsp;需要注意的是，ELK的这三个组件版本要一致，否则可能会出现一些不必要的问题。我们这里选用最新版本7.5.1为例，演示主机均为ubuntu1804。</p><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>&emsp;&emsp;我们这里用两台主机来搭建一个elasticsearch集群，一般来说因为他的选举机制，elasticsearch集群都是3、5、7奇数个，不过2台主机也可以使用，我们这里节约主机使用两台主机做演示，IP分别为<code>192.168.32.41</code>、<code>192.168.32.42</code>。</p><p>&emsp;&emsp;官网下载链接为<a href="https://www.elastic.co/cn/downloads/elasticsearch" rel="noopener" target="_blank">https://www.elastic.co/cn/downloads/elasticsearch</a>。<br>&emsp;&emsp;我们这里选择deb安装包安装，也可以选用源码tar包自己解压安装。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//artifacts.elastic.<span class="keyword">co</span>/downloads/elasticsearch/elasticsearch-<span class="number">7.5</span>.<span class="number">1</span>-amd64.<span class="keyword">deb</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个版本的deb包是自带java环境（openjdk11）的，如果主机已经预制java环境，可以去官网下载no-java的版本，使用jdk8的时候有warning，说未来版本将不支持jdk8，建议使用jdk11及以上。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dpkg</span> <span class="selector-tag">-i</span> <span class="selector-tag">elasticsearch-7</span><span class="selector-class">.5</span><span class="selector-class">.1-amd64</span><span class="selector-class">.deb</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;elasticsearch的配置文件路径为<code>/etc/elasticsearch/elasticsearch.yml</code>，需要修改的不多,将集群主机IP设置好就可以了，如下所示<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@elasticsearch1:~<span class="meta"># grep "^[a-Z]" /etc/elasticsearch/elasticsearch.yml</span></span><br><span class="line"><span class="symbol">cluster.name:</span> ELK-CLuster      <span class="meta">#集群名称，名称相同即属于是同一个集群</span></span><br><span class="line"><span class="symbol">node.name:</span> node<span class="number">-1</span>                 <span class="meta">#本机在集群内的节点名称</span></span><br><span class="line"><span class="symbol">path.data:</span> /elasticsearch/data</span><br><span class="line"><span class="symbol">path.logs:</span> /elasticsearch/logs</span><br><span class="line"><span class="symbol">bootstrap.memory_lock:</span> true   <span class="meta">#服务启动的时候锁定足够的内存， 防止数据写入swap</span></span><br><span class="line"><span class="symbol">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="symbol">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="symbol">discovery.seed_hosts:</span> [<span class="string">"192.168.32.41"</span>,<span class="string">"192.168.32.42"</span>]</span><br><span class="line"><span class="symbol">cluster.initial_master_nodes:</span> [<span class="string">"node-1"</span>,<span class="string">"node-2"</span>]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我这里是单独创建了一个日志路径和数据路径，方便管理，并修改属主赋予权限。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/elasticsearch/</span>&#123;data,logs&#125;</span><br><span class="line">chown -R <span class="string">elasticsearch:</span>elasticsearch /elasticsearch</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;除了在配置文件中设置<code>bootstrap.memory_lock: true</code>以外，还需要在启动配置文件中设置允许无限制使用内存，否则启动检查就会报错，导致服务起不来。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">elasticsearch</span>.<span class="title">service</span></span></span><br><span class="line">LimitMEMLOCK=infinity</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;而且根据官方文档<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html" rel="noopener" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</a>，最大30G 以内的内存。<br>&emsp;&emsp;在一般使用中，使用最大内存和最小内存都设置为2G就可以了。<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/elasticsearch/jvm.options</span><br><span class="line"><span class="deletion">-Xms2g</span></span><br><span class="line"><span class="deletion">-Xmx2g</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;另一台主机也同样配置，记得修改<code>node.name</code>，之后就可以启动elasticsearch了。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">enable</span> <span class="comment">--now elasticsearch</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在任意主机使用curl命令可以检查集群的健康状态。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sXGET <span class="string">http:</span><span class="comment">//192.168.32.41:9200/_cluster/health?pretty=true</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;获取到的是一个 json 格式的返回值，那就可以通过 python 对其中的信息进行分析，例如对 status 进行分析，如果等于 green(绿色)就是运行在正常，等于yellow(黄色)表示副本分片丢失， red(红色)表示主分片丢失。<br>&emsp;&emsp;至此，elasticsearch服务的部署就算是完成了。</p><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>&emsp;&emsp;logstash也是一个基于java的插件式服务，很多功能都是依靠于插件来实现的，我们安装官方的安装包，大部分常用插件都是已经预置了，如果还有其他的功能需求，就需要去官网或者github下载插件了。这些之后再说，我们先去官网上将Logstash7.5.1安装包下载下来并部署上。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//artifacts.elastic.<span class="keyword">co</span>/downloads/logstash/logstash-<span class="number">7.5</span>.<span class="number">1</span>.<span class="keyword">deb</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;logstash也同样需要java环境<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apt</span> <span class="string">update</span></span><br><span class="line"><span class="attr">apt</span> <span class="string">install openjdk-8-jdk</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;或者安装oracle的jdk，生产环境还是推荐使用oracle公司的jdk，更加稳定。然后安装logstash<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dpkg</span> <span class="selector-tag">-i</span> <span class="selector-tag">logstash-7</span><span class="selector-class">.5</span><span class="selector-class">.1</span><span class="selector-class">.deb</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对于logstash的配置也很少,不做修改也可以使用，不过我们这里同样还是修改一下数据目录和日志目录<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@logstash1:~# <span class="keyword">grep</span> <span class="string">"^[a-Z]"</span> /etc/logstash/logstash.yml</span><br><span class="line">path.dat<span class="variable">a:</span> /logstash/data</span><br><span class="line">path.<span class="built_in">log</span><span class="variable">s:</span> /logstash/logs</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改属主<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkdir</span> -p /logstash/&#123;<span class="class"><span class="keyword">data</span>,logs&#125;</span></span><br><span class="line"><span class="title">chown</span> -<span class="type">R</span> /logstash</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;logstash的默认执行程序路径为<code>/usr/share/logstash/bin/logstash</code>，这其实也是一个shell脚本文件，脚本中调用java的类库。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@logstash1:~<span class="comment"># /usr/share/logstash/bin/logstash --help</span></span><br><span class="line">Thread.exclusive is deprecated, <span class="keyword">use</span> <span class="keyword">Thread</span>::<span class="keyword">Mutex</span></span><br><span class="line"><span class="keyword">WARNING</span>: Could <span class="keyword">not</span> find logstash.yml which <span class="keyword">is</span> typically located <span class="keyword">in</span> </span><br><span class="line">$LS_HOME/config <span class="keyword">or</span> /etc/logstash. You can specify the <span class="keyword">path</span> <span class="keyword">using</span> <span class="comment">--path.settings.</span></span><br><span class="line"> Continuing <span class="keyword">using</span> the <span class="keyword">defaults</span></span><br><span class="line"><span class="keyword">Usage</span>:</span><br><span class="line">    <span class="keyword">bin</span>/logstash [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -n, <span class="comment">--node.name NAME          Specify the name of this logstash instance, </span></span><br><span class="line">                                  <span class="keyword">if</span> <span class="keyword">no</span> <span class="keyword">value</span> <span class="keyword">is</span> given</span><br><span class="line">                                  it will <span class="keyword">default</span> <span class="keyword">to</span> the <span class="keyword">current</span> hostname.</span><br><span class="line">                                   (<span class="keyword">default</span>: <span class="string">"logstash1"</span>)</span><br><span class="line">    -f, <span class="comment">--path.config CONFIG_PATH Load the logstash config from a specific file</span></span><br><span class="line">                                  <span class="keyword">or</span> directory.  <span class="keyword">If</span> a <span class="keyword">directory</span> <span class="keyword">is</span> given, <span class="keyword">all</span></span><br><span class="line">                                  files <span class="keyword">in</span> that <span class="keyword">directory</span> will be concatenated</span><br><span class="line">                                  <span class="keyword">in</span> lexicographical <span class="keyword">order</span> <span class="keyword">and</span> <span class="keyword">then</span> parsed <span class="keyword">as</span> a</span><br><span class="line">                                  single config file. You can also specify</span><br><span class="line">                                  wildcards (globs) <span class="keyword">and</span> <span class="keyword">any</span> <span class="keyword">matched</span> files will</span><br><span class="line">                                  be loaded <span class="keyword">in</span> the <span class="keyword">order</span> described above.</span><br><span class="line">    -e, <span class="comment">--config.string CONFIG_STRING Use the given string as the configuration</span></span><br><span class="line">                                  data. Same syntax <span class="keyword">as</span> the config file. <span class="keyword">If</span> <span class="keyword">no</span></span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">is</span> specified, <span class="keyword">then</span> the <span class="keyword">following</span> <span class="keyword">is</span></span><br><span class="line">                                  used <span class="keyword">as</span> the <span class="keyword">default</span> <span class="keyword">input</span>:</span><br><span class="line">                                  <span class="string">"input &#123; stdin &#123; type =&gt; stdin &#125; &#125;"</span></span><br><span class="line">                                  <span class="keyword">and</span> <span class="keyword">if</span> <span class="keyword">no</span> <span class="keyword">output</span> <span class="keyword">is</span> specified, <span class="keyword">then</span> the</span><br><span class="line">                                  <span class="keyword">following</span> <span class="keyword">is</span> used <span class="keyword">as</span> the <span class="keyword">default</span> <span class="keyword">output</span>:</span><br><span class="line">                                  <span class="string">"output &#123; stdout &#123; codec =&gt; rubydebug &#125; &#125;"</span></span><br><span class="line">                                  <span class="keyword">If</span> you wish <span class="keyword">to</span> <span class="keyword">use</span> <span class="keyword">both</span> <span class="keyword">defaults</span>, please <span class="keyword">use</span></span><br><span class="line">                                  the <span class="keyword">empty</span> <span class="keyword">string</span> <span class="keyword">for</span> the <span class="string">'-e'</span> flag.</span><br><span class="line">                                   (<span class="keyword">default</span>: nil)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不过常用的选项也就<code>-e</code>和<code>-f</code>，分别是通过命令行指定参数或者通过文件来指定配置参数。我们可以使用命令来测试<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>share<span class="regexp">/logstash/</span>bin/logstash -e <span class="string">'input &#123; stdin&#123;&#125; &#125; output &#123; stdout&#123; codec =&gt; rubydebug &#125;&#125;'</span></span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20200103161950993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="输出日志"><br>&emsp;&emsp;通过标准输入输入信息，并通过标准输出返回日志信息。同样，我们也可以调用input的file插件和output的file插件实现从文件中读取数据，或者写入文件。这样就可以实现对日志文件的抓取了。我们可以先尝试抓取系统日志如<code>syslog</code>。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>share<span class="regexp">/logstash/</span>bin<span class="regexp">/logstash -e 'input &#123; file &#123; path =&gt; "/</span>var<span class="regexp">/log/</span>syslog<span class="string">"&#125; &#125; output &#123; stdout&#123; codec =&gt; rubydebug &#125;&#125;'</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;哈，系统日志如果太多，估计会刷屏的。<br>&emsp;&emsp;不过刚才那些都只是一些基本用法而已，而实际生产中，我们肯定不能使用命令行来手动获取数据，我们需要的是一个可靠的服务，来帮我们自动抓取日志并筛选过滤，这就需要我们使用配置文件来设置了。<br>&emsp;&emsp;例如我们要做的抓取本机的nginx的访问日志、错误日志还有系统日志，并传递至之前配好的elasticsearch中。<br>&emsp;&emsp;那就在路径<code>/etc/logstash/conf.d/</code>目录下，创建一个新的配置文件，使用systemd启动时会自动读取conf.d下的配置文件。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/logstash/conf.d/nginx.conf</span><br><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123; </span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/var/log/syslog"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"syslog"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">file</span> &#123; </span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/apps/nginx/logs/access_json.log"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">"json"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"nginx_accesslog"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">file</span> &#123; </span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">"/apps/nginx/logs/error.log"</span></span><br><span class="line">    <span class="attr">stat_interval</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="attr">start_position</span> =&gt; <span class="string">"beginning"</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">"nginx_errorlog"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"syslog"</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"syslog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">  if [type] == <span class="string">"nginx_accesslog"</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">"192.168.32.41:9200"</span>]</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">"nginx_accesslog-%&#123;+YYYY.MM.dd&#125;</span></span><br><span class="line"><span class="string">  &#125;&#125;</span></span><br><span class="line"><span class="string">  if [type] == "</span>nginx_errorlog<span class="string">" &#123;</span></span><br><span class="line"><span class="string">  elasticsearch &#123;</span></span><br><span class="line"><span class="string">    hosts =&gt; ["</span><span class="number">192.168</span>.<span class="number">32.41</span>:<span class="number">9200</span><span class="string">"]</span></span><br><span class="line"><span class="string">    index =&gt; "</span>nginx_accesslog-%&#123;+YYYY.MM.dd&#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;logstash支持条件判断，多输入以及多输出，设定type规则，来将每一类日志分类在不同的索引，且支持java的时间变量，可以实现根据日期归档每一天的日志，方便查看和统计。<br>&emsp;&emsp;我们可以使用命令来测试脚本的语法是否正确，如果不加<code>-t</code>可以直接以前台进程的方式启动logstash，不过会占据终端，但测试的时候还是蛮方便的。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>share<span class="regexp">/logstash/</span>bin<span class="regexp">/logstash -f /</span>etc<span class="regexp">/log/</span>logstash<span class="regexp">/conf,d/</span>nginx.conf -t</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不过仅仅是这样，是无法统计具体访问时间、访问ip及访问路径的详细信息的，我们需要将nginx的日志序列化，或者说是储存为json格式。<br>&emsp;&emsp;所以修改nginx的配置文件,将日志格式修改一下。<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    log_format access_json '&#123;<span class="string">"@timestamp"</span>:<span class="string">"<span class="variable">$time_iso8601</span>"</span>,'</span><br><span class="line">        '<span class="string">"host"</span>:<span class="string">"<span class="variable">$server_addr</span>"</span>,'</span><br><span class="line">        '<span class="string">"clientip"</span>:<span class="string">"<span class="variable">$remote_addr</span>"</span>,'</span><br><span class="line">        '<span class="string">"size"</span>:$body_bytes_sent,'</span><br><span class="line">        '<span class="string">"responsetime"</span>:$request_time,'</span><br><span class="line">        '<span class="string">"upstreamtime"</span>:<span class="string">"<span class="variable">$upstream_response_time</span>"</span>,'</span><br><span class="line">        '<span class="string">"upstreamhost"</span>:<span class="string">"<span class="variable">$upstream_addr</span>"</span>,'</span><br><span class="line">        '<span class="string">"http_host"</span>:<span class="string">"<span class="variable">$host</span>"</span>,'</span><br><span class="line">        '<span class="string">"uri"</span>:<span class="string">"<span class="variable">$uri</span>"</span>,'</span><br><span class="line">        '<span class="string">"domain"</span>:<span class="string">"<span class="variable">$host</span>"</span>,'</span><br><span class="line">        '<span class="string">"xff"</span>:<span class="string">"<span class="variable">$http_x_forwarded_for</span>"</span>,'</span><br><span class="line">        '<span class="string">"referer"</span>:<span class="string">"<span class="variable">$http_referer</span>"</span>,'</span><br><span class="line">        '<span class="string">"tcp_xff"</span>:<span class="string">"<span class="variable">$proxy_protocol_addr</span>"</span>,'</span><br><span class="line">        '<span class="string">"http_user_agent"</span>:<span class="string">"<span class="variable">$http_user_agent</span>"</span>,'</span><br><span class="line">        '<span class="string">"status"</span>:<span class="string">"<span class="variable">$status</span>"</span>&#125;';</span><br><span class="line"></span><br><span class="line">    access_log  /apps/nginx/logs/access_json.log  access_json;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;PS:加入的属性名称不要有<code>type</code>，否则会影响到logstash做type判断。然后记得在配置文件中注明输入信息为json格式。看到如下信息，则说明日志被成功拆解。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"http_user_agent"</span> =&gt; <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"</span>,</span><br><span class="line">               <span class="string">"path"</span> =&gt; <span class="string">"/apps/nginx/logs/access_json.log"</span>,</span><br><span class="line">         <span class="string">"@timestamp"</span> =&gt; <span class="number">2020</span><span class="number">-01</span><span class="number">-03</span>T08:<span class="number">17</span>:<span class="number">47.000</span>Z,</span><br><span class="line">       <span class="string">"upstreamhost"</span> =&gt; <span class="string">"-"</span>,</span><br><span class="line">                <span class="string">"xff"</span> =&gt; <span class="string">"-"</span>,</span><br><span class="line">       <span class="string">"responsetime"</span> =&gt; <span class="number">0.0</span>,</span><br><span class="line">               <span class="string">"size"</span> =&gt; <span class="number">0</span>,</span><br><span class="line">             <span class="string">"status"</span> =&gt; <span class="string">"304"</span>,</span><br><span class="line">          <span class="string">"http_host"</span> =&gt; <span class="string">"192.168.32.51"</span>,</span><br><span class="line">           <span class="string">"clientip"</span> =&gt; <span class="string">"192.168.32.1"</span>,</span><br><span class="line">             <span class="string">"domain"</span> =&gt; <span class="string">"192.168.32.51"</span>,</span><br><span class="line">            <span class="string">"tcp_xff"</span> =&gt; <span class="string">""</span>,</span><br><span class="line">               <span class="string">"host"</span> =&gt; <span class="string">"192.168.32.51"</span>,</span><br><span class="line">           <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">                <span class="string">"uri"</span> =&gt; <span class="string">"/index.html"</span>,</span><br><span class="line">            <span class="string">"referer"</span> =&gt; <span class="string">"-"</span>,</span><br><span class="line">       <span class="string">"upstreamtime"</span> =&gt; <span class="string">"-"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用<code>systemctl enable --now logstash</code>启动logstash服务，过一会，日志就写入elasticsearch服务器中了，最好将<code>/etc/systemd/system/logstash.service</code>文件的中启动用户组都改为<code>root</code>，避免因为权限问题，导致无法读取数据。<br>&emsp;&emsp;我记得之前遇到过一次，命令行可以正常使用logstash，不过使用systemd启动就一直报错，<code>logstash: could not find java; set JAVA_HOME or ensure java is in PATH</code>,明明环境变量都是正常的，后来在<code>/usr/share/logstash/bin/logstash</code>脚本文件中加了一个<code>JAVA_HOME=/usr/local/jdk</code>环境变量就好了，而之后配的时候就没有遇到这个问题了，这就很奇怪了。</p><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>&emsp;&emsp;日志信息都已经写到elasticsearch服务器中了，不过我们怎么才可以看到具体的日志信息呢？这就需要借助日志展示工具Kibana了。<br>&emsp;&emsp;虽然elasticsearch可视化工具也有不少，例如head、kopf、cerebro等等，不过他们都是监控elasticsearch集群状态的，对日志做展示分析的还是首推开源的官方组件Kibana。<br>&emsp;&emsp;同样下载kibana7.5.1版本<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http<span class="variable">s:</span>//artifacts.elastic.<span class="keyword">co</span>/downloads/kibana/kibana-<span class="number">7.5</span>.<span class="number">1</span>-amd64.<span class="keyword">deb</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;配置上也很简单，设置监听IP及端口，设置elasticsearch主机地址，最后再将语言环境改为中文就可以启动kibana服务了。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kibana1:~<span class="meta"># grep "^[a-Z]" /etc/kibana/kibana.yml</span></span><br><span class="line"><span class="symbol">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="symbol">server.host:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="symbol">elasticsearch.hosts:</span> [<span class="string">"http://192.168.32.41:9200"</span>]</span><br><span class="line"><span class="symbol">i18n.locale:</span> <span class="string">"zh-CN"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;浏览器访问kibana主机的5601端口。<br>&emsp;&emsp;创建索引模式，依次添加索引。<br><img src="https://img-blog.csdnimg.cn/20200103175631933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="kibana"><br>&emsp;&emsp;然后点左边第一个（最上面）的那个discover图标，就可以看到数据了。点击更改，选择对应的索引，还可以创建各种视图等一系列功能这里就不再详细讲解了。都比较简单。<br>&emsp;&emsp;至此ELK的初步部署就算完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;ELK是Elasticsearch、Logstash、Kibana的简称，这三者是核心套件，但并非全部。&lt;br&gt;&amp;emsp;&amp;emsp;Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。&lt;br&gt;&amp;emsp;&amp;emsp;Logstash是一个用来搜集、分析、过滤日志的工具。它支持几乎任何类型的日志，包括系统日志、错误日志和自定义应用程序日志。它可以从许多来源接收日志，这些来源包括 syslog、消息传递（例如 RabbitMQ）和JMX，它能够以多种方式输出数据，包括电子邮件、websockets和Elasticsearch。&lt;br&gt;&amp;emsp;&amp;emsp;Kibana是一个基于Web的图形界面，用于搜索、分析和可视化存储在 Elasticsearch指标中的日志数据。它利用Elasticsearch的REST接口来检索数据，不仅允许用户创建他们自己的数据的定制仪表板视图，还允许他们以特殊的方式查询和过滤数据。&lt;br&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="https://wudihechao.github.io/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="ELK" scheme="https://wudihechao.github.io/tags/ELK/"/>
    
      <category term="Elasticsearch" scheme="https://wudihechao.github.io/tags/Elasticsearch/"/>
    
      <category term="Logstash" scheme="https://wudihechao.github.io/tags/Logstash/"/>
    
      <category term="Kibana" scheme="https://wudihechao.github.io/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>企业级应用——DevOps（一）gitlab的部署与配置</title>
    <link href="https://wudihechao.github.io//blog/73a033d9.html"/>
    <id>https://wudihechao.github.io//blog/73a033d9.html</id>
    <published>2019-12-26T14:28:34.000Z</published>
    <updated>2019-12-29T04:19:21.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;在企业生产中，DEVOPS这个概念越来越火了，不同公司对此都有不同的理解，但有一点毋庸置疑，提到DEVOPS都绕不开CI/CD。CI是continuous integration的简称，意为持续集成，CD是continuous deployment或者Continuous Delivery的缩写，意为持续部署或持续交付。<br><a id="more"></a><br>&emsp;&emsp;持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起并切相互不影响工作。<br>&emsp;&emsp;持续部署是指是基于某种工具或平台实现代码自动化的构建、测试和部署到线上环境以实现交付高质量的产品。持续部署在某种程度上代表了一个开发团队的更新迭代速率。<br>&emsp;&emsp;持续交付是在持续部署的基础之上， 将产品交付到线上环境， 因此持续交付是产品价值的一种交付， 是产品价值的一种盈利的实现。<br>&emsp;&emsp;可以用一个类似戴明环的图来比较形象展示这种生产模式结构。<br><img src="https://img-blog.csdnimg.cn/20191226203217874.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="DevOps"><br>&emsp;&emsp;比较常用到的开源软件有gitlab、Maven、jenkins、saltstack、slastic以及zabbix。其中gitlab和jenkins是最常用的一个组合，也是目前最为火热的结局方案。本文将详细介绍gitlab的部署及使用。</p><h2 id="Gitlib—分布式版本控制系统"><a href="#Gitlib—分布式版本控制系统" class="headerlink" title="Gitlib—分布式版本控制系统"></a>Gitlib—分布式版本控制系统</h2><h3 id="持续集成开源工具"><a href="#持续集成开源工具" class="headerlink" title="持续集成开源工具"></a>持续集成开源工具</h3><p>&emsp;&emsp;我们需要在公司的服务器安装某种程序，该程序用于按照特定格式和方式记录和保存公司多名开发人员不定期提交的源代码，且后期可以按照某种标记及方式对用户提交的数据进行还原，这是我们就需要用到版本控制系统，也就是所谓的持续集成工具。<br>&emsp;&emsp;早期的集中式版本控制系统如CVS(Concurrent Version System)，现已基本淘汰，可能有些公司还在使用SVN(Subversion)作为版本控制系统，不过他的缺点相当明显，集中式管理，太依赖于网络带宽，当大家一起从管理服务器拉代码或提交代码时，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，效率很差。<br>&emsp;&emsp;而gitlab是分布式的版本控制系统，不存在“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作需要提交或者回滚时，就不需要联网了，因为版本库就在你自己的电脑上。需要汇总时，我们将代码提交至gitlab服务器，将每个人的劳动成果也就是分支仓库的代码合并即可。</p><h3 id="部署gitlab"><a href="#部署gitlab" class="headerlink" title="部署gitlab"></a>部署gitlab</h3><p>&emsp;&emsp;具体安装要求及配置可以参考官方文档<br>&emsp;&emsp;<a href="https://about.gitlab.com/install/" rel="noopener" target="_blank">https://about.gitlab.com/install/</a> # Gitlab 服务的安装文档<br>&emsp;&emsp;<a href="https://docs.gitlab.com/ce/install/requirements.html" rel="noopener" target="_blank">https://docs.gitlab.com/ce/install/requirements.html</a> #安装环境要求</p><p>&emsp;&emsp;最好先配置好依赖仓库源，可以配置阿里的镜像仓库源。<br>&emsp;&emsp;官方下载deb安装包比较慢，可以使用清华大学的镜像源下载。</p><p>&emsp;&emsp;我们这里使用gitlab-ce_11.11.8来演示。也可以去下载其他版本，ubuntu 国内下载地址： <a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu/pool/" rel="noopener" target="_blank">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu/pool/</a>。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/gitlab-<span class="keyword">ce</span>/ubuntu/pool/bionic/main/g/gitlab-<span class="keyword">ce</span>/gitlab-ce_11.<span class="number">11.8</span>-<span class="keyword">ce</span>.<span class="number">0</span>_amd64.<span class="keyword">deb</span></span><br><span class="line">dpkg -i gitlab-ce_11.<span class="number">11.8</span>-<span class="keyword">ce</span>.<span class="number">0</span>_amd64.<span class="keyword">deb</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;安装可能需要一段时间，耐心等待。<br>&emsp;&emsp;然后修改gitlab的配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@gitlabUbuntu24:~# grep "^[a-Z ]" /etc/gitlab/gitlab.rb</span><br><span class="line">external_url 'http://192.168.32.24'</span><br><span class="line"> gitlab_rails['gitlab_email_from'] = 'example@qq.com'</span><br><span class="line"> gitlab_rails['smtp_enable'] = true</span><br><span class="line"> gitlab_rails['smtp_address'] = "smtp.qq.com"</span><br><span class="line"> gitlab_rails['smtp_port'] = 465</span><br><span class="line"> gitlab_rails['smtp_user_name'] = "example@qq.com"</span><br><span class="line"> gitlab_rails['smtp_password'] = "keyword"</span><br><span class="line"> gitlab_rails['smtp_domain'] = "qq.com"</span><br><span class="line"> gitlab_rails['smtp_authentication'] = "login"</span><br><span class="line"> gitlab_rails['smtp_enable_starttls_auto'] = true</span><br><span class="line"> gitlab_rails['smtp_tls'] = true</span><br><span class="line"> user['git_user_email'] = "example@#qq.com"</span><br><span class="line"> alertmanager['admin_email'] = 'example@qq.com'</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;将上面这些选项都设置好。例如使用的是QQ邮箱，则需要去邮箱设置里获取授权码，填在<code>password</code>处。因为gitlab是一般是通过邮件来注册和获取密码的，所以这些配置都要有，邮箱最好填企业邮箱或者公司领导邮箱，以避免员工离职等其他风险。<br>然后使用命令让配置文件生效。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时就可以通过命令<code>gitlab-ctl start</code>启动gitlab了。<br>&emsp;&emsp;可以通过<code>gitlab-ctl status</code>命令查看gitlab运行状态，或者后跟组件名称查看具体组件的运行状态。</p><h3 id="gitlab-相关的目录："><a href="#gitlab-相关的目录：" class="headerlink" title="gitlab 相关的目录："></a>gitlab 相关的目录：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/gitlab #配置文件目录</span><br><span class="line">/run/gitlab #运行 pid 目录</span><br><span class="line">/opt/gitlab #安装目录</span><br><span class="line">/var/opt/gitlab #数据目录</span><br></pre></td></tr></table></figure><h3 id="gitlab常用命令"><a href="#gitlab常用命令" class="headerlink" title="gitlab常用命令"></a>gitlab常用命令</h3><p>&emsp;&emsp;gitlab用法与github几乎相同，这里就不再详细介绍。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “name“ #设置全局用户名</span><br><span class="line">git config --global user.email xxx@xx.com #设置全局邮箱</span><br><span class="line">git config --global --list #列出用户全局设置</span><br><span class="line">git add index.html / . #添加指定文件、 目录或当前目录下所有数据到暂存区</span><br><span class="line">git commit -m “11“ #提交文件到工作区</span><br><span class="line">git status #查看工作区的状态</span><br><span class="line">git push #提交代码到服务器</span><br><span class="line">git pull #获取代码到本地</span><br><span class="line">git log #查看操作日志</span><br><span class="line">vim .gitignore #定义忽略文件</span><br><span class="line">git reset --hard HEAD^^ #git 版本回滚， HEAD 为当前版本，加一个^为上一个， ^^为上上一个版本</span><br><span class="line">git reflog # #获取每次提交的 ID，可以使用--hard 根据提交的 ID 进行版本回退</span><br><span class="line">git reset --hard 5ae4b06 #回退到指定 id 的版本</span><br><span class="line">git branch #查看当前所处的分支</span><br><span class="line">git checkout -b develop #创建并切换到一个新分支</span><br><span class="line">git checkout develop #切换分支</span><br></pre></td></tr></table></figure></p><h3 id="gitlab数据备份"><a href="#gitlab数据备份" class="headerlink" title="gitlab数据备份"></a>gitlab数据备份</h3><p>&emsp;&emsp;gitlab可以通过命令<code>gitlab-rake</code>来备份数据。数据备份前，需要停止<code>unicorn</code>、<code>sidekiq</code>组件服务。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br><span class="line">gitlab-rake gitlab:backup:create #在任意目录即可备份当前 gitlab 数据</span><br><span class="line">gitlab-ctl start #备份完成后启动 gitlab</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;备份完成的数据储存在<code>/var/opt/gitlab/backups/</code>路径下,生成与时间相关的tar包。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@gitlabUbuntu24:~# ll /var/opt/gitlab/backups/</span><br><span class="line">total 4600</span><br><span class="line">drwx------  2 git  root    4096 Dec 25 14:41 ./</span><br><span class="line">drwxr-xr-x 20 root root    4096 Dec 25 11:02 ../</span><br><span class="line">-rw-------  1 git  git  4700160 Dec 25 14:41 1577256108_2019_12_25_11.11.8_gitlab_backup.tar</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的是，命令备份仅仅是备份了gitlab中的数据，通常我们我们的备份脚本中还需要备份以下文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/opt/gitlab/nginx/conf #nginx 配置文件</span><br><span class="line">/etc/gitlab/gitlab.rb #gitlab 配置文件</span><br><span class="line">/etc/gitlab/gitlab-secrets.json #key 文件</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用命令<code>gitlab-rake gitlab:backup:restore BACKUP=备份文件名</code>可以恢复之前的备份数据（文件名到时间戳即可）。同样，执行恢复命令之前也要先关闭<code>unicorn</code>、<code>sidekiq</code>组件服务。恢复时，需要输入yes确认。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1577256108_2019_12_25_11.11.8</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20191226215657234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="gitlab"></p><h3 id="gitlab的关闭注册"><a href="#gitlab的关闭注册" class="headerlink" title="gitlab的关闭注册"></a>gitlab的关闭注册</h3><p>&emsp;&emsp;服务正常启动之后，就可以访问主机的IP或者域名，登陆gitlab系统了。gitlab和github极为相似，也支持邮箱注册。，第一次访问，会放我们设置管理员账户密码，我们使用管理员账户登录，用户名为root。<br>&emsp;&emsp;gitlab默认是开放注册的，而我们作为企业内部使用的版本管理系统，肯定不希望大家随便创建用户来访问，这样很不便于管理。<br>&emsp;&emsp;我们可以在点击中间的小扳手图标，选择setting设置，将sign-up功能取消，这样登录界面就无法注册了。<br><img src="https://img-blog.csdnimg.cn/20191226220453316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;注意，小心别关错了，要是把sign-in功能取消就没法登陆了，哪怕使用root权限账号退出去也就没法登陆了。如果真的不幸将gitlab的sign-in功能取消掉，那只能使用命令行的方式修改数据库中设置了。<br>&emsp;&emsp;因为gitlab目前版本默认使用的psql，所以修改数据库的方式，跟mysql不同，具体如下<br>先切换至gitlab-psql用户。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - gitlab-psql</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用 -h指定数据库路径 -d指定数据库，连接psql数据库。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">psql -h /var/opt/gitlab/postgresql -d gitlabhq_production</span><br><span class="line"><span class="keyword">UPDATE</span> application_settings <span class="keyword">SET</span> password_authentication_enabled_for_web=<span class="literal">true</span>;</span><br><span class="line">\q</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改完数据后，重启gitlab服务。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时，web界面就又可以登陆了。</p><h3 id="gitlab的中文汉化"><a href="#gitlab的中文汉化" class="headerlink" title="gitlab的中文汉化"></a>gitlab的中文汉化</h3><p>&emsp;&emsp;gitlab默认语音为英语，有时有些专业数据或者不太常用的选项配置我们可能无法准确理解它的含义，所以将gitlab汉化成中文还是有一定必要的。<br>&emsp;&emsp;gitlab的每个用户，可以点击用户头像，设置，设置偏好，选择语音。<img src="https://img-blog.csdnimg.cn/20191227101448871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;选择中文之后刷新，就可看到一部分菜单变为了中文。但是也仅仅是菜单变成了中文而已，很多选项和图标都还是英文显示，如果想彻底汉化为中文，则需要我们去下载中文汉化补丁了。<br>&emsp;&emsp;汉化补丁是第三方爱好者提供，github地址是<a href="https://gitlab.com/xhang/gitlab" rel="noopener" target="_blank">https://gitlab.com/xhang/gitlab</a>，找到对应版本的gitlab汉化包。<br>&emsp;&emsp;gitlabv11.11.8汉化包的下载地址如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://gitlab.com/xhang/gitlab/-/archive/v11.11.8-zh/gitlab-v11.11.8-zh.tar.gz</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后先停止gitlab<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;备份并替换文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xvf gitlab-v11.11.8-zh.tar.gz</span><br><span class="line">cp -rp /opt/gitlab/embedded/service/gitlab-rails /opt/gitlab-rails.bak</span><br><span class="line">cp -rf gitlab-v11.11.8-zh/* /opt/gitlab/embedded/service/gitlab-rails/</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时，汉化就完成了，可以直接启动gitlab了。就可以看到页面都变成了中文了，效果图如下。<br><img src="https://img-blog.csdnimg.cn/20191227103139614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="gitlab仪表盘"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在企业生产中，DEVOPS这个概念越来越火了，不同公司对此都有不同的理解，但有一点毋庸置疑，提到DEVOPS都绕不开CI/CD。CI是continuous integration的简称，意为持续集成，CD是continuous deployment或者Continuous Delivery的缩写，意为持续部署或持续交付。&lt;br&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="https://wudihechao.github.io/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="DevOps" scheme="https://wudihechao.github.io/tags/DevOps/"/>
    
      <category term="CI/CD" scheme="https://wudihechao.github.io/tags/CI-CD/"/>
    
      <category term="gitlab" scheme="https://wudihechao.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>企业级应用——监控（一）zabbix的部署</title>
    <link href="https://wudihechao.github.io//blog/366b680c.html"/>
    <id>https://wudihechao.github.io//blog/366b680c.html</id>
    <published>2019-12-20T09:34:00.000Z</published>
    <updated>2019-12-29T02:43:20.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;常见的开源监控软件有：cacti、nagios、zabbix、smokeping、open-falcon等，本文主要介绍目前使用较多的开源监控软件zabbix，针对容器环境的开源监控软件Prometheus下次再讲解。<br><a id="more"></a><br>&emsp;&emsp;zabbix功能强大，可横向扩展、自定义监控项、支持多种监控方式、可监控网络与服务等。</p><h2 id="zabbix功能简述"><a href="#zabbix功能简述" class="headerlink" title="zabbix功能简述"></a>zabbix功能简述</h2><ul><li>数据采集<br>zabbix是周期性采集时序数据。<br>&emsp;&emsp;采集对象可以有：服务器、路由器、交换机、存储、防火墙、IP、PORT、URL、自定义监控对象…<br>&emsp;&emsp;采集目标：监控项，指标数据（metrics data）<br>&emsp;&emsp;数据采集方式：zabbix-server，zabbix-proxy，zabbix-agent<br>&emsp;&emsp;按照有无代理分类：<br>&emsp;&emsp;&emsp;&emsp;Agentless：SNMP,Telnet,ssh, IPMI, JMX,<br>&emsp;&emsp;&emsp;&emsp;Agent：zabbix agent</li><li>数据存储<br>可以储存历史数据和局势数据，还有阈值。<br>&emsp;&emsp;历史数据: 每个监控项采集到的每个监控值<br>&emsp;&emsp;趋势数据: 趋势表里主要保留某个监控项一个小时内历史数据的最大值、最小值和平均值以及该监控项一个小时内所采集到的数据个数。<br>&emsp;&emsp;阈值：可按照预定义的阈值等级实现分层报警<br>支持的数据库类型有：<br>&emsp;&emsp;SQL: MySQL/MariaDB(Zabbix)<br>&emsp;&emsp;NoSQL：Redis(Open-falcon)<br>&emsp;&emsp;rrd: Round Robin Database(Cacti)</li><li>数据展示<br>可以使用原生的zabbix web界面可以展示graph -&gt; screen -&gt; slideshow(将多个screen以幻灯片的方式进行轮流展示)<br>还支持以zabbix为数据源，在grafana展示更绚丽的界面。</li><li>报警通知<br>支持email,短信,微信,语音等多种方式报警通知，也可以实现故障自治愈。<br>host (host groups) <- templates #从模板继承告警配置 host -> items -&gt; triggers -&gt; action (条件-conditions, 操作-operations) #自定义告警配置<h2 id="zabbix架构"><a href="#zabbix架构" class="headerlink" title="zabbix架构"></a>zabbix架构</h2>&emsp;&emsp;在zabbix服务中，一般都包含有<code>zabbix-server</code>、<code>zabbix-agent</code>、<code>zabbix-proxy</code>，及数据库，结构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191219204138569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="zabbix结构示意图"><br>&emsp;&emsp;一般都需要在被监控端安装<code>zabbix-agent</code>服务来抓取数据，然后汇总到<code>zabbix-server</code> 端来展示分析监控报警，如果agent过多或者可能不同机房的数据，可以通过<code>zabbix-proxy</code>来暂存收集数据，之后在汇总至<code>zabbix-server</code>端，所以<code>zabbix-proxy</code>端及<code>zabbix-server</code> 端都需要一个mysql数据库来储存即时及历史监控数据的（zabbix-proxy处临时储存）。而且整个体系中最重要的就是数据库了，数据都在数据库中，只要数据库中的数据不丢失，重建一个zabbix监控架构还是比较容易的，所以可以对数据库做主从复制高可用，可参见<a href="https://blog.csdn.net/MicePro/article/details/101352554" rel="noopener" target="_blank">之前文章</a>。<h2 id="zabbix部署"><a href="#zabbix部署" class="headerlink" title="zabbix部署"></a>zabbix部署</h2><h3 id="zabbix-server"><a href="#zabbix-server" class="headerlink" title="zabbix server"></a>zabbix server</h3><h4 id="包管理工具安装"><a href="#包管理工具安装" class="headerlink" title="包管理工具安装"></a>包管理工具安装</h4>&emsp;&emsp;我们先来搭建<code>zabbix-server</code>端。<br>&emsp;&emsp;对于Ubuntu系统：<br>先下载配置镜像仓库,并apt安装<code>zabbix-server-mysql</code> 、<code>zabbix-frontend-php</code> 及<code>zabbix-agent</code>，其中zabbix-server的二进制程序及启动配置文件都在在<code>zabbix-server-mysql</code>安装包里。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>repo.zabbix.com<span class="regexp">/zabbix/</span><span class="number">4.0</span><span class="regexp">/ubuntu/</span>pool<span class="regexp">/main/</span>z<span class="regexp">/zabbix-release/</span>zabbix-release_4.<span class="number">0</span>-<span class="number">3</span>%<span class="number">2</span>Bbionic_all.deb</span><br><span class="line">dpkg -i zabbix-release_4.<span class="number">0</span>-<span class="number">3</span>+bionic_all.deb</span><br><span class="line">apt update</span><br><span class="line">apt -y install zabbix-server-mysql zabbix-frontend-php zabbix-agent</span><br></pre></td></tr></table></figure></-></li></ul><p>&emsp;&emsp;然后开始安装zabbix-server的数据库。可以与zabbix-server复用一台主机，也可以单独一台主机。我们这里使用一台新的主机,apt安装好mariadb（与mysql操作一样）。<br>&emsp;&emsp;先以root身份登陆mysql主机，然后为zabbix创建一个数据库，例如zabbix_server，再创建一个zabbix用户，并授权<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; <span class="keyword">create</span> <span class="keyword">database</span> zabbix_server <span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_bin;</span><br><span class="line">MariaDB [mysql]&gt;<span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> zabbix_server.* <span class="keyword">to</span> zabbix@"192.168.32.%" identified <span class="keyword">by</span> "zabbix";</span><br><span class="line">MariaDB [mysql]&gt;flush <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后回到zabbix-server主机，安装一个mysql客户端，并测试可否用之前创建的zabbix账号登录数据库。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt mysql-client -y</span><br><span class="line">mysql -uzabbix -pzabbix -h192<span class="number">.168</span><span class="number">.32</span><span class="number">.20</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;确保可以登陆之后，导入数据库表结构<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /usr/<span class="keyword">share</span>/doc/zabbix-<span class="keyword">server</span>-mysql/<span class="keyword">create</span>.<span class="keyword">sql</span>.gz | mysql -uzabbix -pzabbix -h192<span class="number">.168</span><span class="number">.32</span><span class="number">.20</span> zabbix_server</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时在登入数据库服务器，使用命令查询，可以看到已经生成了很多表<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> zabbix_server;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后编辑zabbix配置文件<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/zabbix/zabbix_server.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改数据库相关信息，其他的可以不做修改。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">root@DockerUbuntu19:~# grep "^[a-Z]" /etc/zabbix/zabbix_server.conf</span></span><br><span class="line">LogFile=/var/log/zabbix/zabbix_server.log</span><br><span class="line">LogFileSize=1</span><br><span class="line">PidFile=/var/run/zabbix/zabbix_server.pid</span><br><span class="line">SocketDir=/var/run/zabbix</span><br><span class="line">DBHost=192.168.32.20</span><br><span class="line">DBName=zabbix_server</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br><span class="line">StartTrappers=10</span><br><span class="line">Timeout=30</span><br><span class="line">AlertScriptsPath=/usr/lib/zabbix/alertscripts</span><br><span class="line">ExternalScripts=/usr/lib/zabbix/externalscripts</span><br><span class="line">FpingLocation=/usr/bin/fping</span><br><span class="line">Fping6Location=/usr/bin/fping6</span><br><span class="line">LogSlowQueries=3000</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;重启zabbix服务。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">restart</span> zabbix-<span class="keyword">server</span> zabbix-agent apache2</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时访问zabbix-server主机对应的IP或者域名,加上路径<code>zabbix/setup.php</code>就可以访问zabbix的web界面进行检查配置了。<br>在环境检查时，可能会有一项报错，提示<code>PHP option date.timezone</code>检查unkown。虽然不影响服务启动，不过我们最好还是将他解决掉。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/zabbix/apache.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;搜索<code>timezone</code>,将值改为<code>php_value date.timezone Asia/Shanghai</code>。注意，有两个timezone设置，分别是针对PHP5.版本和PHP7.版本，我们修改7版本的就可以了，也可以都修改。然后重启服务。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">restart</span> zabbix-<span class="keyword">server</span> zabbix-agent apache2</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时，再刷新一下网页，就可以看到所有检查都是OK状态了。正确填写数据库信息和server主机信息，点击Finish，配置就完成了，会自动跳转至登录界面，默认用户名为<code>Admin</code>，默认密码为<code>zabbix</code>。</p><h4 id="编译安装zabbix"><a href="#编译安装zabbix" class="headerlink" title="编译安装zabbix"></a>编译安装zabbix</h4><p>&emsp;&emsp;源码编译安装zabbix的话,先下载源码包。<br>&emsp;&emsp;下载路径为<a href="https://jaist.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/" rel="noopener" target="_blank">https://jaist.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/</a>。<br>&emsp;&emsp;我们这里以4.015版本为例<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https:<span class="comment">//jaist.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/4.0.15/zabbix-4.0.15.tar.gz</span></span><br><span class="line">tar xf zabbix<span class="number">-4.0</span><span class="number">.15</span>.tar.gz</span><br><span class="line">cd zabbix<span class="number">-4.0</span><span class="number">.15</span>/</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;编译安装需要我们自己来创建zabbix用户组。<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g<span class="number"> 1111 </span>zabbix <span class="comment">#创建zabbix用户和组</span></span><br><span class="line">useradd -u<span class="number"> 1111 </span>-g<span class="number"> 1111 </span>zabbix</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;安装相关依赖的安装包<br>&emsp;&emsp;CentOS:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc libxml2-devel <span class="keyword">net</span>-snmp <span class="keyword">net</span>-snmp-devel curl curl-devel php phpbcmath php-mbstring mariadb mariadb-devel -<span class="built_in">y</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;Ubuntu:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt-<span class="keyword">get</span> install apache2 apache2-bin apache2-data apache2-utils fontconfig-config fonts-dejavu-core fping libapache2-mod-php libapache2-mod-php7<span class="number">.2</span> libapr1 libaprutil1 libaprutil1-dbd-sqlite3 libaprutil1-ldap libfontconfig1 libgd3 libiksemel3 libjbig0 libjpeg-turbo8 libjpeg8 liblua5<span class="number">.2</span><span class="number">-0</span> libodbc1 libopenipmi0 libsensors4 libsnmp-base libsnmp30 libsodium23 libssh2<span class="number">-1</span> libtiff5 libwebp6 libxpm4 php-bcmath php-common php-gd php-ldap php-mbstring php-mysql php-xml php7<span class="number">.2</span>-bcmath php7<span class="number">.2</span>-cli php7<span class="number">.2</span>-common php7<span class="number">.2</span>-gd php7<span class="number">.2</span>-json php7<span class="number">.2</span>-ldap php7<span class="number">.2</span>-mbstring php7<span class="number">.2</span>-mysql php7<span class="number">.2</span>-opcache php7<span class="number">.2</span>-readline php7<span class="number">.2</span>-xml snmpd ssl-cert ttf-dejavu-core libmysqlclient-dev libxml2-dev libxml2 snmp libsnmp-dev libevent-dev openjdk<span class="number">-8</span>-jdk curl libcurl4-openssl-dev</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后就可以编译并安装了。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./configure</span> <span class="params">--prefix=/apps/zabbix_server</span> \</span><br><span class="line"><span class="params">--enable-server</span> <span class="params">--enable-agent</span> <span class="params">--with-mysql</span> \</span><br><span class="line"><span class="params">--with-net-snmp</span> <span class="params">--with-libcurl</span> <span class="params">--with-libxml2</span> <span class="params">--enable-java</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;之后流程就与之前一样。</p><h4 id="设置中文web页面及乱码问题"><a href="#设置中文web页面及乱码问题" class="headerlink" title="设置中文web页面及乱码问题"></a>设置中文web页面及乱码问题</h4><p>如果Ubuntu系统安装时为选择中文语言，则web界面大概率是英文界面，可能会对我们的使用有一定影响。<br>点击右上角的用户头像标志，可以选择语音。不过如果系统没有安装中文时，是无法选择中文的。<br><img src="https://img-blog.csdnimg.cn/20191219222043682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;所以需要我们在ubuntu系统中安装并设置中文简体语言环境.。<br>&emsp;&emsp;1、安装简体中文语言环境<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install <span class="keyword">language</span>-pack-zh*</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;2、增加中文语言环境变量<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/environment</span><br><span class="line">PATH=<span class="string">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"</span></span><br><span class="line">LANG=<span class="string">"zh_CN.UTF-8"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;3、重新设置本地配置<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dpkg-reconfigure locales</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时刷新网页，就可以选择中文<code>Chinese(zh_CN)</code>了，点Update修改保存。此时就可以看到界面变成中文了。不过这时，在图形等界面，大概率会出现字符无法显示的乱码情况，这是由于当前系统有些监控项部分显示有乱码，使由于web界面显示为中文但是系统没有相关字体支持，因此需要相关字体的支持才能正常显示。这时需要我们自己配置一个字体并修改zabbix的font设置。<br>&emsp;&emsp;可以去网上下载字体,也可以从windows中获取已有字体。<br>&emsp;&emsp;在windows中路径为<code>控制面板\外观和个性化\字体</code>（复制至地址栏就可以找到了）<br><img src="https://img-blog.csdnimg.cn/20191220100745893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="字体"><br>&emsp;&emsp;不过需要注意的是，里面有的字体是otf格式，zabbix无法识别，要选择ttf格式的字体才可以。<br><img src="https://img-blog.csdnimg.cn/20191220101154993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="otf"><br><img src="https://img-blog.csdnimg.cn/20191220101209572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="ttf"><br>&emsp;&emsp;将选好的或者下载好的ttf格式字体，拷贝至<code>zabbix-server</code>主机的zabbix安装目录下的fonts目录里。<br>&emsp;&emsp;如果是ubuntu通过apt安装，则为<code>/usr/share/zabbix/assets/fonts</code>，如果是编译安装则可通过<code>find</code>命令搜索一下<code>find /PATH(安装路径) -name fonts</code>。<br>&emsp;&emsp;可以看到里面已经有一个字体文件了的（虽然是个软链接）。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu19:~# ll /usr/share/zabbix/assets/fonts</span><br><span class="line">总用量 <span class="number">11520</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> <span class="number">12</span>月 <span class="number">18</span> <span class="number">18</span>:<span class="number">59</span> ./</span><br><span class="line">drwxr-xr-x <span class="number">5</span> root root     <span class="number">4096</span> <span class="number">12</span>月 <span class="number">18</span> <span class="number">17</span>:<span class="number">43</span> ../</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root       <span class="number">38</span> <span class="number">12</span>月 <span class="number">18</span> <span class="number">17</span>:<span class="number">44</span> graphfont.ttf -&gt; /etc/alternatives/zabbix-frontend-font</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">11785184</span> <span class="number">12</span>月 <span class="number">18</span> <span class="number">18</span>:<span class="number">59</span> simkai.ttf</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;将我们准备好的ttf文件拷贝至此目录，修改zabbix环境变量配置文件(apt安装路径为/usr/share/zabbix/include/defines.inc.php)<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>share<span class="regexp">/zabbix/</span></span><br><span class="line">vim <span class="keyword">include</span><span class="regexp">/defines.inc.php</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;搜索替换<code>graphfont</code>为我们期望的字体名称。一共有两处。都替换了即可。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,          <span class="string">'graphfont'</span>); <span class="comment">// font file name</span></span><br><span class="line"><span class="class"><span class="keyword">define</span></span>(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,           <span class="string">'simkai'</span>); <span class="comment">// font file name</span></span><br><span class="line">- - -</span><br><span class="line">#define(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'graphfont'</span>);</span><br><span class="line"><span class="class"><span class="keyword">define</span></span>(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'simkai'</span>);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不需要重启zabbix及apache，修改后的字体文件即可直接生效。<br>&emsp;&emsp;至此zabbix-server端的配置就完成了。</p><h3 id="zabbix-proxy"><a href="#zabbix-proxy" class="headerlink" title="zabbix proxy"></a>zabbix proxy</h3><h4 id="zabbix-proxy对比zbbbix-server"><a href="#zabbix-proxy对比zbbbix-server" class="headerlink" title="zabbix proxy对比zbbbix server"></a>zabbix proxy对比zbbbix server</h4><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">zabbxy proxy</th><th style="text-align:center">zabbix server</th></tr></thead><tbody><tr><td style="text-align:center">轻量级</td><td style="text-align:center">是</td><td style="text-align:center">相对重量级</td></tr><tr><td style="text-align:center">图形</td><td style="text-align:center">无</td><td style="text-align:center">带图形控制界面</td></tr><tr><td style="text-align:center">可以独立工作</td><td style="text-align:center">是，可以独立采集数据并存储</td><td style="text-align:center">是，即数据采集、存储、分析、展示于一体</td></tr><tr><td style="text-align:center">易维护</td><td style="text-align:center">是，配置完成后基本无需管理</td><td style="text-align:center">维护也不难</td></tr><tr><td style="text-align:center">独立数据库</td><td style="text-align:center">保留少量最近数据</td><td style="text-align:center">保留指定时间内的所有数据</td></tr><tr><td style="text-align:center">报警通知</td><td style="text-align:center">否，代理服务器不发送邮件通知</td><td style="text-align:center">支持邮件、短信等告警机制</td></tr></tbody></table><h4 id="zabbix-proxy版本选择"><a href="#zabbix-proxy版本选择" class="headerlink" title="zabbix proxy版本选择"></a>zabbix proxy版本选择</h4><p>&emsp;&emsp;zabbix proxy的大版本必须要和zabbix server版本一致，否则会导致出现zabbix server与zabbix proxy不兼容问题，会提示报错：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy <span class="string">"zabbix-proxy-active"</span> protocol version 3.2 differs <span class="keyword">from</span><span class="built_in"> server </span>version 4.0</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;确认下zabbix-server的版本<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu19:/usr/share/zabbix/assets/fonts# zabbix_server -V</span><br><span class="line">zabbix_server (Zabbix) <span class="number">4.0</span><span class="number">.15</span></span><br><span class="line">Revision <span class="number">992445e02</span>c <span class="number">25</span> November <span class="number">2019</span>, compilation time: Nov <span class="number">25</span> <span class="number">2019</span> <span class="number">09</span>:<span class="number">01</span>:<span class="number">31</span></span><br><span class="line"></span><br><span class="line">Copyright (C) <span class="number">2019</span> Zabbix SIA</span><br><span class="line">License GPLv2+: GNU GPL version <span class="number">2</span> <span class="keyword">or</span> later &lt;http:<span class="comment">//gnu.org/licenses/gpl.html&gt;.</span></span><br><span class="line">This <span class="keyword">is</span> free software: you are free to change <span class="keyword">and</span> redistribute it according to</span><br><span class="line">the license. There <span class="keyword">is</span> NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">This product includes software developed by the OpenSSL Project</span><br><span class="line"><span class="keyword">for</span> use <span class="keyword">in</span> the OpenSSL Toolkit (http:<span class="comment">//www.openssl.org/).</span></span><br><span class="line"></span><br><span class="line">Compiled with OpenSSL <span class="number">1.1</span><span class="number">.0</span>g  <span class="number">2</span> Nov <span class="number">2017</span></span><br><span class="line">Running with OpenSSL <span class="number">1.1</span><span class="number">.1</span>  <span class="number">11</span> Sep <span class="number">2018</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以我们最好也安装相同版本的zabbix-proxy。</p><h4 id="zabbix-proxy部署"><a href="#zabbix-proxy部署" class="headerlink" title="zabbix proxy部署"></a>zabbix proxy部署</h4><p>&emsp;&emsp;因为proxy也需要一个数据库，可以选择复用server端的数据库，或者再另外创建一个。我们这里复用之前server端的数据库。<br>&emsp;&emsp;所以在之前的MariaDB数据库中，新建一个库，并创建对应权限用户。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; <span class="keyword">create</span> <span class="keyword">database</span> zabbix_proxy;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; <span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> zabbix_proxy.* <span class="keyword">to</span> proxy@"172.18.32.%" identified <span class="keyword">by</span> "proxy";</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.10</span> sec)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;回到proxy主机，然后去官方镜像仓库<a href="https://repo.zabbix.com/zabbix/4.0/" rel="noopener" target="_blank">https://repo.zabbix.com/zabbix/4.0/</a>找到对应系统、对应版本的安装包路径<br>&emsp;&emsp;CentOS：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https:<span class="regexp">//</span>repo.zabbix.com<span class="regexp">/zabbix/</span><span class="number">4.0</span><span class="regexp">/rhel/</span><span class="number">7</span><span class="regexp">/x86_64/</span>zabbix-proxy-mysql-<span class="number">4.0</span>.<span class="number">15</span>-<span class="number">1</span>.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;Ubuntu：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>repo.zabbix.com<span class="regexp">/zabbix/</span><span class="number">4.0</span><span class="regexp">/ubuntu/</span>pool<span class="regexp">/main/</span>z<span class="regexp">/zabbix-release/</span>zabbix-release_4.<span class="number">0</span>-<span class="number">3</span>%<span class="number">2</span>Bbionic_all.deb</span><br><span class="line">dpkg -i zabbix-release_4.<span class="number">0</span>-<span class="number">3</span>+bionic_all.deb</span><br><span class="line">apt update</span><br><span class="line">apt install zabbix-proxy-mysql</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;导入proxy的数据库表（CentOS和Ubuntu路径可能不同，不过名字都叫schema.sql.gz）<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /usr/share/doc/zabbix-proxy-mysql<span class="number">-4.0</span><span class="number">.15</span>/schema.sql.gz | mysql -uproxy -pproxy -h192<span class="number">.168</span><span class="number">.32</span><span class="number">.20</span> zabbix_proxy</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改配置文件<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_proxy.conf</span><br><span class="line"></span><br><span class="line">ProxyMode=1 <span class="comment">#0为主动，1为被动</span></span><br><span class="line">Server=192.168.32.19 <span class="comment">#zabbix server服务器的地址或主机名</span></span><br><span class="line">Hostname=Zabbix proxy <span class="comment">#代理服务器名称，需要与zabbix server添加代理时候的proxyname是一致的！</span></span><br><span class="line">ListenPort=10051 <span class="comment">#zabbix proxy监听端口</span></span><br><span class="line">LogFile=/var/log/zabbix/zabbix_proxy.log</span><br><span class="line">EnableRemoteCommands=1 <span class="comment">#允许zabbix server执行远程命令</span></span><br><span class="line">PidFile=/var/run/zabbix/zabbix_proxy.pid</span><br><span class="line">SocketDir=/var/run/zabbix</span><br><span class="line">DBHost=192.168.32.20 <span class="comment">#数据库服务器地址</span></span><br><span class="line">DBName=zabbix_proxy <span class="comment">#使用的数据库名称</span></span><br><span class="line">DBUser=proxy <span class="comment">#连接数据库的用户名称</span></span><br><span class="line">DBPassword=proxy <span class="comment">#数据库用户密码</span></span><br><span class="line">DBPort=3306 <span class="comment">#数据库端口</span></span><br><span class="line">ProxyLocalBuffer=720 <span class="comment">#已经提交到zabbix server的数据保留时间</span></span><br><span class="line">ProxyOfflineBuffer=720 <span class="comment">#未提交到zabbix server的时间保留时间</span></span><br><span class="line">HeartbeatFrequency=60 <span class="comment">#心跳间隔检测时间，默认60秒，范围0-3600秒，被动模式不使用</span></span><br><span class="line">ConfigFrequency=5 <span class="comment">#间隔多少秒从zabbix server获取监控项信息</span></span><br><span class="line">DataSenderFrequency=5 <span class="comment">#数据发送时间间隔，默认为1秒，范围为1-3600秒，被动模式不使用</span></span><br><span class="line">StartPollers=20 <span class="comment">#启动的数据采集器数量</span></span><br><span class="line">CacheSize=2G <span class="comment">#保存监控项而占用的最大内存</span></span><br><span class="line">HistoryCacheSize=2G <span class="comment">#保存监控历史数据占用的最大内存</span></span><br><span class="line">HistoryIndexCacheSize=128M <span class="comment">#历史索引缓存的大小</span></span><br><span class="line">Timeout=30 <span class="comment">#监控项超时时间，单位为秒</span></span><br><span class="line">LogSlowQueries=3000 <span class="comment">#毫秒，多久的数据库查询会被记录到日志</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后在web界面添加proxy，主动模式是proxy端主动向server端推送数据，所以不需要填写IP，被动模式是server端向proxy拉取数据，需要填写proxy端IP或者域名DNS。选在主动代理或者被动代理，视情况而定，要与配置文件中相同。<br><img src="https://img-blog.csdnimg.cn/20191220161035716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;至此，zabbix proxy端也就配置好了。</p><h3 id="zabbix-agent"><a href="#zabbix-agent" class="headerlink" title="zabbix agent"></a>zabbix agent</h3><h4 id="agent工作模式"><a href="#agent工作模式" class="headerlink" title="agent工作模式"></a>agent工作模式</h4><p>&emsp;&emsp;一般来说，zabbix agent与proxy有两种工作模式，一个是主动模式，即被监控端主动向server端或者proxy端发起请求，请求监控项列表，并按照列表的内容主动定时推送监控信息，此时agent端使用随机端口访问server端或者proxy端的固定端口（10051端口）；另一个是被动模式，是server端或者proxy依照设定好的监控项条目，直接去agent段获取相应的数据，此时是agent端打开固定端口（10050）等待请求。<br>&emsp;&emsp;主动模式与被动模式中的主动与被动，是相对于agent端来说的，agent主动的就叫做主动模式，agent端被动的就叫做被动模式。</p><h4 id="zabbix-agent部署"><a href="#zabbix-agent部署" class="headerlink" title="zabbix agent部署"></a>zabbix agent部署</h4><p>&emsp;&emsp;在被监控主机上安装zabbix-agent安装包。流程与之前一样。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">install</span> zabbix-<span class="keyword">agent</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改配置文件，主要需要设置<code>Server</code>和<code>ServerActive</code>，其他保持默认就可以了。<code>Server</code>是控制允许哪个主机可以从本机上拉取数据，一般把server端和paroxy端都写上，方便修改(，其实只写proxy端ip就可以了)，<code>ServerActive</code>是设置向哪个主机请求主动监控配置的，如果打算使用被动模式，则可不进行设置此项，而且设置了也不会生效。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">root@DockerUbuntu21:~# grep "^[a-Z]" /etc/zabbix/zabbix_agentd.conf</span></span><br><span class="line">PidFile=/var/run/zabbix/zabbix_agentd.pid</span><br><span class="line">LogFile=/var/log/zabbix-agent/zabbix_agentd.log</span><br><span class="line">LogFileSize=1</span><br><span class="line">Server=192.168.32.19,192.168.32.20</span><br><span class="line">ListenPort=10050</span><br><span class="line">StartAgents=4</span><br><span class="line">ServerActive=127.0.0.1</span><br><span class="line">Hostname=192.168.32.21</span><br><span class="line">Timeout=20</span><br><span class="line">Include=/etc/zabbix/zabbix_agentd.conf.d/*.conf</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;重启agent服务，是配置生效<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart zabbix-agent</span></span><br></pre></td></tr></table></figure></p><h4 id="配置监控"><a href="#配置监控" class="headerlink" title="配置监控"></a>配置监控</h4><p>&emsp;&emsp;之前的一系列操作，只是完成了一个服务基础，之后的操作才是重点，也就是配置监控。<br>&emsp;&emsp;进入zabbix的web管理界面，可以看到有很多项目，我们选择配置——主机——创建主机，来添加我们的监控对象。<br><img src="https://img-blog.csdnimg.cn/20191220163921915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="创建主机"><br>&emsp;&emsp;在创建主机界面，需要选择一个模版，也就是监控规则，因为我们还没有创建模版，所以可以使用系统自带的模版，可以搜索<code>linux</code>使用自带的一些监控项。<br>&emsp;&emsp;需要注意的是，agent使用工作模式到底是主动模式还是被动模式，就在于监控项的类型是主动还是被动模式。系统默认模版都是被动式的，如果想使用主动式，可以批量修改模版监控项（模版的具体介绍会在之后文章介绍）。<br><img src="https://img-blog.csdnimg.cn/20191220170318287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191220170331346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;而且，<strong>agent端使用的主动式或者被动式方式，与proxy设置的主动模式还是被动模式没有关系</strong>。proxy创建时选择的模式要与proxy配置文件一致，而这个设定只是控制proxy与server之间的关系，而真正控制agent工作模式的就在于这个监控项目的设置了。也就是说如果监控项目都是被动式，<code>ServerActive</code>设不设置都不会生效，如果有一部分项目是主动式，若没有设置正确的<code>ServerActive</code>，则这些项目将会获取不到数据了。<br>&emsp;&emsp;至此，对于zabbix的初步配置就生效了，等一下就可以看到添加的主机都显示绿色的可用状态。<br><img src="https://img-blog.csdnimg.cn/20191220170936800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;之后就可以在图形界面看到图形数据了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;常见的开源监控软件有：cacti、nagios、zabbix、smokeping、open-falcon等，本文主要介绍目前使用较多的开源监控软件zabbix，针对容器环境的开源监控软件Prometheus下次再讲解。&lt;br&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="https://wudihechao.github.io/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="监控" scheme="https://wudihechao.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="zabbix" scheme="https://wudihechao.github.io/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>使用kubeasz自动化部署K8s</title>
    <link href="https://wudihechao.github.io//blog/8f374cb8.html"/>
    <id>https://wudihechao.github.io//blog/8f374cb8.html</id>
    <published>2019-12-18T07:21:12.000Z</published>
    <updated>2020-01-08T12:08:34.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本文使用kubeasz项目基于二进制方式部署和利用ansible-playbook实现自动化部署K8s。<br><a id="more"></a><br>&emsp;&emsp;架构图如下所示<br><img src="https://img-blog.csdnimg.cn/20191214135719739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;根据kubeasz官方文档中高可用集群所需节点配置如下</p><table><thead><tr><th style="text-align:center">角色</th><th style="text-align:center">数量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">管理节点</td><td style="text-align:center">1</td><td style="text-align:center">运行ansible/easzctl脚本，可以复用master，建议使用独立节点（1c1g）</td></tr><tr><td style="text-align:center">etcd节点</td><td style="text-align:center">3</td><td style="text-align:center">注意etcd集群需要1,3,5,7…奇数个节点，一般复用master节点</td></tr><tr><td style="text-align:center">master节点</td><td style="text-align:center">2</td><td style="text-align:center">高可用集群至少2个master节点</td></tr><tr><td style="text-align:center">node节点</td><td style="text-align:center">3</td><td style="text-align:center">运行应用负载的节点，可根据需要提升机器配置/增加节点数</td></tr></tbody></table><h2 id="配置集群环境"><a href="#配置集群环境" class="headerlink" title="配置集群环境"></a>配置集群环境</h2><p>&emsp;&emsp;此次部署节点设置如下：<br>ansible安装节点&amp;master1：172.18.32.18<br>master2：172.18.32.19<br>harbor：172.19.32.20<br>node1：172.18.32.21<br>node2：172.18.32.22<br>etcd1：172.18.32.23<br>etcd2：172.18.32.24<br>etcd3：172.18.32.25<br>haproxy1+keepalived：172.18.32.183<br>haproxy2+keepalived：172.18.32.184  VIP：172.18.32.250</p><h3 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h3><p>&emsp;&emsp;先将ansible安装节点也就是master1主机（可以不复用主机）的秘钥分发至各个主机。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">vim fenfamiyao.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">目标主机列表</span></span><br><span class="line">PASSWORD="password"</span><br><span class="line">PORT="22"</span><br><span class="line"></span><br><span class="line">IP="</span><br><span class="line">172.18.32.18</span><br><span class="line">172.18.32.19</span><br><span class="line">172.18.32.20</span><br><span class="line">172.18.32.21</span><br><span class="line">172.18.32.22</span><br><span class="line">172.18.32.23</span><br><span class="line">172.18.32.24</span><br><span class="line">172.18.32.25</span><br><span class="line">"</span><br><span class="line"></span><br><span class="line">[ -a /root/.ssh/id_rsa ] || ssh-keygen -t rsa </span><br><span class="line">which sshpass &amp;&gt; /dev/null || yum install sshpass -y #适用于CentOS</span><br><span class="line"></span><br><span class="line">for node in $&#123;IP&#125;;do</span><br><span class="line">        sshpass -p $PASSWORD ssh-copy-id -p$PORT -o StrictHostKeyChecking=no $&#123;node&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">        <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;node&#125;</span> 秘钥 copy 完成,准备环境初始化....."</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                ssh -p<span class="variable">$PORT</span> <span class="variable">$&#123;node&#125;</span> <span class="string">"mkdir /etc/docker/certs.d/harbor.hechao.com -p"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                <span class="built_in">echo</span> <span class="string">"Harbor 证书目录创建成功!"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                scp -P<span class="variable">$PORT</span> /usr/<span class="built_in">local</span>/src/harbor/certs/harbor-ca.crt <span class="variable">$&#123;node&#125;</span>:/etc/docker/certs.d/harbor.hechao.com/harbor-ca.crt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                <span class="built_in">echo</span> <span class="string">"Harbor 证书拷贝成功!"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                scp -P<span class="variable">$PORT</span> /etc/hosts <span class="variable">$&#123;node&#125;</span>:/etc/hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                <span class="built_in">echo</span> <span class="string">"host 文件拷贝完成"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                scp -r -P<span class="variable">$PORT</span> /root/.docker <span class="variable">$&#123;node&#125;</span>:/root/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                <span class="built_in">echo</span> <span class="string">"Harbor 认证文件拷贝完成!"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                scp -r -P<span class="variable">$PORT</span> /etc/resolv.conf <span class="variable">$&#123;node&#125;</span>:/etc/</span></span><br><span class="line">                 echo "镜像加速链接同步!"</span><br><span class="line">                 ssh $&#123;node&#125; "mkdir -p /etc/docker"</span><br><span class="line">                 scp -r -p$PORT /etc/docker/daemon.json $&#123;node&#125;:/etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash">        <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;node&#125;</span> 秘钥 copy 失败"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">        <span class="keyword">fi</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h3 id="安装ansible环境"><a href="#安装ansible环境" class="headerlink" title="安装ansible环境"></a>安装ansible环境</h3><p>&emsp;&emsp;因为要使用ansible批量自动化部署K8s集群，每个主机都要先安装ansible环境。<br>&emsp;&emsp;ubuntu默认的python版本是3.6，而ansible需要python2.7。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">update</span></span><br><span class="line">apt <span class="keyword">install</span> python2<span class="number">.7</span></span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">bin</span>/python2<span class="number">.7</span> /usr/<span class="keyword">bin</span>/python</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;master1上安装ansible<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">install</span> ansible</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;centos一般是自带python2.X环境，所以一般不需要在进行额外操作。<br>&emsp;&emsp;在master1上检查各节点连通性<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible <span class="keyword">all</span> -m ping</span><br></pre></td></tr></table></figure></p><h2 id="配置kubeasz"><a href="#配置kubeasz" class="headerlink" title="配置kubeasz"></a>配置kubeasz</h2><h3 id="下载kubeasz"><a href="#下载kubeasz" class="headerlink" title="下载kubeasz"></a>下载kubeasz</h3><p>&emsp;&emsp;官方文档地址为<a href="https://github.com/easzlab/kubeasz" rel="noopener" target="_blank">https://github.com/easzlab/kubeasz</a>，根据适配的K8s版本选择合适的kubeasz版本。根据官方文档，目前支持以下版本</p><blockquote><p>集群版本 kubernetes v1.13, v1.14, v1.15, v1.16<br>操作系统 CentOS/RedHat 7, Debian 9/10, Ubuntu 1604/1804<br>运行时 docker 18.06.x-ce, 18.09.x, containerd 1.2.6<br>网络 calico, cilium, flannel, kube-ovn, kube-router</p></blockquote><p>&emsp;&emsp;我们下载2.0.3版本的kubeasz,并给予执行权限<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -C- -fLO --retry <span class="number">3</span> https:<span class="regexp">//gi</span>thub.com<span class="regexp">/easzlab/</span>kubeasz<span class="regexp">/releases/</span>download<span class="regexp">/2.0.3/</span>easzup</span><br><span class="line">chmod +x easzup</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以用<code>file easzup</code>命令看到这是一个ASCII文本文件，其实就是一个shell脚本。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu18:~<span class="comment"># file easzup</span></span><br><span class="line"><span class="symbol">easzup:</span> <span class="keyword">Bourne-Again </span><span class="keyword">shell </span><span class="keyword">script, </span>ASCII text executable</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;用vim编辑修改此文件。<br>&emsp;&emsp;大部分地方无需修改，不过可以设置docker版本为18.09.9和K8s的版本为v1.15.5，其他地方不用动。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_VER</span>=18.09.9</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">K8S_BIN_VER</span>=v1.15.5</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;执行<code>-- help</code>查看脚本使用方法。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu18:~# ./easzup <span class="comment">--help</span></span><br><span class="line">./easzup: illegal <span class="keyword">option</span> <span class="comment">-- -</span></span><br><span class="line"><span class="keyword">Usage</span>: easzup [<span class="keyword">options</span>] [args]</span><br><span class="line">  <span class="keyword">option</span>: -&#123;DdekSz&#125;</span><br><span class="line">    -C         stop&amp;clean <span class="keyword">all</span> <span class="keyword">local</span> containers</span><br><span class="line">    -D         download <span class="keyword">all</span> <span class="keyword">into</span> /etc/ansible</span><br><span class="line">    -S         <span class="keyword">start</span> kubeasz <span class="keyword">in</span> a container</span><br><span class="line">    -d &lt;ver&gt;   <span class="keyword">set</span> docker-ce <span class="keyword">version</span>, <span class="keyword">default</span> "18.09.9"</span><br><span class="line">    -e &lt;ver&gt;   <span class="keyword">set</span> kubeasz-ext-bin <span class="keyword">version</span>, <span class="keyword">default</span> "0.3.0"</span><br><span class="line">    -k &lt;ver&gt;   <span class="keyword">set</span> kubeasz-k8s-bin <span class="keyword">version</span>, <span class="keyword">default</span> "v1.15.5"</span><br><span class="line">    -m &lt;str&gt;   <span class="keyword">set</span> docker registry mirrors, <span class="keyword">default</span> "CN"(used <span class="keyword">in</span> Mainland,China)</span><br><span class="line">    -p &lt;ver&gt;   <span class="keyword">set</span> kubeasz-sys-pkg <span class="keyword">version</span>, <span class="keyword">default</span> "0.3.2"</span><br><span class="line">    -z &lt;ver&gt;   <span class="keyword">set</span> kubeasz <span class="keyword">version</span>, <span class="keyword">default</span> "2.0.3"</span><br><span class="line">  </span><br><span class="line">see more at https://github.com/kubeasz/dockerfiles</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;先将<code>/etc/ansible</code>目录下所有自带的配置文件以及hosts文件删掉<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\rm</span> -rf <span class="regexp">/etc/ansible/</span>*</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;执行脚本下载所有需要的镜像和二进制文件<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./easzup</span> -D</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;稍等片刻之后，下载好需要的镜像和二进制文件，此时就可以开始ansible自动部署安装K8s集群了。</p><h3 id="ansible部署K8s"><a href="#ansible部署K8s" class="headerlink" title="ansible部署K8s"></a>ansible部署K8s</h3><p>&emsp;&emsp;kubeasz工具都已经写好了playbook，只需要设定好hosts文件即可一键安装了。先进入<code>/etc/ansible</code>目录,然后复制提供好的host模版文件并编辑。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ansible/</span><br><span class="line">cp example/hosts.multi-<span class="keyword">node</span> <span class="title">hosts</span></span><br><span class="line">vim hosts</span><br></pre></td></tr></table></figure></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">root@DockerUbuntu18:/etc/ansible# grep -v ^# hosts|grep -v ^$</span></span><br><span class="line">[etcd]</span><br><span class="line">172.18.32.23 NODE_NAME=etcd1</span><br><span class="line">172.18.32.24 NODE_NAME=etcd2</span><br><span class="line">172.18.32.25 NODE_NAME=etcd3</span><br><span class="line">[kube-master]</span><br><span class="line">172.18.32.18</span><br><span class="line">172.18.32.19</span><br><span class="line">[kube-node]</span><br><span class="line">172.18.32.21</span><br><span class="line">172.18.32.22</span><br><span class="line">[harbor]</span><br><span class="line">[ex-lb]</span><br><span class="line">[chrony]</span><br><span class="line"><span class="section">[all:vars]</span></span><br><span class="line">CONTAINER_RUNTIME=<span class="string">"docker"</span></span><br><span class="line">CLUSTER_NETWORK=<span class="string">"calico"</span></span><br><span class="line">SERVICE_CIDR=<span class="string">"10.68.0.0/16"</span></span><br><span class="line">CLUSTER_CIDR=<span class="string">"172.20.0.0/16"</span></span><br><span class="line">NODE_PORT_RANGE=<span class="string">"30000-65000"</span></span><br><span class="line">CLUSTER_DNS_DOMAIN=<span class="string">"cluster.local."</span></span><br><span class="line">bin_dir=<span class="string">"/usr/kube/bin"</span></span><br><span class="line">ca_dir=<span class="string">"/etc/kubernetes/ssl"</span></span><br><span class="line">base_dir=<span class="string">"/etc/ansible"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以为我本地已经搭好harbor服务器了，所以就不要设置harbor服务让他来安装了。除了各节点IP以外，需要修改的就是<code>bin_dir</code>目录，这样就省去了创建软链接的步骤，也省去配置PATH变量了。我选择的网卡是<code>calico</code>，也可以使用默认的<code>flannel</code>，之后具体区别会再详细介绍。<br>&emsp;&emsp;直接执行 <code>playbook</code>剧本90.setup.yml可以直接一键安装完成，不过如果出现问题我们不好排错，推荐一个剧本一个剧本的来跑。</p><ul><li>01.prepare.yml</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook <span class="number">01</span><span class="selector-class">.prepare</span><span class="selector-class">.yml</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个剧本总共三个环节，一般来说都不会报错（如果提示软链接创建失败，则可忽略）。<br>&emsp;&emsp;1.如果设置了chrony服务器，则master、node、etcd主机都会向chrony服务器同步时间。<br>&emsp;&emsp;2.控制节点上创建CA、创建集群参数及客户端认证参数<br>&emsp;&emsp;3分发证书工具CFSSL及kubeconfig配置文件</p><ul><li>02.etcd.yml</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook <span class="number">02</span><span class="selector-class">.etcd</span><span class="selector-class">.yml</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个剧本是在配置etcd服务器。在3个etcd节点上，创建etcd目录并分发证书，导入之前下载在控制端的二进制程序<code>etcd</code>及<code>etcdctl</code>及导入etcd的systemctl unit文件，设置开机自动启动etcd服务。这步也很简单，一般也不会出现什么问题。</p><ul><li>03.docker.yml</li></ul><p>&emsp;&emsp;因为我们在hosts文件中设置了运行时为<code>docker</code>,所以我们第三个剧本选择<code>03.docker.yml</code>，选择执行<code>03.containerd,yml</code>剧本也不会执行，里面做了条件判断<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu18</span><span class="symbol">:/etc/ansible</span><span class="comment"># cat 03.containerd.yml </span></span><br><span class="line"><span class="comment"># to install containerd service</span></span><br><span class="line">- <span class="symbol">hosts:</span></span><br><span class="line">  - kube-master</span><br><span class="line">  - kube-node</span><br><span class="line">  <span class="symbol">roles:</span></span><br><span class="line">  - &#123; <span class="symbol">role:</span> containerd, <span class="symbol">when:</span> <span class="string">"CONTAINER_RUNTIME == 'containerd'"</span> &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个阶段的剧本比较复杂，要在每一个节点上安装docker，在执行这一步之前，先检查一下模版二进制文件的docker版本是否和我们之前预设的一样。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/ansible/bin/docker -v</span><br><span class="line">Docker version <span class="number">18.09</span><span class="number">.6</span>, build <span class="number">481</span>bc77</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果不一样，可以去<code>/opt/kube/bin/</code>目录下找一下之前下好的二进制文件，确认下版本。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="meta">opt</span>/kube/<span class="keyword">bin/docker </span>-v</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个目录下的版本一般是不会错的，将此目录下的二进制文件复制至模版目录<code>/etc/ansible/bin/</code>。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/opt/</span>kube<span class="regexp">/bin/</span>* <span class="regexp">/etc/</span>ansible<span class="regexp">/bin/</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;执行ansible剧本<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook <span class="number">03</span><span class="selector-class">.docker</span><span class="selector-class">.yml</span></span><br></pre></td></tr></table></figure></p><ul><li>04.kube-master.yml</li></ul><p>&emsp;&emsp;这个剧本是对两个master节点操作，执行了以下操作<br>&emsp;&emsp;1.创建kubernetes签名请求以及证书和私钥<br>&emsp;&emsp;2.导入配置文件，启动kube-apiserver、kube-controller-manager及kube-scheduler服务<br>&emsp;&emsp;3.设置主节点的kube-apiserver.service文件，并设置apiserver的IP地址并创建配置用户rbac权限。<br>&emsp;&emsp;此时使用命令<code>kubectl get node</code>可以看到两个主节点都是出于ready状态了。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# kubectl <span class="keyword">get</span> node</span><br><span class="line">NAME           STATUS                     ROLES    AGE    VERSION</span><br><span class="line"><span class="number">172.18</span><span class="number">.32</span><span class="number">.18</span>   Ready,SchedulingDisabled   master   <span class="number">1</span>m    v1<span class="number">.15</span><span class="number">.5</span></span><br><span class="line"><span class="number">172.18</span><span class="number">.32</span><span class="number">.19</span>   Ready,SchedulingDisabled   master   <span class="number">1</span>m    v1<span class="number">.15</span><span class="number">.5</span></span><br></pre></td></tr></table></figure></p><ul><li>05..kube-node.yml</li></ul><p>&emsp;&emsp;这个剧本主要是将几个node节点加到集群中来。流程比较复杂，大致有以下步骤：<br>&emsp;&emsp;1,创建kube-node目录:/var/lib/kubelet、/var/lib/kube-proxy和/etc/cni/net.d目录<br>&emsp;&emsp;2.导入之前准备好的二进制可执行文件kubectl、kubelet、kube-proxy、bridge、host-local和loopback<br>&emsp;&emsp;3.配置haproxy，监听本地的127.0.0.1：6443端口，代理至两个主节点的6443端口<br>&emsp;&emsp;4.生成node节点的kubelet的配置文件，并分发至各个node节点。kubelet连接主节点的apiserver。<br>&emsp;&emsp;5.node节点连接后，对node节点标记为kubernetes.io/role=node</p><p>&emsp;&emsp;这步很容易出现kubelet服务无法启动，或者一直处于loaded状态，返回值为255。这是因为node节点的kubelet的认证失败。可以去node节点主机上查看服务kubelet服务状态。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">status kubectl</span></span><br><span class="line"><span class="attr">journalctl</span> <span class="string">-u kubelet -e</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我遇到几次node节点kubelet无法正常启动的情况，但是换了个全新的node节点就可以加进去了，说明问题不是在主节点上，一般将node节点还原至干净系统都可以解决问题。<br>&emsp;&emsp;还有一次返回值255但报错提示是，找不到<code>/run/systemd/resolve/resolv.conf</code>文件，于是创建一个<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/run/</span>systemd<span class="regexp">/resolve/</span>;echo <span class="string">"nameserver 233.5.5.5"</span> &gt; <span class="regexp">/run/</span>systemd<span class="regexp">/resolve/</span>resolv.conf</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;自己创建一个解析之后问题解决。<br>&emsp;&emsp;顺利的话，使用<code>kubectl get node</code>可以看到主节点和node节点都处于ready状态。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu18:/etc/ansible# kubectl <span class="keyword">get</span> node</span><br><span class="line">NAME           STATUS                     ROLES    AGE   VERSION</span><br><span class="line"><span class="number">172.18</span><span class="number">.32</span><span class="number">.18</span>   Ready,SchedulingDisabled   master   <span class="number">2</span>h   v1<span class="number">.15</span><span class="number">.5</span></span><br><span class="line"><span class="number">172.18</span><span class="number">.32</span><span class="number">.19</span>   Ready,SchedulingDisabled   master   <span class="number">2</span>h   v1<span class="number">.15</span><span class="number">.5</span></span><br><span class="line"><span class="number">172.18</span><span class="number">.32</span><span class="number">.21</span>   Ready                      node     <span class="number">2</span>h   v1<span class="number">.15</span><span class="number">.5</span></span><br><span class="line"><span class="number">172.18</span><span class="number">.32</span><span class="number">.22</span>   Ready                      node     <span class="number">2</span>h   v1<span class="number">.15</span><span class="number">.5</span></span><br></pre></td></tr></table></figure></p><ul><li>06.network.yml</li></ul><p>&emsp;&emsp;在这个剧本中，主要是配置各个pod之间的网络访问。需要在每个物理节点上都生成一个<code>calico-node</code>服务的pod，再启动一个<code>calico-kube-controllers</code>服务的pod来管理他们，（因为默认主节点设置了不可调度，所以这个calico-kube-contronllers一般是在node节点上生成）。因为使用的是pod方式启动，所以这个剧本中，除了配置calicao证书及私钥外，主要是生成了一个<code>calico DaemonSet yaml</code>文件，路径为<code>/opt/kube/kube-system/calico.yaml</code>，所以之后如果修改网络配置，可以直接在此路径下修改这个yaml文件，例如如果想要修改镜像地址为私有harbor地址，则<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> -<span class="keyword">f</span> /<span class="keyword">opt</span>/kube/kube-<span class="built_in">system</span>/calico.yaml</span><br><span class="line"><span class="keyword">vim</span> /<span class="keyword">opt</span>/kube/kube-<span class="built_in">system</span>/calico.yaml</span><br><span class="line">kubectl apply -<span class="keyword">f</span> /<span class="keyword">opt</span>/kube/kube-<span class="built_in">system</span>/calico.yaml</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的是，如果将yaml文件中拉取镜像的地址改为了私有harbor，则需要在yaml文件中加入Secret资源，使用<code>imagePullSecrets</code>拉取。<br>&emsp;&emsp;当我们的node节点不需要跨网段时，通常会选择将IPIP模式（ip-in-ip叠加模式）关掉，使用calico的BGP模式，以节约大量主机内部访问时封装的性能损耗。<br>&emsp;&emsp;查看路由，可以看到目前荣期间通信的网络接口为<code>tunl0</code>。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">172.18</span><span class="number">.0</span><span class="number">.1</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> docker0</span><br><span class="line"><span class="number">172.18</span><span class="number">.0</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">172.20</span><span class="number">.185</span><span class="number">.64</span>   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> *</span><br><span class="line"><span class="number">172.20</span><span class="number">.233</span><span class="number">.128</span>  <span class="number">172.18</span><span class="number">.32</span><span class="number">.19</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> tunl0</span><br><span class="line"><span class="number">172.20</span><span class="number">.250</span><span class="number">.128</span>  <span class="number">172.18</span><span class="number">.32</span><span class="number">.22</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> tunl0</span><br><span class="line"><span class="number">172.20</span><span class="number">.250</span><span class="number">.192</span>  <span class="number">172.18</span><span class="number">.32</span><span class="number">.21</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> tunl0</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth1</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;于是可以编辑<code>/etc/ansible/roles/calico/defaults/main.yml</code>或者直接修改<code>/opt/kube/kube-system/calico.yaml</code>文件，将其中的 <code>CALICO_IPV4POOL_IPIP</code>修改为off，将<code>name: FELIX_IPINIPMTU</code>属性注释掉，改为<code>FELIX_IPINIPENABLED</code>值为<code>false</code>。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="type">name</span>: CALICO_IPV4POOL_IPIP</span><br><span class="line">  <span class="keyword">value</span>: "off"</span><br><span class="line">  </span><br><span class="line">- <span class="type">name</span>: FELIX_IPINIPENABLED</span><br><span class="line">  <span class="keyword">value</span>: "false"</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后执行<code>kubectl delete -f /opt/kube/kube-system/calico.yaml</code>将网络组件calico的pod都先停掉，<code>reboot</code>重启后，使用命令<code>ifconfig</code>就会发现，之前使用的<code>tunl0</code>网卡就不见了。再使用命令<code>kubectl apply -f /opt/kube/kube-system/calico.yaml</code>，将k8s网络连接起来，使用命令<code>route -n</code>查看路由信息，就会发现，跨主机通信直接使用eth0网卡了。此时模式从IPIP修改为BGP模式。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu18:~# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">172.18</span><span class="number">.0</span><span class="number">.1</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> docker0</span><br><span class="line"><span class="number">172.18</span><span class="number">.0</span><span class="number">.0</span>      <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">172.20</span><span class="number">.185</span><span class="number">.64</span>   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> *</span><br><span class="line"><span class="number">172.20</span><span class="number">.233</span><span class="number">.128</span>  <span class="number">172.18</span><span class="number">.32</span><span class="number">.19</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">172.20</span><span class="number">.250</span><span class="number">.128</span>  <span class="number">172.18</span><span class="number">.32</span><span class="number">.22</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">172.20</span><span class="number">.250</span><span class="number">.192</span>  <span class="number">172.18</span><span class="number">.32</span><span class="number">.21</span>    <span class="number">255.255</span><span class="number">.255</span><span class="number">.192</span> UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth1</span><br></pre></td></tr></table></figure></p><ul><li>07.cluster-addon.yml</li></ul><p>&emsp;&emsp;第七步是安装一些功能插件，如在node节点生成dns解析(默认使用的是coredns，可以在<code>roles/cluster-addon/defaults/main.yml</code>文件中设置），安装dashboard（可视化web界面）。我们也可以选择自己安装这些功能插件。<br>&emsp;&emsp;可参考官方文档<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/#deploying-the-dashboard-ui" rel="noopener" target="_blank">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/#deploying-the-dashboard-ui</a><br>&emsp;&emsp;dashboard默认是1.6.3版本的，比较老。我们这里手动安装dashboard1.10.1版本，过程如下<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ansible/manifests/dashboard</span><br><span class="line">mkdir <span class="number">1.10</span><span class="number">.1</span></span><br><span class="line">cp <span class="number">1.6</span><span class="number">.3</span>/ui* <span class="number">1.10</span><span class="number">.1</span>/</span><br><span class="line">cd <span class="number">1.10</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;先下载yaml文档<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/kubernetes/</span>dashboard<span class="regexp">/v1.10.1/</span>src<span class="regexp">/deploy/</span>recommended<span class="regexp">/kubernetes-dashboard.yaml</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;再创建admin token<code>vim admin-user-sa-rbac.yaml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建集群角色<code>vim read-user-sa-rbac.yaml</code><br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">--</span></span><br><span class="line"><span class="ruby"><span class="symbol">apiVersion:</span> rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="ruby"><span class="symbol">kind:</span> ClusterRole</span></span><br><span class="line"><span class="ruby"><span class="symbol">metadata:</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">name:</span> dashboard-read-clusterrole</span></span><br><span class="line"><span class="ruby"><span class="symbol">rules:</span></span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - configmaps</span></span><br><span class="line"><span class="ruby">  - endpoints</span></span><br><span class="line"><span class="ruby">  - persistentvolumeclaims</span></span><br><span class="line"><span class="ruby">  - pods</span></span><br><span class="line"><span class="ruby">  - replicationcontrollers</span></span><br><span class="line"><span class="ruby">  - replicationcontrollers/scale</span></span><br><span class="line"><span class="ruby">  - serviceaccounts</span></span><br><span class="line"><span class="ruby">  - services</span></span><br><span class="line"><span class="ruby">  - nodes</span></span><br><span class="line"><span class="ruby">  - persistentvolumeclaims</span></span><br><span class="line"><span class="ruby">  - persistentvolumes</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - bindings</span></span><br><span class="line"><span class="ruby">  - events</span></span><br><span class="line"><span class="ruby">  - limitranges</span></span><br><span class="line"><span class="ruby">  - namespaces/status</span></span><br><span class="line"><span class="ruby">  - pods/log</span></span><br><span class="line"><span class="ruby">  - pods/status</span></span><br><span class="line"><span class="ruby">  - replicationcontrollers/status</span></span><br><span class="line"><span class="ruby">  - resourcequotas</span></span><br><span class="line"><span class="ruby">  - resourcequotas/status</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - namespaces</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - apps</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - daemonsets</span></span><br><span class="line"><span class="ruby">  - deployments</span></span><br><span class="line"><span class="ruby">  - deployments/scale</span></span><br><span class="line"><span class="ruby">  - replicasets</span></span><br><span class="line"><span class="ruby">  - replicasets/scale</span></span><br><span class="line"><span class="ruby">  - statefulsets</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - autoscaling</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - horizontalpodautoscalers</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - batch</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - cronjobs</span></span><br><span class="line"><span class="ruby">  - jobs</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - extensions</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - daemonsets</span></span><br><span class="line"><span class="ruby">  - deployments</span></span><br><span class="line"><span class="ruby">  - deployments/scale</span></span><br><span class="line"><span class="ruby">  - ingresses</span></span><br><span class="line"><span class="ruby">  - networkpolicies</span></span><br><span class="line"><span class="ruby">  - replicasets</span></span><br><span class="line"><span class="ruby">  - replicasets/scale</span></span><br><span class="line"><span class="ruby">  - replicationcontrollers/scale</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - policy</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - poddisruptionbudgets</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - networking.k8s.io</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - networkpolicies</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - storage.k8s.io</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - storageclasses</span></span><br><span class="line"><span class="ruby">  - volumeattachments</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - rbac.authorization.k8s.io</span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - clusterrolebindings</span></span><br><span class="line"><span class="ruby">  - clusterroles</span></span><br><span class="line"><span class="ruby">  - roles</span></span><br><span class="line"><span class="ruby">  - rolebindings</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时目录结构如下<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu18</span><span class="symbol">:/etc/ansible/manifests/dashboard/</span><span class="number">1.10</span>.<span class="number">1</span><span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── admin-user-sa-rbac.yaml</span><br><span class="line">├── kubernetes-dashboard.yaml</span><br><span class="line">├── read-user-sa-rbac.yaml</span><br><span class="line">├── ui-admin-rbac.yaml</span><br><span class="line">└── ui-read-rbac.yaml</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">5</span> files</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后通过yaml文件启动dashboard的pod<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以通过命令查看pod 是否启动成功。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> pods --<span class="keyword">all</span>-namespaces | <span class="keyword">grep</span> dashboard</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;看到状态running之后，输入命令开启认证生成登陆用户名密码<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">easzctl</span> <span class="keyword">basic-auth </span>-s</span><br></pre></td></tr></table></figure></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">INFO</span>]<span class="keyword">basic-auth </span>for apiserver is enabled!</span><br><span class="line"><span class="keyword">BASIC_AUTH_USER: </span><span class="string">'admin'</span></span><br><span class="line"><span class="keyword">BASIC_AUTH_PASS: </span><span class="string">'4fe554e56c32f27b'</span></span><br><span class="line">[<span class="meta">INFO</span>] Action successed : <span class="keyword">basic-auth </span><span class="keyword">basic-auth </span>-s`</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过命令<code>kubectl cluster-info</code>查看集群信息来查看登陆url<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kubectl</span> cluster-<span class="literal">info</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用命令来获取token<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system describe secret <span class="constructor">$(<span class="params">kubectl</span> -<span class="params">n</span> <span class="params">kube</span>-<span class="params">system</span> <span class="params">get</span> <span class="params">secret</span> | <span class="params">grep</span> <span class="params">admin</span>-<span class="params">user</span> | <span class="params">awk</span> '&#123;<span class="params">print</span> $1&#125;')</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时就可以登陆web界面查看K8s集群信息了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文使用kubeasz项目基于二进制方式部署和利用ansible-playbook实现自动化部署K8s。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="kubernetes" scheme="https://wudihechao.github.io/tags/kubernetes/"/>
    
      <category term="kubeasz" scheme="https://wudihechao.github.io/tags/kubeasz/"/>
    
      <category term="dashboard" scheme="https://wudihechao.github.io/tags/dashboard/"/>
    
  </entry>
  
  <entry>
    <title>使用kubeadm部署安装K8s</title>
    <link href="https://wudihechao.github.io//blog/107b7ce7.html"/>
    <id>https://wudihechao.github.io//blog/107b7ce7.html</id>
    <published>2019-12-13T03:08:47.000Z</published>
    <updated>2019-12-18T07:32:52.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;本文将介绍通过kubeadm部署K8s集群的详细过程，且通过两个mater节点实现K8s集群的高可用。<br>&emsp;&emsp;本次演示使用 k8s 官方提供的部署工具 kubeadm 自动安装， 需要在 master 和 node 节点上安装 docker 等组件， 然后初始化， 把管理端的控制服务和 node 上的服务都以pod 的方式运行。<br><a id="more"></a><br>&emsp;&emsp;架构结构示意图如下路所示<br><img src="https://img-blog.csdnimg.cn/20191211215135227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="K8s架构"><br>&emsp;&emsp;环境搭建（master及node节点均为ubuntu1804）：<br>&emsp;&emsp;master1：192.168.32.18<br>&emsp;&emsp;master2：192.168.32.19<br>&emsp;&emsp;harbor：192.168.32.20<br>&emsp;&emsp;node1：192.168.32.21<br>&emsp;&emsp;node2：192.168.32.22<br>&emsp;&emsp;需要禁用 swap， selinux， iptables。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">swapoff -a</span></span><br></pre></td></tr></table></figure></p><h2 id="搭建master节点"><a href="#搭建master节点" class="headerlink" title="搭建master节点"></a>搭建master节点</h2><h3 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h3><p>&emsp;&emsp;可以通过apt快速安装或者源码编译，下面以apt包管理工具安装为例<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install keepalived -y</span><br><span class="line">cp <span class="regexp">/usr/</span>share<span class="regexp">/doc/</span>keepalived<span class="regexp">/samples/</span>keepalived.conf.vrrp <span class="regexp">/etc/</span>keepalived<span class="regexp">/keepalived.conf</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后修改配置文件，实例如下<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.<span class="symbol">Cassen@</span>firewall.loc</span><br><span class="line">   smtp_server <span class="number">192.168</span><span class="number">.200</span><span class="number">.1</span></span><br><span class="line">   smtp_connect_timeout <span class="number">30</span></span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    <span class="keyword">interface</span> <span class="symbol">eth0</span></span><br><span class="line">    <span class="symbol">garp_master_delay</span> <span class="symbol">10</span></span><br><span class="line">    <span class="symbol">smtp_alert</span></span><br><span class="line">    <span class="symbol">virtual_router_id</span> <span class="symbol">32</span></span><br><span class="line">    <span class="symbol">priority</span> <span class="symbol">100</span></span><br><span class="line">    <span class="symbol">advert_int</span> <span class="symbol">1</span></span><br><span class="line">    <span class="symbol">authentication</span> &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        # optional label. should be of the form <span class="string">"realdev:sometext"</span> <span class="keyword">for</span></span><br><span class="line">        # compatibility with ifconfig.</span><br><span class="line">        <span class="number">172.18</span><span class="number">.32</span><span class="number">.250</span> label eth0:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;另一个节点也安装keepalived，然后测试VIP是否可以漂移成功。</p><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><p>&emsp;&emsp;在主节点上先安装docker，详细可参考<a href="https://blog.csdn.net/MicePro/article/details/103375500" rel="noopener" target="_blank">之前文章</a>。<br>&emsp;&emsp;可以通过阿里云镜像，使用脚本来安装<code>vim docker1806.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line"><span class="comment"># Step 4: 更新并安装Docker-CE</span></span><br><span class="line">apt-get -y update</span><br><span class="line">apt-get -y install docker-ce=18.06.0~ce~3-0~ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line"><span class="comment"># apt-cache madison docker-ce</span></span><br><span class="line"><span class="comment">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="comment">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="comment"># Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span></span><br><span class="line"><span class="comment"># sudo apt-get -y install docker-ce=[VERSION]</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash docker1806.sh</span><br></pre></td></tr></table></figure><h3 id="配置阿里加速器"><a href="#配置阿里加速器" class="headerlink" title="配置阿里加速器"></a>配置阿里加速器</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="meta-keyword">/etc/</span>docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://360k4x9i.mirror.aliyuncs.com"</span>,<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line">        <span class="string">"insecure-registries"</span>: [<span class="string">"https://harbor.local.com"</span>],</span><br><span class="line">        <span class="string">"bip"</span>: <span class="string">"10.20.0.1/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装kubeadm"><a href="#安装kubeadm" class="headerlink" title="安装kubeadm"></a>安装kubeadm</h3><p>&emsp;&emsp;先配置k8s的镜像源,并安装kubeadm<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="comment">//mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span></span><br><span class="line"></span><br><span class="line"> cat  &gt;/etc/apt/sources.list.d/kubernetes.list &lt;&lt;EOF</span><br><span class="line">deb https:<span class="comment">//mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">apt-<span class="keyword">get</span> update</span><br><span class="line">apt install kubeadm=<span class="number">1.16</span><span class="number">.1</span><span class="number">-00</span> kubectl=<span class="number">1.16</span><span class="number">.1</span><span class="number">-00</span> kubelet=<span class="number">1.16</span><span class="number">.1</span><span class="number">-00</span></span><br><span class="line">systemctl start kubelet &amp;&amp; systemctl enable kubelet</span><br></pre></td></tr></table></figure></p><h3 id="安装K8s"><a href="#安装K8s" class="headerlink" title="安装K8s"></a>安装K8s</h3><p>&emsp;&emsp;因为默认使用的是google的镜像仓库，国内是连接不上的，所以我们最好提前下载好镜像。本次演示安装版本为kubernetes v1.16.1<br>&emsp;&emsp;先查看需要下载的镜像及版本<br><code>kubeadm config images list --kubernetes-version v1.16.1</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/kube-apiserver:v1.<span class="number">16.1</span></span><br><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/kube-controller-manager:v1.<span class="number">16.1</span></span><br><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/kube-scheduler:v1.<span class="number">16.1</span></span><br><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/kube-proxy:v1.<span class="number">16.1</span></span><br><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/pause:<span class="number">3.1</span></span><br><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/etcd:<span class="number">3.3</span>.<span class="number">15</span>-<span class="number">0</span></span><br><span class="line">k8s<span class="selector-class">.gcr</span><span class="selector-class">.io</span>/coredns:<span class="number">1.6</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们先去阿里云镜像仓库提前下载好镜像，可以通过快速实现.。如果有harbor服务器，可以先上传到本地harbor。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.16.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.16.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.16.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.16.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.3.15-0</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.2</span><br></pre></td></tr></table></figure></p><h3 id="master-初始化"><a href="#master-初始化" class="headerlink" title="master 初始化"></a>master 初始化</h3><p>&emsp;&emsp;因为我们打算做master的高可用。所以我们在master初始化时，要加选项<code>--control-plane-endpoint=172.18.32.250</code>指定<code></code>VIP`。只需在一个master节点上做初始化即可。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=<span class="number">172.18</span><span class="number">.32</span><span class="number">.18</span> \</span><br><span class="line">--<span class="section">control</span>-plane-endpoint=<span class="number">172.18</span><span class="number">.32</span><span class="number">.250</span> \</span><br><span class="line">--apiserver-bind-port=<span class="number">6443</span> \</span><br><span class="line">--kubernetes-version=v1<span class="number">.16</span><span class="number">.1</span> \</span><br><span class="line">--pod-network-cidr=<span class="number">10.10</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> \</span><br><span class="line">--service-cidr=<span class="number">10.20</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> \</span><br><span class="line">--service-dns-domain=k8s.local \</span><br><span class="line">--image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \</span><br><span class="line">--ignore-preflight-errors=swap</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以基于yaml文件而不是用命令行命令来进行初始化。可以使用命令<code>kubeadm init --config kubeadm-init.yaml</code> ，基于文件初始化。<br>&emsp;&emsp;<code>kubeadm config print init-defaults</code> 输出默认初始化配置<br>&emsp;&emsp;<code>kubeadm config print init-defaults &gt; kubeadm-init.yaml</code> 将默认配置输出至文件<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root@k8s-master1:~#</span> <span class="string">cat</span> <span class="string">kubeadm-init.yaml</span> <span class="comment">#修改后的初始化文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="attr">- groups:</span></span><br><span class="line"><span class="attr">- system:</span><span class="attr">bootstrappers:kubeadm:default-node-token</span></span><br><span class="line"><span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line"><span class="attr">ttl:</span> <span class="number">24</span><span class="string">h0m0s</span></span><br><span class="line"><span class="attr">usages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line"><span class="attr">advertiseAddress:</span> <span class="number">172.18</span><span class="number">.32</span><span class="number">.18</span></span><br><span class="line"><span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">k8s-master1.k8s.local</span></span><br><span class="line"><span class="attr">taints:</span></span><br><span class="line"><span class="attr">- effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line"><span class="attr">timeoutForControlPlane:</span> <span class="number">4</span><span class="string">m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controlPlaneEndpoint:</span> <span class="number">172.18</span><span class="number">.32</span><span class="number">.250</span><span class="string">:6443</span> <span class="comment">#添加基于 VIP 的 Endpoint</span></span><br><span class="line"><span class="attr">controllerManager:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">CoreDNS</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line"><span class="attr">local:</span></span><br><span class="line"><span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.16.1</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line"><span class="attr">dnsDomain:</span> <span class="string">k8s.local</span></span><br><span class="line"><span class="attr">podSubnet:</span> <span class="number">10.10</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">serviceSubnet:</span> <span class="number">10.20</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">scheduler:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;初始化成功，记录下来<code>--token</code>和<code>--discovery-token-ca-cert-hash</code>,，之后加入其他节点时需要用到。<br>&emsp;&emsp;如果初始化失败了需要 使用命令kubeadm reset可以清除已有容器数据以便重新安装，PS：此命令如果在安装完成后使用会清除已创建的k8s集群。</p><h3 id="配置kube证书"><a href="#配置kube证书" class="headerlink" title="配置kube证书"></a>配置kube证书</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/coreos</span><span class="regexp">/flannel/master</span><span class="regexp">/Documentation/kube</span>-flannel.yml</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><h2 id="加入其他节点"><a href="#加入其他节点" class="headerlink" title="加入其他节点"></a>加入其他节点</h2><p>&emsp;&emsp;其他三台k8s节点也要安装docker及k8s，可以通过脚本快速实现<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> node.<span class="keyword">sh</span></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"># step <span class="number">1</span>: 安装必要的一些系统工具</span><br><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> -<span class="keyword">y</span> install apt-transport-https <span class="keyword">ca</span>-certificates curl software-properties-common</span><br><span class="line"># step <span class="number">2</span>: 安装GPG证书</span><br><span class="line">curl -fsSL http<span class="variable">s:</span>//mirrors.aliyun.<span class="keyword">com</span>/docker-<span class="keyword">ce</span>/linux/ubuntu/gpg | sudo apt-key <span class="built_in">add</span> -</span><br><span class="line"># Step <span class="number">3</span>: 写入软件源信息</span><br><span class="line">sudo <span class="built_in">add</span>-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span></span><br><span class="line"># Step <span class="number">4</span>: 更新并安装Docker-CE</span><br><span class="line">apt-<span class="built_in">get</span> -<span class="keyword">y</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> -<span class="keyword">y</span> install docker-<span class="keyword">ce</span>=<span class="number">18.06</span>.<span class="number">0</span>~<span class="keyword">ce</span>~<span class="number">3</span>-<span class="number">0</span>~ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://360k4x9i.mirror.aliyuncs.com"</span>,<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line">        <span class="string">"insecure-registries"</span>: [<span class="string">"https://harbor.local.com"</span>],</span><br><span class="line">        <span class="string">"bip"</span>: <span class="string">"10.20.0.1/24"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">curl http<span class="variable">s:</span>//mirrors.aliyun.<span class="keyword">com</span>/kubernetes/apt/doc/apt-key.gpg | apt-key <span class="built_in">add</span> - </span><br><span class="line"></span><br><span class="line"><span class="keyword">cat</span>  &gt;/etc/apt/sources.<span class="keyword">list</span>.d/kubernetes.<span class="keyword">list</span> &lt;&lt;EOF</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.aliyun.<span class="keyword">com</span>/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line">apt install kubeadm=<span class="number">1.16</span>.<span class="number">1</span>-<span class="number">00</span> kubectl=<span class="number">1.16</span>.<span class="number">1</span>-<span class="number">00</span> kubelet=<span class="number">1.16</span>.<span class="number">1</span>-<span class="number">00</span> -<span class="keyword">y</span></span><br><span class="line">systemctl start kubelet &amp;&amp; systemctl enable kubelet</span><br><span class="line"></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/kube-apiserver:v1.<span class="number">16.1</span></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/kube-controller-manager:v1.<span class="number">16.1</span></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/kube-scheduler:v1.<span class="number">16.1</span></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/kube-proxy:v1.<span class="number">16.1</span></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/pause:<span class="number">3.1</span></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/etcd:<span class="number">3.3</span>.<span class="number">15</span>-<span class="number">0</span></span><br><span class="line">docker pull registry.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/google_containers/coredn<span class="variable">s:1</span>.<span class="number">6.2</span></span><br><span class="line"></span><br><span class="line">systemctl enable --now docker kubelet</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;当前 maste 生成证书用于添加新控制节点：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init phase upload-certs <span class="comment">--upload-certs</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;得到<code>--certificate-key</code>的值，也要记录下来。<br>&emsp;&emsp;之后想加入哪个节点，就在哪个节点上操作。先加入另一个master节点。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join <span class="number">172.18</span><span class="number">.32</span><span class="number">.250</span>:<span class="number">6443</span> --token <span class="number">89</span>beqy<span class="number">.13</span>jxavbu7yz3187d \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:<span class="number">7388</span>af4f1662805a844cce7c1371facb83f32dddb998370d11bfb41957fe75bf \</span><br><span class="line">--certificate-key <span class="number">3630</span>d5719795c77e7071d77a206cc17078c912f9c3915e76e70bb26e75e26178 \</span><br><span class="line">--control-plane</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;再加入各个node节点，命令区别是少了<code>--control-plane</code>选项以及控制秘钥。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join <span class="number">172.18</span><span class="number">.32</span><span class="number">.250</span>:<span class="number">6443</span> --token <span class="number">89</span>beqy<span class="number">.13</span>jxavbu7yz3187d \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:<span class="number">7388</span>af4f1662805a844cce7c1371facb83f32dddb998370d11bfb41957fe75bf</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;之后通过命令,就可以看到4个主机都处于<code>ready</code>状态了。至此k8s集群的搭建就完成了。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文将介绍通过kubeadm部署K8s集群的详细过程，且通过两个mater节点实现K8s集群的高可用。&lt;br&gt;&amp;emsp;&amp;emsp;本次演示使用 k8s 官方提供的部署工具 kubeadm 自动安装， 需要在 master 和 node 节点上安装 docker 等组件， 然后初始化， 把管理端的控制服务和 node 上的服务都以pod 的方式运行。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="kubeadm" scheme="https://wudihechao.github.io/tags/kubeadm/"/>
    
      <category term="docker" scheme="https://wudihechao.github.io/tags/docker/"/>
    
      <category term="kubernetes" scheme="https://wudihechao.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker（五）——Docker镜像仓库</title>
    <link href="https://wudihechao.github.io//blog/6187894.html"/>
    <id>https://wudihechao.github.io//blog/6187894.html</id>
    <published>2019-12-07T14:30:04.000Z</published>
    <updated>2019-12-09T02:47:35.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;比较常见的docker镜像仓库，有docker官方仓库<a href="https://hub.docker.com/" rel="noopener" target="_blank">https://hub.docker.com/</a>，和阿里云镜像仓库<code>https://cr.console.aliyun.com/cn-hangzhou/instances/images</code>，可以比较方便的拉取镜像或储存容器镜像。而在企业生产中，绝对部分情况我们都是使用企业内部的镜像仓库，来分发部署我们的代码。本文将详细介绍阿里云仓库还有私有云仓库Registry、Harbor的搭建和使用的详细步骤方法。<br><a id="more"></a></p><h2 id="阿里云仓库"><a href="#阿里云仓库" class="headerlink" title="阿里云仓库"></a>阿里云仓库</h2><p>&emsp;&emsp;docker官方仓库配置比较简单，而且大部分是默认配置，且速度不如阿里云镜像仓库速度快，所以我这里就不介绍了，使用方式和阿里云容器镜像仓库差不多类似。</p><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>&emsp;&emsp;使用阿里云仓库服务首先要注册阿里云账号，支付宝也可以登陆，比较快捷。点击上面的网址登陆即可。<br><img src="https://img-blog.csdnimg.cn/20191207213751920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>&emsp;&emsp;先创建一个命名空间，这相当于每个人独立的url，可以以代码类别或者性质命名创建（也可以凭个人喜好），每个账号只能创建5个命名空间，不过也够用了。<br>&emsp;&emsp;然后创建镜像仓库。<br><img src="https://img-blog.csdnimg.cn/2019120721442027.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;地域选择离自己比较近的地域，这样延迟会稍微低一些，选择已创建的命名空间，仓库名的命名一般是服务名或者软件名。公开或者私有看个人请款选择。</p><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>&emsp;&emsp;有了仓库之后，我们就可以上传镜像了。</p><h4 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h4><p>&emsp;&emsp;要上传镜像，第一步，要先重新打标签，将阿里云的仓库源的地址，仓库名，以及版本号重新打标签，生成新镜像。例如对已有的haproxy镜像重新打标签，因为我选择的是北京节点，所以打标命令如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag haproxy-base:v1 registry<span class="selector-class">.cn-beijing</span><span class="selector-class">.aliyuncs</span><span class="selector-class">.com</span>/【命名空间名称】/【仓库名】:【版本号】</span><br></pre></td></tr></table></figure></p><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>&emsp;&emsp;想上传或者下载镜像一般都需要授权才可以，这就要求我们要用有权限的帐号登陆，才可以上传镜像或者下载镜像。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu</span><span class="symbol">:/opt/dockerfile/web/haproxy/</span><span class="number">2.0</span>.<span class="number">5</span><span class="comment"># docker login --username=【账号名】 registry.cn-beijing.aliyuncs.com</span></span><br><span class="line"><span class="symbol">Password:</span> </span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line"><span class="symbol">https:</span>/<span class="regexp">/docs.docker.com/engine</span><span class="regexp">/reference/commandline</span><span class="regexp">/login/</span><span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">root<span class="variable">@DockerUbuntu</span><span class="symbol">:/opt/dockerfile/web/haproxy/</span><span class="number">2.0</span>.<span class="number">5</span><span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>&emsp;&emsp;用<code>docker images</code>可以查看所有的镜像，选择已经打了阿里云网址的标签的镜像上传就可以了<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root<span class="meta">@DockerUbuntu</span>:<span class="regexp">/opt/</span>dockerfile<span class="regexp">/web/</span>haproxy<span class="regexp">/2.0.5# docker push registry.cn-beijing.aliyuncs.com/</span>【命名空间名称】/【仓库名】:【版本号】</span><br><span class="line">The push refers to repository [registry.cn-beijing.aliyuncs.com<span class="regexp">/命名空间名/</span>仓库名]</span><br><span class="line"><span class="number">0</span><span class="string">ec88a00d427:</span> Pushed </span><br><span class="line"><span class="number">6</span><span class="string">a6e6f03a1a5:</span> Pushed </span><br><span class="line"><span class="number">965</span><span class="string">bdb9c5299:</span> Pushed </span><br><span class="line"><span class="string">a1d450e33837:</span> Pushed </span><br><span class="line"><span class="number">837</span><span class="string">dac687863:</span> Pushed </span><br><span class="line"><span class="string">b39d6a9ec3e2:</span> Pushed </span><br><span class="line"><span class="number">1e7</span><span class="string">fbf47b8df:</span> Pushed </span><br><span class="line"><span class="string">dc298319f184:</span> Pushed </span><br><span class="line"><span class="string">e4809dffd3aa:</span> Pushed </span><br><span class="line"><span class="string">b3cdf76b6336:</span> Pushed </span><br><span class="line"><span class="number">2</span><span class="string">fc5c4732662:</span> Pushed </span><br><span class="line"><span class="number">2</span><span class="string">d03b9db6c3f:</span> Pushed </span><br><span class="line"><span class="number">89169</span><span class="string">d87dbe2:</span> Pushed </span><br><span class="line"><span class="string">haproxy:</span> <span class="string">digest:</span> <span class="string">sha256:</span>f0b4157cd18498e4bc373e333e4fb0b85a65d00e03de2d65015b0d0da9099af6 <span class="string">size:</span> <span class="number">3049</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时就上传成功了</p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>&emsp;&emsp;其他主机登陆成功之后，通过拉取命令就可以从阿里云端下载镜像了。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@DockerCentOS ~]# docker pull registry.<span class="keyword">cn</span>-beijing.aliyuncs.<span class="keyword">com</span>/【命名空间名称】/【仓库名】:【版本号】</span><br><span class="line">haproxy: Pulling from xxxxxxxxxx/web</span><br><span class="line">ac9208207ad<span class="variable">a:</span> Already <span class="built_in">exists</span> </span><br><span class="line"><span class="number">75</span>c124fe932<span class="variable">b:</span> Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">9</span>ef7eb04bb69: Pull <span class="built_in">complete</span> </span><br><span class="line">c5f97c472240: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">9</span>dc49af65399: Pull <span class="built_in">complete</span> </span><br><span class="line">a745615abdb<span class="variable">a:</span> Pull <span class="built_in">complete</span> </span><br><span class="line">ddcf37c0f462: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">0</span>c406d186167: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">246</span>fafa1cb32: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">057</span>e62247ad8: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">770</span>d7edff222: Pull <span class="built_in">complete</span> </span><br><span class="line">b4064e1ed3ec: Pull <span class="built_in">complete</span> </span><br><span class="line">d0a103ae1f19: Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:f0b4157cd18498e4bc373e333e4fb0b85a65d00e03de2d65015b0d0da9099af6</span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> registry.<span class="keyword">cn</span>-beijing.aliyuncs.<span class="keyword">com</span>/xxxxxxxxxx/we<span class="variable">b:haproxy</span></span><br><span class="line">registry.<span class="keyword">cn</span>-beijing.aliyuncs.<span class="keyword">com</span>/xxxxxxxxxx/we<span class="variable">b:haproxy</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时就可以在<code>docker images</code>的镜像列表中看到刚刚拉取的镜像了。</p><h2 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h2><p>&emsp;&emsp;阿里云镜像仓库虽然很方便，但是在生产环境中，每次都从云端拉取或者上传至云端仓库，太消耗企业带宽，有时候数据繁忙的时候，很有可能会堵塞业务，而且速度也较慢。所以企业中都会基于内部局域网搭建企业内部使用的私有仓库。一般搭建私有仓库有两种解决方案，一个是docker自带的Docker Registry，还有就是由vmware公司开源的harbor。</p><h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>&emsp;&emsp;Docker Registry 作为 Docker 的核心组件之一负责镜像内容的存储与分发， 客户端的 docker pull 以及 push 命令都将直接与 registry 进行交互,最初版本的 registry由Python实现,由于设计初期在安全性， 性能以及API的设计上有着诸多的缺陷，该版本在 0.9 之后停止了开发，由新的项目 distribution（新的 docker register 被称为 Distribution）来重新设计并开发下一代 registry，新的项目由 go 语言开发，所有的 API， 底层存储方式， 系统架构都进行了全面的重新设计已解决上一代registry 中存在的问题， 2016 年 4 月份 rgistry 2.0 正式发布， docker 1.6 版本开始支持 registry 2.0，而八月份随着 docker 1.8 发布， docker hub 正式启用 2.1 版本registry 全面替代之前版本 registry，新版 registry 对镜像存储格式进行了重新设计并和旧版不兼容， docker 1.5 和之前的版本无法读取 2.0 的镜像， 另外， Registry2.4 版本之后支持了回收站机制，也就是可以删除镜像了，在 2.4 版本之前是无法支持删除镜像的，所以如果你要使用最好是大于 Registry 2.4 版本的。<br>&emsp;&emsp;Docker Registry的优势就是比较小（25M），但是功能表比较简单。</p><h4 id="下载-docker-registry-镜像"><a href="#下载-docker-registry-镜像" class="headerlink" title="下载 docker registry 镜像"></a>下载 docker registry 镜像</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@DockerCentOS ~]# docker pull registry</span><br><span class="line">Using<span class="built_in"> default </span>tag: latest</span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/registry</span><br><span class="line">c87736221ed0: Pull complete </span><br><span class="line">1cc8e0bb44df: Pull complete </span><br><span class="line">54d33bcb37f5: Pull complete </span><br><span class="line">e8afc091c171: Pull complete </span><br><span class="line">b4541f6d3db6: Pull complete </span><br><span class="line">Digest: sha256:8004747f1e8cd820a148fb7499d71a76d45ff66bac6a29129bfdbfdc0154d146</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry:latest</span><br><span class="line">docker.io/library/registry:latest</span><br></pre></td></tr></table></figure><h4 id="搭建单机仓库"><a href="#搭建单机仓库" class="headerlink" title="搭建单机仓库"></a>搭建单机仓库</h4><p>&emsp;&emsp;先创建授权使用目录<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="selector-tag">p</span> /docker/auth</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建一个用户并创建密码文件<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/docker</span></span><br><span class="line">docker run <span class="params">--entrypoint</span> htpasswd registry -Bbn Mice 123456 &gt; auth/htpasswd <span class="comment">#创建一个用户并生成密码</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;验证用户名密码<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@DockerCentOS</span> docker]<span class="meta"># cat auth/htpasswd</span></span><br><span class="line">Mice:$2y$05$XqNS4BH3gkxodR9MQyhnIuL19uT4wfa6MjUgXvJUYuo0T0o0J8Tzy</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从registry镜像中启动 docker registry,指定容器名称为<code>registry1</code>，挂载本地/docker/auth目录至容器的/auth目录，传递账号密码变量至容器。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always \</span><br><span class="line">-<span class="ruby">-name registry1 \</span></span><br><span class="line"><span class="ruby">-v /docker/<span class="symbol">auth:</span>/auth \</span></span><br><span class="line"><span class="ruby">-e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span></span><br><span class="line"><span class="ruby">-e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span></span><br><span class="line"><span class="ruby">-e REGISTRY_AUTH_HTPASSWD_PATH=<span class="regexp">/auth/htpasswd</span>\</span></span><br><span class="line"><span class="ruby"> registry</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时如果用我们创建的用户名密码尝试登陆了，记得IP或者域名后面要加<strong>5000端口</strong>，否则会报<strong>502</strong>错误。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu19:~# docker login 192.168.32.20</span><br><span class="line">Username: Mice</span><br><span class="line">Password: </span><br><span class="line"><span class="keyword">Error </span>response from daemon: login attempt to http://192.168.32.20/v2/ failed with status: 502 Bad Gateway</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不过很有可能当你加上5000端口，可能还会有报错。ヾ(≧O≦)〃嗷~<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu19:~# docker login 192.168.32.20:5000</span><br><span class="line">Username: Mice</span><br><span class="line">Password: </span><br><span class="line"><span class="keyword">Error </span>response from daemon: Get https://192.168.32.20:5000/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这是因为我们每一个docker主机要设置允许<code>insecure-registries</code>，加上我们registry仓库的IP或者域名。<br>&emsp;&emsp;同样，可以修改<code>/lib/systemd/system/docker.service</code>启动脚本文件，或者<code>/etc/docker/daemon.json</code>文件，推荐修改<code>/etc/docker/daemon.json</code>文件。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://360k4x9i.mirror.aliyuncs.com"</span>],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [<span class="string">"192.168.32.19"</span>,<span class="string">"DockerCentOS20:5000"</span>],</span><br><span class="line">  <span class="attr">"bip"</span>: <span class="string">"10.20.0.1/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后重启docker服务,此时再尝试登陆，就回提示登陆成功。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu19</span><span class="symbol">:~</span><span class="comment"># docker login DockerCentOS20:5000</span></span><br><span class="line"><span class="symbol">Username:</span> Mice</span><br><span class="line"><span class="symbol">Password:</span> </span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line"><span class="symbol">https:</span>/<span class="regexp">/docs.docker.com/engine</span><span class="regexp">/reference/commandline</span><span class="regexp">/login/</span><span class="comment">#credentials-store</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;之后就与阿里云的镜像仓库使用方法相同了，不过速度上会快很多（毕竟内网），可以如果要上传镜像至regist仓库，先打好标签就可以了，下载写明下载仓库源，也就可以正常下载了。ヾ(=ﾟ･ﾟ=)ﾉ喵♪</p><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><p>&emsp;&emsp;Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器， 由vmware开源，其通过添加一些企业必需的功能特性，例如安全、标识和管理等， 扩展了开源 Docker Distribution。作为一个企业级私有Registry服务器，Harbor 提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制， 镜像全部保存在私有Registry中，确保数据和知识产权在公司内部网络中管控， 另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等 ，所以企业生产中，我们更多会选择Harbor。</p><h4 id="下载harbor安装包"><a href="#下载harbor安装包" class="headerlink" title="下载harbor安装包"></a>下载harbor安装包</h4><p>&emsp;&emsp;下载地址： <a href="https://github.com/vmware/harbor/releases" rel="noopener" target="_blank">https://github.com/vmware/harbor/releases</a><br>&emsp;&emsp;安装文档：<a href="https://github.com/vmware/harbor/blob/master/docs/installation_guide.md" rel="noopener" target="_blank">https://github.com/vmware/harbor/blob/master/docs/installation_guide.md</a><br>&emsp;&emsp;本次以harbor的1.75版本为例，演示harbor的安装过程。<br>&emsp;&emsp;下载离线包，并解压。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://storage.googleapis.com/harbor-releases/release-<span class="number">1.7</span><span class="meta">.0</span>/harbor-offline-installer-v1<span class="meta">.7</span><span class="meta">.5</span>.tgz</span><br><span class="line">tar xvf harbor-offline-installer-v1<span class="meta">.7</span><span class="meta">.5</span>.tgz</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以下载在线安装包，但里面没有镜像，之后还要去拉取镜像，不适合生产环境。</p><h4 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h4><p>&emsp;&emsp;Harbor是需要使用docker编排工具docker-compose安装，docker-compose我们之后会专门介绍。而且对docker-compose版本是有要求的，可以查看上面的官方文档链接查看确切版本。<br><img src="https://img-blog.csdnimg.cn/20191208220914881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="Harbor要求"><br>&emsp;&emsp;而如果使用包管理工具yum或者apt直接安装的docker-compose可能版本会比较低，我们这里采用python包管理工具<code>python-pip</code>来安装<code>docker-compose</code>。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">install</span> python-pip -y</span><br><span class="line">pip <span class="keyword">install</span> docker-compose</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后可以通过命令<code>docker compose -v</code>看到docker-compose版本已经是最新稳定版1.25版本了。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu19</span><span class="symbol">:/usr/local/src</span><span class="comment"># docker-compose -v</span></span><br><span class="line">docker-compose version <span class="number">1.25</span>.<span class="number">0</span>, build b42d419</span><br></pre></td></tr></table></figure></p><h4 id="安装Harbor"><a href="#安装Harbor" class="headerlink" title="安装Harbor"></a>安装Harbor</h4><p>&emsp;&emsp;我们习惯于将源码包放在<code>/usr/local/src</code>下，而将主程序放在<code>/usr/local/</code>目录中，所以我们可以将harbor目录的的路径改为<code>/usr/local/harbor</code>，可以通过<code>mv</code>命令，也可以通过软链接方式实现<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sv <span class="regexp">/usr/</span>local<span class="regexp">/src/</span>harbor <span class="regexp">/usr/</span>local<span class="regexp">/</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后修改配置文件<code>harbor.cfg</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/harbor</span><br><span class="line">vim harbor.cfg</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改其中主机名(改为IP或者域名)，管理员登录密码，及邮箱即可。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hostname</span> = <span class="number">192.168</span>.<span class="number">32.19</span></span><br><span class="line"><span class="attr">email_identity</span> = harbor</span><br><span class="line"><span class="attr">email_server</span> = smtp.<span class="number">163</span>.com</span><br><span class="line"><span class="attr">email_server_port</span> = <span class="number">25</span></span><br><span class="line"><span class="attr">email_username</span> = XXXXXXXXX@<span class="number">163</span>.com</span><br><span class="line"><span class="attr">email_password</span> = XXXXXXXXXX</span><br><span class="line"><span class="attr">email_from</span> = admin &lt;XXXXXXXX@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="attr">harbor_admin_password</span> = XXXXXXXXXXXXX</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后更新配置文件中的环境变量到安装文件中,忘记更新环境变量会提示找不到环境变量文件<code>ERROR: Couldn&#39;t find env file: /usr/local/src/harbor/common/config/core/env</code>。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">prepare</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时就可以执行命令,来创建并安装Harbor了。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker-compose up -d</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;或者执行官方脚本（两个都可以）<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="keyword">install</span>.sh</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这时候就可以通过浏览器访问我们刚刚搭建的harbor仓库了，至此企业私有仓库就算是搭建好了。<br><img src="https://img-blog.csdnimg.cn/2019120910105297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;管理员用户名为admin，密码为我们之前在配置文件中修改的<code>harbor_admin_password</code>。<br>&emsp;&emsp;后期如果需要修改配置文件信息，需要先停止harbor，然后修改信息后，更新配置文件信息至harbor服务，之后再试用<code>docker-compose up -d</code>启动harbor服务即可,流程如下。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /usr/local/harbor</span><br><span class="line">docker-compose <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">vim</span> harbor.cfg</span><br><span class="line">./prepare</span><br><span class="line">docker-compose <span class="keyword">up</span> -d</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20191209101117514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;推送流程与使用其他云镜像仓库相同，先打标签,开头加上ip/仓库名，然后直接推送即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;比较常见的docker镜像仓库，有docker官方仓库&lt;a href=&quot;https://hub.docker.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/&lt;/a&gt;，和阿里云镜像仓库&lt;code&gt;https://cr.console.aliyun.com/cn-hangzhou/instances/images&lt;/code&gt;，可以比较方便的拉取镜像或储存容器镜像。而在企业生产中，绝对部分情况我们都是使用企业内部的镜像仓库，来分发部署我们的代码。本文将详细介绍阿里云仓库还有私有云仓库Registry、Harbor的搭建和使用的详细步骤方法。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="Docker" scheme="https://wudihechao.github.io/tags/Docker/"/>
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="容器" scheme="https://wudihechao.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="镜像仓库" scheme="https://wudihechao.github.io/tags/%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker（四）——容器跨主机网络配置</title>
    <link href="https://wudihechao.github.io//blog/7e3785f.html"/>
    <id>https://wudihechao.github.io//blog/7e3785f.html</id>
    <published>2019-12-07T11:32:04.000Z</published>
    <updated>2019-12-09T02:47:35.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;跨主机互联是说 A 宿主机的容器可以访问 B 主机上的容器，但是前提是保证各宿主机之间的网络是可以相互通信的， 然后各容器才可以通过宿主机访问到对方的容器， 实现原理是在宿主机做一个网络路由就可以实现 A 宿主机的容器访问 B主机的容器的目的， 复杂的网络或者大型的网络可以使用 google 开源的 k8s 进行互联。本文之后将详细介绍docker网络配置，并演示容器跨主机通信的实现。<br><a id="more"></a></p><h2 id="docker网络基础"><a href="#docker网络基础" class="headerlink" title="docker网络基础"></a>docker网络基础</h2><p>&emsp;&emsp;之前我们说过，当我们安装完docker应用后，就会自动添加一块虚拟的docker0网卡，并基于docker0网卡，提供了3种可选网络类型供创建的容器使用，分别是bridge(桥接)，host(主机)，none(无外部网络)。其中默认是采用桥接模式，容器中的网卡桥接在docker的网桥上，且通过DHCP自动分配IP，与docker0在同一网段。<br>&emsp;&emsp;当我们每创建一个容器，宿主机上就会新建一个网卡与容器中的网卡相对应，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20191207153539950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="网桥"><br>&emsp;&emsp;容器桥接模式跨网络访问的结构示意图如下图所示<br><img src="https://img-blog.csdnimg.cn/20191207155538522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="docker跨主机通信"><br>&emsp;&emsp;想实现不同宿主机上的容器跨主机肯定要经过宿主机来做网络转发，通过设置宿主机静态路由或者修改iptables规则来实现，可这时就面临一个问题：所有的容器服务默认的DHCP网段都是172.17.0.0/16网段，如果node1上的容器想直接访问node2宿主机上的容器，就会被直接当做docker0网桥的内部网段，数据报文根本都不会从node1主机的eth0网卡发出去，也根本到不了node2主机上。这种情况下，无论我们怎么修改iptables规则或者路由规则都无济于事的。所以我们想实现容器跨主机访问，首先要将不同宿主机上的容器分到不同的网段，然后才可以通过路由规则或者iptables进行跳转或转发。</p><h3 id="修改docker网络的网段"><a href="#修改docker网络的网段" class="headerlink" title="修改docker网络的网段"></a>修改docker网络的网段</h3><p>&emsp;&emsp;我们可以对每一个宿主机上的docker配置文件进行修改，实现每个宿主机的docker容器都在不同网段的目的,可以通过以下方式修改（未避免影响， 先在各服务器删除之前创建的所有容器，<code>docker rm -f `docker ps -a -q`</code>）。</p><ul><li>修改启动system脚本文件<code>docker.service</code><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">docker</span>.<span class="title">service</span></span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;在<code>ExecStart=</code>选项结尾加上<code>--bip=10.1.0.1/24</code>，就指定了10.1.0.0/24网段，然后执行命令重新加载配置文件和重启服务。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart docker</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>注意:<code>不能写10.1.0.0/24，会报错</code></strong>，虽然写网段结尾是0，如10.1.0.0/24更符合我们的习惯，不过确实会报错，报错信息如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dec 07 16:27:58 DockerUbuntu dockerd[14794]: failed to <span class="keyword">start</span> daemon: <span class="keyword">Error</span> initializing network controller: <span class="keyword">Error</span> creating <span class="keyword">default</span> <span class="string">"bridge"</span> network: <span class="keyword">failed</span> <span class="keyword">to</span> <span class="keyword">allocate</span> gateway (<span class="number">10.10</span><span class="number">.0</span><span class="number">.0</span>): Address already <span class="keyword">in</span> <span class="keyword">use</span></span><br><span class="line"><span class="built_in">Dec</span> <span class="number">07</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">58</span> DockerUbuntu systemd[<span class="number">1</span>]: docker.service: <span class="keyword">Main</span> process exited, code=exited, <span class="keyword">status</span>=<span class="number">1</span>/<span class="keyword">FAILURE</span></span><br><span class="line"><span class="built_in">Dec</span> <span class="number">07</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">58</span> DockerUbuntu systemd[<span class="number">1</span>]: docker.service: <span class="keyword">Failed</span> <span class="keyword">with</span> <span class="keyword">result</span> <span class="string">'exit-code'</span>.</span><br><span class="line"><span class="built_in">Dec</span> <span class="number">07</span> <span class="number">16</span>:<span class="number">27</span>:<span class="number">58</span> DockerUbuntu systemd[<span class="number">1</span>]: <span class="keyword">Failed</span> <span class="keyword">to</span> <span class="keyword">start</span> Docker Application <span class="keyword">Container</span> Engine.</span><br><span class="line"><span class="comment">-- Subject: Unit docker.service has failed</span></span><br><span class="line"><span class="comment">-- Defined-By: systemd</span></span><br></pre></td></tr></table></figure></p><ul><li>也可以修改daemon.json文件，在里面添加<code>&quot;bip&quot;: &quot;10.2.0.1/24&quot;</code>，如下所示（上面那个是我的阿里云加速器链接，注册阿里账号免费获取，<a href="https://blog.csdn.net/MicePro/article/details/103411387#t0" rel="noopener" target="_blank">之前文章</a>有详细介绍，需改成自己的或者删掉）：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xxxxxxxx.mirror.aliyuncs.com"</span>,<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line">        <span class="string">"bip"</span>: <span class="string">"10.1.0.1/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;<strong>daemon.json文件是json数据格式，需要遵守json语法，换行记得要加<code>,</code>逗号。</strong><br>&emsp;&emsp;直接重启docker服务后生效<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart docker</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时看网卡的ip就已经变为了我们设置的网段，之后创建的容器服务器就会自动获取我们设置好的网段中的IP了。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu:~# ifconfig</span><br><span class="line">docker0: flags=<span class="number">4099</span>&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">10.10</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">10.10</span><span class="number">.0</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">42</span>:<span class="number">25f</span>f:fe2b:ecbc  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">02</span>:<span class="number">42</span>:<span class="number">25</span>:<span class="number">2</span>b:ec:bc  txqueuelen <span class="number">0</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">41</span>  bytes <span class="number">3526</span> (<span class="number">3.5</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;同样的操作，将node2宿主机中的docker0网段设置为10.2.0.0/24</p><h3 id="修改静态路由"><a href="#修改静态路由" class="headerlink" title="修改静态路由"></a>修改静态路由</h3><p>&emsp;&emsp;我这里node1的eth0网卡ip为192.168.32.19，node2的eth0网卡ip为192.168.32.20，且两个宿主机之前网络是可以通过eth0网卡相互连接的。添加路由规则如下：<br>&emsp;&emsp;在node1上添加静态路由<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip r add <span class="number">10.2</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.32</span><span class="number">.20</span> dev eth0</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在node2上添加静态路由<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip r add <span class="number">10.1</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span> via <span class="number">192.168</span><span class="number">.32</span><span class="number">.19</span> dev eth0</span><br></pre></td></tr></table></figure></p><h3 id="修改iptables规则"><a href="#修改iptables规则" class="headerlink" title="修改iptables规则"></a>修改iptables规则</h3><p>&emsp;&emsp;宿主机如果为centos7，则不需要修改iptables规则，而宿主机如果为ubuntu系统则需要添加forward规则来放行。我仔细看了下这两个系统的iptables规则，发现在centos系统docker创建的iptables规则中对<code>Chain FORWARD</code>是默认<code>ACCEPT</code>，而ubuntu系统中docker创建的iptables对<code>Chain FORWARD</code>是默认<code>DROP</code><br><img src="https://img-blog.csdnimg.cn/20191207185124292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="dockecentosiptables"><br><img src="https://img-blog.csdnimg.cn/20191207185139492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="dockerubuntuiptables"><br>&emsp;&emsp;之后两边各启动一个容器就可以实现相互通信或访问了。</p><h2 id="docker网络进阶"><a href="#docker网络进阶" class="headerlink" title="docker网络进阶"></a>docker网络进阶</h2><p>&emsp;&emsp;之前我们演示了通过docker0网卡的桥接方式实现了容器跨主机访问。我们通过修改docker0网卡的网段设置来实现，每个主机上容器的网段不同。<br>&emsp;&emsp;这种实现方式有个问题就是，但当每次我们修改了docker0网段之后，如果之后打算变更网段，之前的容器都将无法与docker0网桥桥接，导致网络不通，不能使用。<br>&emsp;&emsp;对此我们有一个更灵活的方案来实现容器的跨主机通信。那就是我们还可以通过创建一个或多个自定义网络，将新创建的每个容器指定连接到我们创建的这个网络中，这样他们的网段就是我们设置的这个网络的网段，实现每个主机上容器网段都不相同。</p><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><p>&emsp;&emsp;可以将我们之前对docker0网卡的修改还原了的（当然，也可以不修改，出于控制变量方便观察考虑，建议修改回去）。<br>&emsp;&emsp;我们可以通过<code>docker network create</code>命令来创建一个自定义网络<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu:~<span class="comment"># docker network create --help</span></span><br><span class="line"></span><br><span class="line">Usage:docker network <span class="keyword">create</span> [OPTIONS] NETWORK</span><br><span class="line"></span><br><span class="line"><span class="keyword">Create</span> a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      <span class="comment">--attachable           Enable manual container attachment</span></span><br><span class="line">      <span class="comment">--aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver</span></span><br><span class="line">                             (<span class="keyword">default</span> <span class="keyword">map</span>[])</span><br><span class="line">      <span class="comment">--config-from string   The network from which copying the configuration</span></span><br><span class="line">      <span class="comment">--config-only          Create a configuration only network</span></span><br><span class="line">  -d, <span class="comment">--driver string        Driver to manage the Network (default "bridge")</span></span><br><span class="line">      <span class="comment">--gateway strings      IPv4 or IPv6 Gateway for the master subnet</span></span><br><span class="line">      <span class="comment">--ingress              Create swarm routing-mesh network</span></span><br><span class="line">      <span class="comment">--internal             Restrict external access to the network</span></span><br><span class="line">      <span class="comment">--ip-range strings     Allocate container ip from a sub-range</span></span><br><span class="line">      <span class="comment">--ipam-driver string   IP Address Management Driver (default "default")</span></span><br><span class="line">      <span class="comment">--ipam-opt map         Set IPAM driver specific options (default map[])</span></span><br><span class="line">      <span class="comment">--ipv6                 Enable IPv6 networking</span></span><br><span class="line">      <span class="comment">--label list           Set metadata on a network</span></span><br><span class="line">  -o, <span class="comment">--opt map              Set driver specific options (default map[])</span></span><br><span class="line">      <span class="comment">--scope string         Control the network's scope</span></span><br><span class="line">      <span class="comment">--subnet strings       Subnet in CIDR format that represents a network segment</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;例如我们在node1创建一个名为web1的桥接网络，网段为10.10.0.0/24,设置网关为10.10.0.1（可设置为此网段内任意ip）。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu:~# docker<span class="built_in"> network </span>create -d<span class="built_in"> bridge </span>--subnet 10.10.0.0/24 --gateway 10.10.0.1 web1</span><br><span class="line">a817cf36502eea3469e1cb4b9b7577044f8dce96f015ba57a47f6809c00d72c7</span><br><span class="line">root@DockerUbuntu:~# docker<span class="built_in"> network </span>ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">afd91b2e1731       <span class="built_in"> bridge </span>            <span class="built_in"> bridge </span>             local</span><br><span class="line">241d3e94a6b3        host                host                local</span><br><span class="line">7cc9cf9eb69e        none                <span class="literal">null</span>                local</span><br><span class="line">a817cf36502e        web1               <span class="built_in"> bridge </span>             local</span><br><span class="line">root@DockerUbuntu:~#</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以用<code>docker network ls</code>(或<code>docker network list</code>)看到网络类型多了一种，也就是我们刚刚创建的web1类型。<br>而用<code>ifconfig</code>或者<code>ip a</code>命令也可以看到我们的网卡设备里多了一个<code>br-a817cf36502e</code>，ip也恰好是我们指定的<code>10.10.0.0/24</code>网段。<br><img src="https://img-blog.csdnimg.cn/20191207192708651.png" alt="自定义网络"><br>&emsp;&emsp;此时我们就可以通过<code>--net</code>选项指定我们刚刚创建的web1网络，来创建并启动容器了。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu:~# docker run -it -d -p <span class="number">8080</span>:<span class="number">8080</span> -p <span class="number">8009</span>:<span class="number">8009</span> --net=web1 tomcat-app1:v1</span><br><span class="line">afc1e3db8a6a670d30cdd0756af65da74895976ce5ebbf876329b04b452a3710</span><br><span class="line"><span class="symbol">root@</span>DockerUbuntu:~#</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;同样，在宿主机node2上也创建一个自定义网络web2，然后新创建的容器，也指定网络为web2，再设置静态路由和修改iptables规则放行，也可以实现容器间跨主机访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;跨主机互联是说 A 宿主机的容器可以访问 B 主机上的容器，但是前提是保证各宿主机之间的网络是可以相互通信的， 然后各容器才可以通过宿主机访问到对方的容器， 实现原理是在宿主机做一个网络路由就可以实现 A 宿主机的容器访问 B主机的容器的目的， 复杂的网络或者大型的网络可以使用 google 开源的 k8s 进行互联。本文之后将详细介绍docker网络配置，并演示容器跨主机通信的实现。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="Docker" scheme="https://wudihechao.github.io/tags/Docker/"/>
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="容器" scheme="https://wudihechao.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="跨主机通信" scheme="https://wudihechao.github.io/tags/%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    
      <category term="容器网络" scheme="https://wudihechao.github.io/tags/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker（三）——镜像制作</title>
    <link href="https://wudihechao.github.io//blog/ddd838e7.html"/>
    <id>https://wudihechao.github.io//blog/ddd838e7.html</id>
    <published>2019-12-06T07:02:09.000Z</published>
    <updated>2019-12-09T02:47:35.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;在docker使用过程中，其实大部分时间都是花在了打镜像上，因为容器本身底层不可写，顶层可读写缺无法持久化性质，我们如果对容器进行了修改，想要进行横向扩容，快速部署时，一般需要重新制作镜像，在分发到其他主机或终端。（虽然也可以将数据储存在NFS和宿主机本地，而不是容器内部来方便的修改配置文件及保存数据等。）<br>&emsp;&emsp;docker中镜像的制作方式一般手工修改后导出和通过Dockerfile生成两种方式。<br><a id="more"></a></p><h2 id="手动制作镜像"><a href="#手动制作镜像" class="headerlink" title="手动制作镜像"></a>手动制作镜像</h2><p>&emsp;&emsp;因为镜像本身的不可修改性，有时候官方镜像中使用的工具的版本可能不是那么符合我们的生产环境，我们就需要自己制作镜像了。一般来说，我们都是基于官方镜像，作出修改来符合自身实际场景中使用，然后在导出保存为我们自己的镜像。<br>&emsp;&emsp;以一个tomcat容器为例，我们如果需要tomcat8的容器，可以直接从官网拉取tomcat8的镜像<code>docker pull tomcat:8.5.49-jdk8-openjdk</code>修改完成后，还可以使用命令<code>docker commit</code>将已有容器制作为镜像.<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu</span><span class="symbol">:/opt/dockerfile/web/tomcat/tomcat-apps/app1</span><span class="comment"># docker commit --help</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Usage:</span>docker commit [OPTIONS] CONTAINER [REPOSITORY[<span class="symbol">:TAG</span>]]</span><br><span class="line"></span><br><span class="line">Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -a, --author string    Author (e.g., "John Hannibal Smith &lt;hannibal@a-team.com&gt;")</span></span><br><span class="line"><span class="string">  -c, --change list      Apply Dockerfile instruction to the created image</span></span><br><span class="line"><span class="string">  -m, --message string   Commit message</span></span><br><span class="line"><span class="string">  -p, --pause            Pause container during commit (default true)</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>-a</code>添加镜像制作人信息，<code>-m</code>添加备注信息，<code>-p</code>选项是默认选项，在制作为镜像时暂停容器，<code>-c</code>使用Dockerfile指令来创建镜像，Dockerfile之后我们会详细讲解。例如<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -<span class="selector-tag">a</span> <span class="string">"example@163.com"</span> -m <span class="string">"tomcat app1 v1"</span> --change=<span class="string">"EXPOSE 8080 8009"</span> f5f8c13d0f9f centos-tomcat-app1:v1</span><br></pre></td></tr></table></figure></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>&emsp;&emsp;不过如果业务场景要求的配置场景要修改nginx的编译参数或者要求底层是centos7系统这就没法更改了（官方镜像一般都是debian系统），我们只能修改最上层的镜像。此时我们可以通过分层构建的方式来制作镜像(，毕竟docker镜像本来就是分层构建的)。<br>&emsp;&emsp;DockerfileDockerFile 可以说是一种可以被 Docker 程序解释的脚本， DockerFile 是由一条条的命令组成的，每条命令对应 linux 下面的一条命令， Docker 程序将这些 DockerFile 指令再翻译成真正的 linux 命令，其有自己的书写方式和支持的命令， Docker 程序读取 DockerFile 并根据指令生成 Docker 镜像，相比手动制作镜像的方式， DockerFile 更能直观的展示镜像是怎么产生的，有了写好的各种各样 DockerFile 文件，当后期某个镜像有额外的需求时，只要在之前的DockerFile 添加或者修改相应的操作即可重新生成新的 Docke 镜像，避免了重复手动制作镜像的麻烦。<br>&emsp;&emsp;Docker中常用到的命令令有<code>FROM</code>（指定基础镜像名称）,<code>MAINTAINER</code>（镜像作者署名及联系方式）,<code>USER</code>（切换用户身份，初始一般为root）,<code>WORKDIR</code>（指定或切换工作目录），<code>ADD</code>（将当前宿主机目录的文件拷贝至容器指定位置，tar包可以自动解压）,<code>RUN</code>(运行命令，其实就是shell命令，可执行多条，用&amp;&amp;符号连接),<code>ENV</code>（设置环境变量）,<code>CMD</code>（设置默认镜像启动命令，要可以占据前台，否则基于此镜像启动的容器会直接停止），之后我们结合实际例子一一说明。</p><p>&emsp;&emsp;例如我们使用Dockerfile来分层构建定制的tomcat镜像来运行app1服务（当然，也可以一步到位），步骤如下：</p><ol><li><p>构建目录架构<br>我们通常将Dockerfile文件都放置在<code>/opt/</code>目录下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/dockerfile/&#123;web/&#123;nginx,tomcat,jdk&#125;,<span class="built_in">system</span>/&#123;centos,ubuntu,redhat&#125;&#125; -<span class="built_in">pv</span></span><br></pre></td></tr></table></figure></li><li><p>构建系统镜像</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/dockerfile/<span class="built_in">system</span>/centos</span><br><span class="line"><span class="built_in">mkdir</span> <span class="number">7.6</span></span><br><span class="line"><span class="keyword">cd</span> <span class="number">7.6</span></span><br><span class="line">docker pull cento<span class="variable">s:7</span>.<span class="number">6.1810</span></span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;创建Dockerfile文件,注意D要大写<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"><span class="comment">#CentOS 7.6 镜像</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.6</span>.<span class="number">1810</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> Mice example@<span class="number">163</span>.com</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rpm -ivh http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y vim wget tree lrzsz gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel openssl openssl-devel iproute net-tools iotop</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"bash"</span>]</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建制作镜像脚本，来生成镜像。当然，也可以直接使用<code>docker build</code>命令配合<code>-t</code>参数（指定标签名）直接将当前目录的Dockerfile制作为镜像，使用脚本是为了日后修改不至于每次名称都不一样，可以保证每次打的镜像的名称和版本号统一，否则以后镜像多了会乱（脚本中也可以在标签中加上时间）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim build_centos.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker build -t centos-base:v7.6.1810 .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;当前目录结构为<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu</span><span class="symbol">:/opt/dockerfile/system/centos/</span><span class="number">7.6</span><span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build_centos.sh</span><br><span class="line">└── Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;执行命令<code>bash build_centos.sh</code>来创建第一层镜像<code>centos-base:v7.6.1810</code><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu:/opt/dockerfile/system/centos/<span class="number">7.6</span># bash build_centos.sh </span><br><span class="line">Sending build context to Docker daemon  <span class="number">3.072</span>kB</span><br><span class="line">Step <span class="number">1</span>/<span class="number">5</span> : FROM centos:<span class="number">7.6</span><span class="number">.1810</span></span><br><span class="line"> ---&gt; f1cb7c7d58b7</span><br><span class="line">Step <span class="number">2</span>/<span class="number">5</span> : MAINTAINER Mice <span class="symbol">example@</span><span class="number">163.</span>com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; <span class="number">3899</span>d2446806</span><br><span class="line">Step <span class="number">3</span>/<span class="number">5</span> : RUN rpm -ivh http:<span class="comment">//mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; <span class="number">5</span>a72857ed63d</span><br><span class="line">Step <span class="number">4</span>/<span class="number">5</span> : RUN yum install -y vim wget tree lrzsz gcc gcc-c++ <span class="built_in">auto</span>make pcre pcre-devel zlib zlib-devel openssl openssl-devel iproute net-tools iotop</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; <span class="number">705f</span>ed38cb94</span><br><span class="line">Step <span class="number">5</span>/<span class="number">5</span> : CMD [<span class="string">"bash"</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> aea451be0461</span><br><span class="line">Removing <span class="built_in">int</span>ermediate container aea451be0461</span><br><span class="line"> ---&gt; <span class="number">160</span>b9544f121</span><br><span class="line">Successfully built <span class="number">160</span>b9544f121</span><br><span class="line">Successfully tagged centos-base:v7<span class="number">.6</span><span class="number">.1810</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;有时到yum那步会提示报错，无法解析IP。多执行几次脚本，多试几次就可以了。他会有缓存自动保存镜像，已经写好的层数会自动缓存的，如上面的<code>---&gt; Using cache</code>。</p><ol start="3"><li>构建适合版本的jdk镜像<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/dockerfile/web/jdk/</span><br><span class="line"><span class="built_in">mkdir</span> <span class="number">8</span>u212</span><br><span class="line"><span class="keyword">cd</span> <span class="number">8</span>u212</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;将准备好的jdk压缩包<code>jdk-8u212-linux-x64.tar.gz</code>放入此目录，然后还是编写<code>Dockerfile</code>以及<code>build_jdk.sh</code>脚本<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"><span class="comment">#JDK 8u212</span></span><br><span class="line"><span class="keyword">FROM</span> centos-base:v7.6.1810</span><br><span class="line">MAINTAINER Mice example@163.com</span><br><span class="line"><span class="builtin-name">ADD</span> jdk-8u212-linux-x64.tar.gz /usr/local/src/</span><br><span class="line"><span class="builtin-name">ADD</span> env.sh /etc/profile.d/</span><br><span class="line"><span class="builtin-name">RUN</span> ln -sv /usr/local/src/jdk1.8.0_212 /usr/local/jdk &amp;&amp; groupadd www -g 2019 &amp;&amp; useradd www -u 2019 -g www</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/java/default</span><br><span class="line">ENV PATH <span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">ENV JRE_HOME <span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/:<span class="variable">$JRE_HOME</span>/lib/</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">RUN</span> rm -rf /etc/localtime &amp;&amp; ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim build_jdk.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker build -t jdk-base:v1.8.0_212 .</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，因为ENV环境变量是当前用户（当前终端）有效，也就是说对于容器本身来说，他运行的环境变量是已经通过ENV可以设置好，可是如果发生故障，我们需要连接进入容器时，这个ENV就对我们当前终端无效了，我们可能就无法使用那些ENV设置了的PATH变量了，所以我们需要添加一个<code>环境变量配置文件</code>至<code>/etc/profile.d目录</code>（也可直接替换profile文件），以便这些环境变量在我们连接至容器后也可以生效。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim env.sh</span><br><span class="line">JAVA_HOME=<span class="regexp">/usr/local</span><span class="regexp">/jdk</span></span><br><span class="line"><span class="regexp">JRE_HOME=$JAVA_HOME/jre</span></span><br><span class="line">CLASSPATH=$JAVA_HOME/<span class="class"><span class="keyword">lib</span>/:$<span class="title">JRE_HOME</span>/<span class="title">lib</span>/</span></span><br><span class="line">PATH=$<span class="symbol">PATH:</span>$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;目录结构如下所示<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu</span><span class="symbol">:/opt/dockerfile/web/jdk/</span><span class="number">8</span>u212<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build_jdk.sh</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── env.sh</span><br><span class="line">└── jdk-<span class="number">8</span>u212-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">4</span> files</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;还是通过build脚本，构建jdk容器。</p><ol start="4"><li>构建适合版本的tomcat镜像<br>先创建版本目录(，为日后可能需要不同版本的tomcat弄好框架)。<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/dockerfile/web/tomcat/</span><br><span class="line"><span class="built_in">mkdir</span> <span class="number">8.5</span>.<span class="number">47</span></span><br><span class="line"><span class="keyword">cd</span> <span class="number">8</span></span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;将准备好的tomcat源码包拷到这个目录，或者wget下载<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/apache/</span>tomcat<span class="regexp">/tomcat-8/</span>v8.<span class="number">5.47</span><span class="regexp">/bin/</span>apache-tomcat-<span class="number">8.5</span>.<span class="number">47</span>.tar.gz</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;制作Dockerfile<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"><span class="comment">#tomcat 8-jdk 1.8.0_212-centos 7.6</span></span><br><span class="line"><span class="keyword">FROM</span> jdk-base:v1.<span class="number">8.0</span>_212</span><br><span class="line"><span class="keyword">MAINTAINER</span> Mice example@<span class="number">163</span>.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="keyword">ENV</span> LANG en_US.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> TERM xterm</span><br><span class="line"><span class="keyword">ENV</span> TOMCAT_MAJOR_VERSION <span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> TOMCAT_MINOR_VERSION <span class="number">8.5</span>.<span class="number">47</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /apps/tomcat</span><br><span class="line"><span class="keyword">ENV</span> APP_DIR $&#123;CATALINA_HOME&#125;/webapps</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /apps</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-8.5.47.tar.gz /apps/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sv /apps/apache-tomcat-8.5.47 /apps/tomcat</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;老规矩，创建build脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim build_tomcat.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker build -t tomcat-base:v8.5.47 .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后执行脚本打镜像~</p><ol start="5"><li>放置项目app1至指定目录构建镜像<br>&emsp;&emsp;到现在，tomcat容器的环境都配置好了，不过里面还没有跑服务，所以可以针对不同的业务，创建不同的镜像，而他们底层都是共用的一个基础镜像<code>tomcat-base:v8.5.47</code>，所有底层镜像因为都是只读的，所以可以复用而互不干扰，也不会重复占用多余的空间。<br>还是先创建业务APP目录。<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv <span class="meta-keyword">/opt/</span>dockerfile<span class="meta-keyword">/web/</span>tomcat<span class="meta-keyword">/myapps/</span>app1/</span><br><span class="line">cd <span class="meta-keyword">/opt/</span>dockerfile<span class="meta-keyword">/web/</span>tomcat<span class="meta-keyword">/myapps/</span>app1/</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;因为当app1有变化时，tomcat服务可能会需要重启才会生效变化，而如果tomcat服务是容器的启动进程(即PID=1的进程)时，重启tomcat会导致容器终止，容器里面在运行的数据及session都会丢失。所以我们使用<code>tail -f</code>命令来作为这个容器的守护进程来启动容器。我们可以通过构建一个脚本<code>run_tomcat.sh</code>来实现，启动tomcat并让tail -f 最为前台进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim run_tomcat.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">su - www -c <span class="string">"/apps/tomcat/bin/catalina.sh start"</span></span><br><span class="line">su - www -c <span class="string">"tail -f /etc/hosts"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;且为了安全考虑，我们打算让tomcat服务以www用户身份启动，所以在构建容器时，需要注意权限问题，Dockerfile如下：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"><span class="comment"># tomcat-apps</span></span><br><span class="line"><span class="keyword">FROM</span> tomcat-base:v8.<span class="number">5.47</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> run_tomcat.sh /apps/tomcat/bin/run_tomcat.sh</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> app1/* /apps/tomcat/webapps/myapp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chown www.www /apps/ -R</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span> <span class="number">8009</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/apps/tomcat/bin/run_tomcat.sh"</span>]</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;而且我们把<code>run_tomcat.sh</code>传进去后，要以脚本启动的话，要对脚本加执行权限，这样传进去的时候也是有执行权限的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> +<span class="selector-tag">x</span> <span class="selector-tag">run_tomcat</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后构建build脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim build_app1.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docker build -t tomcat-app1:v1 .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后将APP1的程序代码拷贝至当前目录，结构示意图如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@DockerUbuntu</span><span class="symbol">:/opt/dockerfile/web/tomcat/myapps/app1</span><span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build_app1.sh</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── app1</span><br><span class="line">│   └── index.html</span><br><span class="line">└── run_tomcat.sh</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> directory, <span class="number">4</span> files</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;就可以执行build脚本打镜像啦。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bash </span><span class="keyword">build_app1.sh</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的是，启动镜像时记得加<code>端口映射</code>，命令如下<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p <span class="number">8080</span>:<span class="number">8080</span> -p <span class="number">8009</span>:<span class="number">8009</span> tomcat-app1:v1</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时通过<code>ss -tanl</code>命令就可以看到8080、80009端口已经被docker proxy监听了。说明服务启动成功。<br>如果宿主机为centos，或者redhat（ubuntu默认是开启的），可能会需要先打开内核参数ip_forward选项，否则会报错网络不可用:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">WARNING: </span>IPv4 forwarding is disabled. Networking will not work.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;那就开启IP转发。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_forward</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后<code>sysctl -p</code>生效就可以正常使用容器网络了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>&emsp;&emsp;需要注意的是，<code>RUN</code>命令是类似启动一个新的进程或者是shell，来执行每一次命令，执行完毕后此次<code>RUN</code>进程结束，下一次是一个全新的<code>RUN</code>进程了，相互之间不会联系。这么说可能大家无法理解，举个最简单的例子吧，就是当我们想要编译安装haproxy的时候，需要进入编译目录然后执行<code>make</code>命令，编译完后还要在编译目录执行<code>make install</code>命令。所以可以写成<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /usr/localk/haproxy-2.0.5 &amp;&amp; make --xxx参数选项省略xxxx  &amp;&amp; make install</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;但是如果我们像写脚本那样，写成<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /usr/localk/haproxy-2.0.5</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make --xxx参数选项省略xxxx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;或者<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /usr/localk/haproxy-2.0.5 &amp;&amp; make --xxx参数选项省略xxxx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;就会报错找不到路径，因为没一条命令都是一层独立的镜像，每层镜像开始都会在默认的初始目录，所以如果打算将<code>make</code>和<code>make install</code>分开写，则两次都加<code>cd /usr/local/haproxy-2.0.5</code>,或者直接切换工作目录，如下所示。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/local/src/haproxy-2.0.5</span><br><span class="line"><span class="builtin-name">RUN</span> make <span class="attribute">ARCH</span>=x86_64 \</span><br><span class="line"><span class="attribute">TARGET</span>=linux-glibc <span class="attribute">USE_PCRE</span>=1 \</span><br><span class="line"><span class="attribute">USE_OPENSSL</span>=1 \</span><br><span class="line"><span class="attribute">USE_ZLIB</span>=1 \</span><br><span class="line"><span class="attribute">USE_CPU_AFFINITY</span>=1 \</span><br><span class="line"><span class="attribute">USE_LUA</span>=1 \</span><br><span class="line"><span class="attribute">LUA_INC</span>=../lua-5.3.5/src/ \</span><br><span class="line"><span class="attribute">LUA_LIB</span>=../lua-5.3.5/src/ \</span><br><span class="line"><span class="attribute">PREFIX</span>=/apps/haproxy</span><br><span class="line"><span class="builtin-name">RUN</span> make install <span class="attribute">PREFIX</span>=/apps/haproxy</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>WORKDIR</code>和<code>USER</code>很类似，都是修改后，对后续Dockerfile指令有效。且<code>WORKDIR</code>还支持相对路径，例如<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;则最终的工作目录为<code>/a/b/c</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在docker使用过程中，其实大部分时间都是花在了打镜像上，因为容器本身底层不可写，顶层可读写缺无法持久化性质，我们如果对容器进行了修改，想要进行横向扩容，快速部署时，一般需要重新制作镜像，在分发到其他主机或终端。（虽然也可以将数据储存在NFS和宿主机本地，而不是容器内部来方便的修改配置文件及保存数据等。）&lt;br&gt;&amp;emsp;&amp;emsp;docker中镜像的制作方式一般手工修改后导出和通过Dockerfile生成两种方式。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="Docker" scheme="https://wudihechao.github.io/tags/Docker/"/>
    
      <category term="Dockerfile" scheme="https://wudihechao.github.io/tags/Dockerfile/"/>
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="容器" scheme="https://wudihechao.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker（二）——基础命令详解</title>
    <link href="https://wudihechao.github.io//blog/5c39f4ef.html"/>
    <id>https://wudihechao.github.io//blog/5c39f4ef.html</id>
    <published>2019-12-06T07:02:09.000Z</published>
    <updated>2019-12-09T02:47:35.870Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;安装完Docker的服务，我们就可以开始使用Docker了。<br><a id="more"></a></p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>&emsp;&emsp;之前我们提到，docker是一个运行容器的工具，可以单独隔离每个服务的运行环境，达到互不干扰和节约资源的目的。而docker运行的容器，是基于一层一层的镜像联合挂载构建而成。所以我们需要先有镜像。<br>&emsp;&emsp;所谓镜像，其实可以理解为，一个个的最简化的安装包，里面只集成了一些必备的程序和文件，且每一层和每一层镜像是可以相互一样的，大大的节约了空间，提高了资源利用率。举个最简单的例子，我们从官方下载一个centos系统的镜像包centos:apline，大小才5.55兆，而centos差不多至少200兆了，而centos安装的ISO镜像文件也都差不多1G左右。这是因为容器使用的镜像系统，需要依赖宿主机内核来运行，容器本身是没有内核的，只包含一些基础功能命令而已。可用<code>docker images</code>查看本地镜像，从大小来看，就知道容器确实很精简。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>DockerUbuntu:~# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">alpine              latest              <span class="number">965</span>ea09ff2eb        <span class="number">6</span> weeks ago         <span class="number">5.55</span>MB</span><br><span class="line">centos              latest              <span class="number">0f</span>3e07c0138f        <span class="number">2</span> months ago        <span class="number">220</span>MB</span><br><span class="line">centos              <span class="number">7.6</span><span class="number">.1810</span>            f1cb7c7d58b7        <span class="number">8</span> months ago        <span class="number">202</span>MB</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以在docker官方镜像仓库<a href="https://hub.docker.com" rel="noopener" target="_blank">https://hub.docker.com</a>查看官方镜像,也可以通过命令直接搜索centos的可用容器<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker search centos</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;注意：官方仓库也有很多是个人的镜像，为避免未知风险，一定要采用官方镜像，千万别使用安全性未知或来源不明的的镜像。一般排在第一个是官方镜像。<br>&emsp;&emsp;使用命令<code>docker pull centos</code>就可以自动从docker官方镜像仓库docker.io，下载centos镜像了，因为我们没有指定版本标签，所以这条命令会默认下载<code>centos:latest</code>版本，也就是最新版。生产中我们出于稳定性和便于管理，都会推荐使用指定的稳定版本，而不会采用latest版本（，随着版本发型，之前的latest版本和几个月之后的latest版很有可能就不是一个版本，不利于规范化统一）。我们本次以CentOS7.6中的最新版<code>centos:7.6.1810</code>最为本次演示的版本。下载镜像命令如下：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:<span class="number">7.6</span><span class="number">.1810</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用<code>docker image rm [ OPTION ] 容器ID</code>可以删除不要的镜像，如果已有容器基于此镜像启动，则会提示错误，无法删除，需先停止容器，或直接加<code>-f选项</code>强制删除镜像，此时容器也会被停止。注意，当容器被停止时，上面的数据也都会丢失，所以需要谨慎关闭容器和删除镜像。<br>&emsp;&emsp;此外，docker官方镜像站，因为在国外(美国，不过应该是有CDN或者国内镜像加速站点的，不过还是有点点慢)，肯定不如阿里的容器镜像仓库速度快。所以我们可以配置阿里的镜像加速器，需要注册阿里账号。<br>&emsp;&emsp;进入阿里网站<a href="http://cr.console.aliyun.com" rel="noopener" target="_blank">http://cr.console.aliyun.com</a>，登陆之后，可以看到阿里的镜像仓库(之后再细说)还有镜像加速器，点击镜像加速器，可看到如图所示界面：<br><img src="https://img-blog.csdnimg.cn/20191205220137716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="Docker镜像加速">&emsp;&emsp;执行将下面代码，便可实现镜像加速了。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -<span class="selector-tag">p</span> /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon<span class="selector-class">.json</span> &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xxxxxxxx.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;之后使用<code>docker info</code>命令就可以看到已经添加镜像仓库成功<br><img src="https://img-blog.csdnimg.cn/20191205220652786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="docker info"></p><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>&emsp;&emsp;有了镜像之后我们就可以从中运行容器了。基础的命令有<code>docker pull</code>、<code>docker push</code>、<code>docker create</code>、<code>docker run</code>、<code>docker ps</code>、<code>docker rm</code>、<code>docker start</code>、<code>docker stop</code>、<code>docker images</code>、<code>docker exec</code>、<code>docker inspect</code>等等</p><h3 id="pull-push"><a href="#pull-push" class="headerlink" title="pull push"></a>pull push</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu:~<span class="comment"># docker pull --help</span></span><br><span class="line"></span><br><span class="line">Usage:docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Pull <span class="keyword">an</span> image <span class="keyword">or</span> <span class="keyword">a</span> repository <span class="built_in">from</span> <span class="keyword">a</span> registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -<span class="keyword">a</span>, <span class="comment">--all-tags                Download all tagged images in the repository</span></span><br><span class="line">      <span class="comment">--disable-content-trust   Skip image verification (default true)</span></span><br><span class="line">  -q, <span class="comment">--quiet                   Suppress verbose output</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>docker pull</code>命令我们之前也使用过，可以用来拉镜像，相当于命令<code>docker image pull</code>。根据官方帮助信息，我们可以知道，<code>docker pull</code> 如果要拉去指定版本，需要加<code>:tag</code>版本标签，加<code>-a</code>选项可以拉取所有镜像，不过生产中一般都是用的时候公司内部的本地镜像仓库Harbor，所以拉取镜像时,格式要跟公司Harbor服务器的IP或者域名，指定拉取镜像的源仓库，如果不加，则默认从docker官网拉取。镜像名称格式为：<code>Harbor IP/项目名/image 名字:版本号</code><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="number">172.18</span><span class="number">.32</span><span class="number">.101</span>/centos/centos-base:v1</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>docker push</code>是用来推送本地镜像至仓库的,相当于命令<code>docker image push</code>，用法格式与pull相似。<br>使用pull推送至公司Harbor时，需要先在docker启动文件<code>/lib/systemd/system/docker.service</code>的<code>ExecStart选项</code>结尾加入参数<code>--insecure-registry</code>，表示加入不安全的镜像仓库，可加多个，示例如下。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=<span class="string">/usr/bin/dockerd</span> -H fd:<span class="string">//</span> <span class="params">--containerd=/run/containerd/containerd</span>.sock <span class="params">--insecure-registry</span> 192.168.32.19 <span class="params">--insecure-registry</span> 192.168.32.20</span><br></pre></td></tr></table></figure></p><h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu:~<span class="comment"># docker tag --help</span></span><br><span class="line"></span><br><span class="line">Usage:docker <span class="keyword">tag</span> <span class="title">SOURCE_IMAGE</span>[:<span class="keyword">TAG</span>] TARGET_IMAGE[:<span class="keyword">TAG</span>]</span><br><span class="line"></span><br><span class="line">Create a <span class="keyword">tag</span> <span class="title">TARGET_IMAGE</span> that refers to SOURCE_IMAGE</span><br><span class="line">root@DockerUbuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>docker tag</code>命令可以用来打标记，格式如上。一般为了区分不同版本，我们会在每次制作完镜像后打上不同的标记，而且要分发到不同的镜像仓库时也要重新打一个对应<code>仓库IP/项目名</code>的镜像，才可以<code>push</code>或<code>pull</code>。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>&emsp;&emsp;<code>docker run</code>可以算是最常用的docker基础命令了，意思是创建并运行容器，相当于<code>docker create</code>和<code>docker start</code>的组合。用法格式如下。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="string">[ OPTION ]</span> 镜像ID <span class="string">[ CMD ]</span></span><br></pre></td></tr></table></figure></p><h4 id="OPTION"><a href="#OPTION" class="headerlink" title="OPTION"></a>OPTION</h4><p>&emsp;&emsp;常用选项有<code>-i</code>、<code>-t</code>、<code>-d</code>、<code>-p</code>、<code>-v</code>、<code>-e</code>、<code>--name</code>、<code>--net</code>。</p><ul><li><code>-i</code>，–interactive， Keep STDIN open even if not attached<br>&emsp;&emsp;以交互式方式运行。不过只加-t是没法实现交互式的，通常需要<code>-t</code>参数配合，来给容器加一个<code>伪终端</code>实现交互式。</li><li><code>-t</code>，–tty， Allocate a pseudo-TTY<br>&emsp;&emsp;给容器分配一个伪终端，与<code>-i</code>配合使用，通常写作<code>-it</code>。</li><li><code>-d</code>，–detach，  Run container in background and print container ID<br>&emsp;&emsp;使容器启动时后台运行，如果不加这个选项，则会占据宿主机当前终端，服务类容器等交互式容器一般都会加上这个选项。</li><li><code>-p</code>，–publish， list Publish a container’s port(s) to the host<br>&emsp;&emsp;映射本地端口到容器的指定端口，同时映射多个端口，则写多个<code>-p 宿主机端口:容器端口</code>选项。</li><li><code>-v</code>，–volume， list Bind mount a volume<br>&emsp;&emsp;使用-v 参数， 将宿主机目录映射到容器内部， 默认是可读写的。<code>-v SOUCE:DEST:ro</code>后面加<code>ro</code>则可实现只读。</li><li><code>-e</code>，–env， list Set environment variables<br>&emsp;&emsp;可用<code>-e</code>选项为容器添加启动时的环境变量。虽然大多环境变量都是在制作容器时就写进容器里，不过此选项应用在环境变量经常变化的场景，方面修改。</li><li><code>--name</code>，Assign a name to the container<br>&emsp;&emsp;给创建的容器命名。同一个宿主机上的容器之间可以通过自定义的容器名称相互访问，由于容器在启动的时候其内部 IP 地址是 DHCP 随机分配的，所以如果通过内部访问的话，自定义名称是相对比较固定的，因此设置容器别名比较适用于此场景。</li><li>–link，Add link to another container<br>&emsp;&emsp;为容器设置一个别名，相当于一个路径名。自定义的容器名称可能后期会发生变化， 那么一旦名称发生变化，程序之间也要随之发生变化，比如程序通过容器名称进行服务调用， 但是容器名称发生变化之后再使用之前的名称肯定是无法成功调用， 每次都进行更改的话又比较麻烦， 因此可以使用自定义别名的方式解决，即容器名称可以随意更，只要不更改别名即可。</li><li><code>--net</code><br>&emsp;&emsp;为容器指定网络。容器网络类型，常见的为bridge、host、null，也可以自己创建自定义网络。可用<code>docker network list</code>查看当前已有的网络。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu:~# docker<span class="built_in"> network </span>list</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">1eb441f702d2       <span class="built_in"> bridge </span>            <span class="built_in"> bridge </span>             local</span><br><span class="line">241d3e94a6b3        host                host                local</span><br><span class="line">7cc9cf9eb69e        none                <span class="literal">null</span>                local</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;docker服务安装完成后，默认在每个宿主机会生成一个名称为 docker0 的网卡其 IP 地址都是 172.17.0.1/16，并且会生成三种不同类型的网络，也就是bridge、host和null，分别代表网桥（桥接）、宿主机网络和无网络访问。<br>&emsp;&emsp;如果不加<code>--net</code>选项则默认使用bridge，相当于桥接在宿主机的<code>docker0</code>网卡上。<br>&emsp;&emsp;<code>host</code>网络就是指容器使用宿主机网络，所以端口就不能重复使用，多个使用host网络的容器间端口也不能重复。<br>&emsp;&emsp;<code>null</code>网络指容器只有回环网卡，没有外部网卡，无法与外部交流交流，不常使用，适用于某些不需要与外界通信的数据计算或图形、数据处理服务。<br>&emsp;&emsp;还有一种比较特的类型就是<code>container</code>模式，就是指定与一个已有容器共享网络，格式为<code>--net=container:指定名称或 ID</code> 。使用此模式创建的容器需指定和一个已经存在的容器共享一个网络，而不是和宿主机共享网，新创建的容器不会创建自己的网卡也不会配置自己的 IP，而是和一个已经存在的被指定的容器东西 IP 和端口范围，因此这个容器的端口不能和被指定的端口冲突， 除了网络之外的文件系统、进程信息等仍然保持相互隔离，两个容器的进程可以通过 lo 网卡及容器 IP 进行通信。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>&emsp;&emsp;<code>docker run</code>后面跟的CMD表示指定启动容器的命令，如果不指定，则为容器默认命令。可用 命令<code>docker inspect 容器ID</code>查看容器详细参数查看容器创建时的的CMD。<br>&emsp;&emsp;因为容器中没有守护进程systemd，所以进程编号PID=1的根进程，就是我们启动容器时指定的CMD命令或创建容器设定的默认CMD。如果这个PID=1的守护进程结束，则整个容器就将被关闭。所以我们一般会指定一个可以占据前台终端的服务来作为守护进程，例如<code>bash</code>或者<code>tail -f /etc/hosts</code>命令，对于后台nginx等服务来说，想让他们作为守护进程启动容器，<code>需要将在后台执行的这个选项关闭</code>，如nginx可以通过<code>docker run -it -d nginx:alpine nginx -g &quot;daemon off;&quot;</code>命令，加上<code>-g &quot;daemon off&quot;</code>选项传递参数或者在配置文件中设置<code>daemon off</code>来关闭后台执行选项，否则容器启动就会因为没有前台进程而终止。为了方便我们修改配置或者重启服务，企业生产中我们都采用<code>tail -f /etc/hosts</code>来作为前台进程，这样我们重启服务容器就不受影响了。</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@DockerUbuntu:~# docker ps <span class="comment">--help</span></span><br><span class="line"></span><br><span class="line">Usage:docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line">List containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, <span class="comment">--all             Show all containers (default shows just running)</span></span><br><span class="line">  -f, <span class="comment">--filter filter   Filter output based on conditions provided</span></span><br><span class="line">      <span class="comment">--format string   Pretty-print containers using a Go template</span></span><br><span class="line">  -n, <span class="comment">--last int        Show n last created containers (includes all states) (default -1)</span></span><br><span class="line">  -l, <span class="comment">--latest          Show the latest created container (includes all states)</span></span><br><span class="line">      <span class="comment">--no-trunc        Don't truncate output</span></span><br><span class="line">  -q, <span class="comment">--quiet           Only display numeric IDs</span></span><br><span class="line">  -s, <span class="comment">--size            Display total file sizes</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>docker ps</code>命令比较简单，较长使用的参数是<code>-a</code>、<code>-q</code>，分别是显示所有容器（包括为未运行容器，ps默认只显示正在运行的容器）和只显示容器ID。也可以使用<code>docker ps -aq</code>来显示所有容器的ID，可配合其他命令如<code>docker rm</code>命令使用。<code>docker rm -f `docker ps -aq`</code>删除本地所有容器（很危险，小心操作！）。</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>&emsp;&emsp;<code>docker rm</code>命令是用来删除容器的，如果容器正在运行，使用<code>docker rm</code>命令删除时会报错提示<code>Error response from daemon: You cannot remove a running container XXX. Stop the container before attempting removal or force remove</code>，告诉我们无法删除运行中的容器，需要先将容器停止或者强制删除，使用<code>docker rm -f</code>命令强制删除，或者使用下面的停止命令</p><h3 id="start-stop"><a href="#start-stop" class="headerlink" title="start stop"></a>start stop</h3><p>&emsp;&emsp;<code>docker start 容器ID</code>启动容器，可以加选项<code>-i</code>，表示启动容器并输出容器内的标准输出至宿主机终端。需要注意的是，如果当时用<code>docker run</code>或者<code>docker create</code>命令创建容器时，没有加<code>-it</code>或<code>-d</code>等一些其它选项或者参数的话，在start容器这一步也没法作出更改了的。容器怎么创建的，启动时就会按照创建时设定好的模式运行，这些是没办法再次修改了的，包括启动CMD。<br>&emsp;&emsp;<code>docker stop 容器ID</code>终止容器。需要注意：终止容器时，容器内的数据都将丢失，在备份重要数据之前不要终止容器。</p><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>&emsp;&emsp;<code>docker images</code>命令其实相当于<code>docker image ls</code>,显示本地所有镜像。<code>docker image CMD</code>还有很多，之后介绍镜像管理的时候 在详细介绍。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>&emsp;&emsp;<code>docker exec</code>命令可以向一个已运行容器发送命令。用法如下所示。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@DockerCentOS ~]<span class="comment"># docker exec --help</span></span><br><span class="line"></span><br><span class="line">Usage:docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command <span class="keyword">in</span> a <span class="built_in">running</span> container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, <span class="comment">--detach               Detached mode: run command in the background</span></span><br><span class="line">      <span class="comment">--detach-keys string   Override the key sequence for detaching a container</span></span><br><span class="line">  -e, <span class="comment">--env list             Set environment variables</span></span><br><span class="line">  -i, <span class="comment">--interactive          Keep STDIN open even if not attached</span></span><br><span class="line">      <span class="comment">--privileged           Give extended privileges to the command</span></span><br><span class="line">  -t, <span class="comment">--tty                  Allocate a pseudo-TTY</span></span><br><span class="line">  -u, <span class="comment">--user string          Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span></span><br><span class="line">  -w, <span class="comment">--workdir string       Working directory inside the container</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;最常使用的格式是<code>docker exec -it 容器ID bash/sh</code>，可以进入正在运行的容器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;安装完Docker的服务，我们就可以开始使用Docker了。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="Docker" scheme="https://wudihechao.github.io/tags/Docker/"/>
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="容器" scheme="https://wudihechao.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker（一）——基础概念及部署</title>
    <link href="https://wudihechao.github.io//blog/eaa1ac6e.html"/>
    <id>https://wudihechao.github.io//blog/eaa1ac6e.html</id>
    <published>2019-12-04T01:58:21.000Z</published>
    <updated>2019-12-04T02:06:06.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;在企业生产应用中，docker容器技术及k8s的编排管理工具的使用率越来越高，这项技术甚至已经改变了很多企业的架构与框架流程，因为容器技术的出现，可以将应用以集装箱的方式打包交付，使应用在不同的团队中共享，通过镜像的方式应用可以部署于任何环境中。这样避免了各团队之间的协作问题的出现，成为企业实现DevOps目标的重要工具，而且以容器方式交付的Docker技术支持不断地开发迭代，提升了产品开发和交付速度，极大的方便了业务的横向扩容。<br>&emsp;&emsp;且与KVM虚拟化技术不同的是，Docker直接移植于Linux内核之上，通过运行Linux进程将底层设备虚拟隔离，这样系统性能的损耗也要比虚拟机低的多，几乎可以忽略。同时，Docker应用容器的启停非常高效，可以支持大规模的分布系统的水平扩展，真正给企业开发带来福音。<br><a id="more"></a></p><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><p>&emsp;&emsp;首先 Docker 是一个在 2013 年开源的应用程序并且是一个基于 go 语言编写是一个开源的 PAAS 服务(Platform as a Service， 平台即服务的缩写)， go 语言是由google 开发， docker 公司最早叫 dotCloud 后由于 Docker 开源后大受欢迎就将公司改名为 Docker Inc， 总部位于美国加州的旧金山， Docker 是基于 linux 内核实现， Docker 最早采用 LXC 技术(LinuX Container 的简写， LXC 是 Linux 原生支持的容器技术， 可以提供轻量级的虚拟化， 可以说 docker 就是基于 LXC 发展起来的，提供 LXC 的高级封装，发展标准的配置方法)， 而虚拟化技术 KVM(Kernelbased Virtual Machine) 基于模块实现， Docker 后改为自己研发并开源的 runc 技术运行容器。</p><h3 id="Dokcer与虚拟机技术对比"><a href="#Dokcer与虚拟机技术对比" class="headerlink" title="Dokcer与虚拟机技术对比"></a>Dokcer与虚拟机技术对比</h3><p>&emsp;&emsp;Docker 相比虚拟机的交付速度更快， 资源消耗更低， Docker 采用客户端/服务端架构，使用远程 API 来管理和创建 Docker 容器，其可以轻松的创建一个轻量级的、 可移植的、自给自足的容器， docker 的三大理念是 build(构建)、ship(运输)、 run(运行)， Docker 遵从 apache 2.0 协议，并通过（namespace 及cgroup 等）来提供容器的资源隔离与安全保障等，所以 Docke 容器在运行时不需要类似虚拟机（空运行的虚拟机占用物理机 6-8%性能）的额外资源开销，因此可以大幅提高资源利用率,总而言之 Docker 是一种用了新颖方式实现的轻量级虚拟机.类似于 VM 但是在原理和应用上和 VM 的差别还是很大的，并且 docker的专业叫法是应用容器(Application Container)。<br>| 优势 | Docker | 虚拟机 |<br>|–|–|–|<br>| 资源利用率更高 |  一台物理机可以运行数百个容器 | 但是一般只能运行数十个虚拟机 |<br>| 开销更小 |  不需要启动单独的虚拟机占用硬件资源 |  需要启动单独的虚拟机占用硬件资源 |<br>| 启动速度更快 | 可以在数秒内完成启动 | 需要几十秒甚至数分钟 |</p><p>&emsp;&emsp;使用虚拟机是为了更好的实现服务运行环境隔离， 每个虚拟机都有独立的内核，虚拟化可以实现不同操作系统的虚拟机，但是通常一个虚拟机只运行一个服务， 很明显资源利用率比较低且造成不必要的性能损耗， 我们创建虚拟机的目的是为了运行应用程序，比如 Nginx、 PHP、 Tomcat 等 web 程序， 使用虚拟机无疑带来了一些不必要的资源开销，但是容器技术则基于减少中间运行环节带来较大的性能提升。</p><h3 id="Docker-的组成"><a href="#Docker-的组成" class="headerlink" title="Docker 的组成"></a>Docker 的组成</h3><ul><li>Docker 主机(Host)： 一个物理机或虚拟机，用于运行 Docker 服务进程和容器。</li><li>Docker 服务端(Server)： Docker 守护进程， 运行 docker 容器。</li><li>Docker 客户端(Client)： 客户端使用 docker 命令或其他工具调用 docker API。</li><li>Docker 仓库(Registry): 保存镜像的仓库，类似于 git 或 svn 这样的版本控制系统，官方仓库: <a href="https://hub.docker.com/" rel="noopener" target="_blank">https://hub.docker.com/</a></li><li>Docker 镜像(Images)： 镜像可以理解为创建实例使用的模板。</li><li>Docker 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务。</li></ul><p>详细介绍参见官方文档<a href="https://docs.docker.com/engine/docker-overview/" rel="noopener" target="_blank">https://docs.docker.com/engine/docker-overview/</a></p><h2 id="Docker实现需要解决的问题"><a href="#Docker实现需要解决的问题" class="headerlink" title="Docker实现需要解决的问题"></a>Docker实现需要解决的问题</h2><p>&emsp;&emsp;容器技术确实有很多优点，不过当使用多个容器时带来的以下问题怎么解决:<br>&emsp;&emsp;1.怎么样保证每个容器都有不同的文件系统并且能互不影响？<br>&emsp;&emsp;2.一个 docker 主进程内的各个容器都是其子进程，那么实现同一个主进程下不同类型的子进程？ 各个进程间通信能相互访问(内存数据)吗？<br>&emsp;&emsp;3.每个容器怎么解决 IP 及端口分配的问题？<br>&emsp;&emsp;4.多个容器的主机名能一样吗？<br>&emsp;&emsp;5.每个容器都要不要有 root 用户？怎么解决账户重名问题？<br>&emsp;&emsp;这就不得不引入一个Namespace的概念了。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>&emsp;&emsp;namespace 是 Linux 系统的底层概念， 在内核层实现，即有一些不同类型的命名空间被部署在核内， 各个 docker 容器运行在同一个 docker 主进程并且共用同一个宿主机系统内核，各 docker 容器运行在宿主机的用户空间， 每个容器都要有类似于虚拟机一样的相互隔离的运行空间， 但是容器技术是在一个进程内实现运行指定服务的运行环境， 并且还可以保护宿主机内核不受其他进程的干扰和影响， 如文件系统空间、网络空间、进程空间等。<br>| 隔离类型 | 实现功能 | 系统调用参数 | 内核版本 |<br>|–|–|–|–|<br>| MNT Namespace(mount) | 提供磁盘挂载点和文件系统的隔离能力 | CLONE_NEWNS | Linux 2.4.19 |<br>| IPC Namespace(Inter-Process Communication) |  提供进程间通信的隔离能力 | CLONE_NEWIPC | Linux 2.6.19 |<br>| UTS Namespace(UNIX Timesharing System) | 提供主机名隔离能力 | CLONE_NEWUTS | Linux 2.6.19 |<br>| PID Namespace(Process Identification) | 提供进程隔离能力 | CLONE_NEWPID | Linux 2.6.24 |<br>| Net Namespace(network) | 提供网络隔离能力 | CLONE_NEWNET | Linux 2.6.29 |<br>| User Namespace(user) | 提供用户隔离能力 | CLONE_NEWUSER | Linux 3.8 |</p><ul><li>MNT Namespace：每个容器都要有独立的根文件系统有独立的用户空间， 以实现在容器里面启动服务并且使用容器的运行环境，容器里面是不能访问宿主机的资源， 宿主机是使用了 chroot 技术把容器锁定到一个指定的运行目录里面。</li><li>IPC Namespace：一个容器内的进程间通信， 允许一个容器内的不同进程的(内存、 缓存等)数据访问，但是不能跨容器访问其他容器的数据。</li><li>UTS Namespace：UTS namespace（UNIX Timesharing System 包含了运行内核的名称、版本、底层体系结构类型等信息）用于系统标识， 其中包含了 hostname 和域名domainname ， 它使得一个容器拥有属于自己 hostname 标识，这个主机名标识独立于宿主机系统和其上的其他容器。</li><li>PID Namespace：Linux 系统中，有一个 PID 为 1 的进程(init/systemd)是其他所有进程的父进程， 那么在每个容器内也要有一个父进程来管理其下属的子进程，那么多个容器的进程通 PID namespace 进程隔离(比如 PID 编号重复、 器内的主进程生成与回收子进程等)。</li><li>Net Namespace：每一个容器都类似于虚拟机一样有自己的网卡、 监听端口、 TCP/IP 协议栈等，Docker 使用 network namespace 启动一个 vethX 接口，这样你的容器将拥有它自己的桥接 ip 地址，通常是 docker0，而 docker0 实质就是 Linux 的虚拟网桥,网桥是在 OSI 七层模型的数据链路层的网络设备，通过 mac 地址对网络进行划分，并且在不同网络直接传递数据。</li><li>User Namespace：User Namespace 允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户 UID 和 GID， 只是会把用户的作用范围限制在每个容器内，即 A 容器和 B 容器可以有相同的用户名称和 ID 的账户，但是此用户的有效范围仅是当前容器内， 不能访问另外一个容器内的文件系统，即相互隔离、互补影响、 永不相见。</li></ul><p>&emsp;&emsp;通过这些内核级功能的实现，docker才可以正常工作，实现不同容器间的各种资源的隔离，形成共享同一组硬件及内核上却互不影响的独立应用级虚拟化系统。不过此时，我们还面临一个问题，就是资源使用率的控制。如果一个容器因为BUG或代码本身等原因导致无限制的使用宿主机上的资源，将会导致宿主机CPU或者内存不足进而极有可能影响到其他容器的正常运行。所以我们需要对每个容器的资源利用做一个限制，我们通过内核中的Linux Cgroups功能来限制每个容器能使用的资源的上限。</p><h3 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h3><p>&emsp;&emsp;Linux Cgroups 的全称是 Linux Control Groups， 它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。此外，还能够对进程进行优先级设置，以及将进程挂起和恢复等操作。<br>&emsp;&emsp;Cgroups 在内核层默认已经开启，可通过下列命令验证查看Cgroups设置<br>&emsp;&emsp;CentOS7.6:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[root@localhost ~]</span><span class="comment"># cat /boot/config-3.10.0-957.el7.x86_64 |grep CGROUP</span></span><br><span class="line"><span class="attr">CONFIG_CGROUPS</span>=y</span><br><span class="line"><span class="comment"># CONFIG_CGROUP_DEBUG is not set</span></span><br><span class="line"><span class="attr">CONFIG_CGROUP_FREEZER</span>=y</span><br><span class="line"><span class="attr">CONFIG_CGROUP_PIDS</span>=y</span><br><span class="line"><span class="attr">CONFIG_CGROUP_DEVICE</span>=y</span><br><span class="line"><span class="attr">CONFIG_CGROUP_CPUACCT</span>=y</span><br><span class="line"><span class="attr">CONFIG_CGROUP_HUGETLB</span>=y</span><br><span class="line"><span class="attr">CONFIG_CGROUP_PERF</span>=y</span><br><span class="line"><span class="attr">CONFIG_CGROUP_SCHED</span>=y</span><br><span class="line"><span class="attr">CONFIG_BLK_CGROUP</span>=y</span><br><span class="line"><span class="comment"># CONFIG_DEBUG_BLK_CGROUP is not set</span></span><br><span class="line"><span class="attr">CONFIG_NETFILTER_XT_MATCH_CGROUP</span>=m</span><br><span class="line"><span class="attr">CONFIG_NET_CLS_CGROUP</span>=y</span><br><span class="line"><span class="attr">CONFIG_NETPRIO_CGROUP</span>=y</span><br><span class="line"><span class="section">[root@localhost ~]</span><span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;ubuntu1804中:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">root@DockerUbuntu:~# cat /boot/config-4.15.0-70-generic |grep CGROUP</span></span><br><span class="line">CONFIG_CGROUPS=y</span><br><span class="line">CONFIG_BLK_CGROUP=y</span><br><span class="line"><span class="comment"># CONFIG_DEBUG_BLK_CGROUP is not set</span></span><br><span class="line">CONFIG_CGROUP_WRITEBACK=y</span><br><span class="line">CONFIG_CGROUP_SCHED=y</span><br><span class="line">CONFIG_CGROUP_PIDS=y</span><br><span class="line">CONFIG_CGROUP_RDMA=y</span><br><span class="line">CONFIG_CGROUP_FREEZER=y</span><br><span class="line">CONFIG_CGROUP_HUGETLB=y</span><br><span class="line">CONFIG_CGROUP_DEVICE=y</span><br><span class="line">CONFIG_CGROUP_CPUACCT=y</span><br><span class="line">CONFIG_CGROUP_PERF=y</span><br><span class="line">CONFIG_CGROUP_BPF=y</span><br><span class="line"><span class="comment"># CONFIG_CGROUP_DEBUG is not set</span></span><br><span class="line">CONFIG_SOCK_CGROUP_DATA=y</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_CGROUP=m</span><br><span class="line">CONFIG_NET_CLS_CGROUP=m</span><br><span class="line">CONFIG_CGROUP_NET_PRIO=y</span><br><span class="line">CONFIG_CGROUP_NET_CLASSID=y</span><br><span class="line"><span class="section">root@DockerUbuntu:~#</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到内核较新的 ubuntu 支持的功能更多。</p><h4 id="cgroups-参数具体解释："><a href="#cgroups-参数具体解释：" class="headerlink" title="cgroups 参数具体解释："></a>cgroups 参数具体解释：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">blkio：块设备 IO 限制。</span><br><span class="line">cpu：使用调度程序为 cgroup 任务提供 cpu 的访问。</span><br><span class="line">cpuacct：产生 cgroup 任务的 cpu 资源报告。</span><br><span class="line">cpuset：如果是多核心的 cpu，这个子系统会为 cgroup 任务分配单独的 cpu</span><br><span class="line">和内存。</span><br><span class="line">devices：允许或拒绝 cgroup 任务对设备的访问。</span><br><span class="line">freezer：暂停和恢复 cgroup 任务。</span><br><span class="line">memory：设置每个 cgroup 的内存限制以及产生内存资源报告。</span><br><span class="line">net_cls：标记每个网络包以供 cgroup 方便使用。</span><br><span class="line">ns：命名空间子系统。</span><br><span class="line">perf_event：增加了对每<span class="built_in"> group </span>的监测跟踪的能力，可以监测属于某个特定的</span><br><span class="line">group 的所有线程以及运行在特定 CPU 上的线程。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以通过命令<code>ll /sys/fs/cgroup/</code>查看系统Cgroups</p><h2 id="Docker依赖的技术"><a href="#Docker依赖的技术" class="headerlink" title="Docker依赖的技术"></a>Docker依赖的技术</h2><p>&emsp;&emsp;Docker容器技术如果真正想在企业中应用，还必须依赖下面的一些技术，会在之后的文章中详细介绍。</p><h3 id="容器网络："><a href="#容器网络：" class="headerlink" title="容器网络："></a>容器网络：</h3><p>&emsp;&emsp;docker 自带的网络 docker network 仅支持管理单机上的容器网络， 当多主机运行的时候需要使用第三方开源网络，例如 calico、 flannel 等。</p><h3 id="服务发现："><a href="#服务发现：" class="headerlink" title="服务发现："></a>服务发现：</h3><p>&emsp;&emsp;容器的动态扩容特性决定了容器 IP 也会随之变化， 因此需要有一种机制可以自动识别并将用户请求动态转发到新创建的容器上， kubernetes 自带服务发现功能，需要结合 kube-dns 服务解析内部域名。</p><h3 id="容器监控："><a href="#容器监控：" class="headerlink" title="容器监控："></a>容器监控：</h3><p>&emsp;&emsp;可以通过原生命令 docker ps/top/stats 查看容器运行状态，另外也可以使<br>heapster/ Prometheus 等第三方监控工具监控容器的运行状态。</p><h3 id="数据管理："><a href="#数据管理：" class="headerlink" title="数据管理："></a>数据管理：</h3><p>&emsp;&emsp;容器的动态迁移会导致其在不同的 Host 之间迁移，因此如何保证与容器相关的数据也能随之迁移或随时访问，可以使用逻辑卷/存储挂载等方式解决。</p><h3 id="日志收集："><a href="#日志收集：" class="headerlink" title="日志收集："></a>日志收集：</h3><p>&emsp;&emsp;docker 原生的日志查看工具 docker logs， 但是容器内部的日志需要通过 ELK 等专门的日志收集分析和展示工具进行处理。</p><h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><p>&emsp;&emsp;我们初步知道了Docker的概念和实现原理，也知道了Docker在使用中可能会遇到的问题，说了这么多，现在我们先将Docker部署一下。<br>&emsp;&emsp;Docker常见的安装方式有三种，可以通过rpm包下载，或者二进制安装，也可以通过epel源安装。<br>&emsp;&emsp;官方 rpm 包下载地址:<br>&emsp;&emsp;<a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" rel="noopener" target="_blank">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a><br>&emsp;&emsp;二进制下载地址：<br>&emsp;&emsp;<a href="https://download.docker.com/" rel="noopener" target="_blank">https://download.docker.com/</a><br><a href="https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/" rel="noopener" target="_blank">https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/</a><br>&emsp;&emsp;阿里镜像下载地址：<br>&emsp;&emsp;<a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/" rel="noopener" target="_blank">https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/</a><br>&emsp;&emsp;Ubuntu的安装docker-ce阿里云镜像仓库方式如下（使用 apt-get 进行安装）:<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="meta"># step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL https:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class="line"><span class="meta"># Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span></span><br><span class="line"><span class="meta"># Step 4: 更新并安装Docker-CE</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> -y update</span><br><span class="line">sudo apt-<span class="keyword">get</span> -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="meta"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="meta"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line"><span class="meta"># apt-cache madison docker-ce</span></span><br><span class="line"><span class="meta">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="meta">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="meta"># Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span></span><br><span class="line"><span class="meta"># sudo apt-get -y install docker-ce=[VERSION]</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>注意</strong>：在与 kubernetes 结合使用的时候，要安装经过 kubernetes 官方测试通过的 docker版本， 避免出现不兼容等未知的及不可预估的问题发生， kubernetes 测试过的docker 版本可以在 github 查询， 具体如下：<br><a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md#external-dependencies" rel="noopener" target="_blank">https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md#external-dependencies</a><br>&emsp;&emsp;安装完成后就可以用<code>systemctl start docker</code>命令启动Docker了。<br>&emsp;&emsp;然后用<code>docker info</code>命令来验证当前容器信息<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> <span class="literal">info</span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Containers:</span> <span class="number">0</span> <span class="comment">#当前主机运行的容器总数</span></span><br><span class="line"><span class="attr">Running:</span> <span class="number">0</span> <span class="comment">#有几个容器是正在运行的</span></span><br><span class="line"><span class="attr">Paused:</span> <span class="number">0</span> <span class="comment">#有几个容器是暂停的</span></span><br><span class="line"><span class="attr">Stopped:</span> <span class="number">0</span> <span class="comment">#有几个容器是停止的</span></span><br><span class="line"><span class="attr">Images:</span> <span class="number">0</span> <span class="comment">#当前服务器的镜像数</span></span><br><span class="line"><span class="string">Server</span> <span class="attr">Version:</span> <span class="number">18.09</span><span class="number">.9</span> <span class="comment">#服务端版本</span></span><br><span class="line"><span class="string">Storage</span> <span class="attr">Driver:</span> <span class="string">overlay2</span> <span class="comment">#正在使用的存储引擎</span></span><br><span class="line"><span class="string">Backing</span> <span class="attr">Filesystem:</span> <span class="string">extfs</span> <span class="comment">#后端文件系统，即服务器的磁盘文件系统</span></span><br><span class="line"><span class="string">Supports</span> <span class="attr">d_type:</span> <span class="literal">true</span> <span class="comment">#是否支持 d_type</span></span><br><span class="line"><span class="string">Native</span> <span class="string">Overlay</span> <span class="attr">Diff:</span> <span class="literal">true</span> <span class="comment">#是否支持差异数据存储</span></span><br><span class="line"><span class="string">Logging</span> <span class="attr">Driver:</span> <span class="string">json-file</span> <span class="comment">#日志类型</span></span><br><span class="line"><span class="string">Cgroup</span> <span class="attr">Driver:</span> <span class="string">cgroupfs</span> <span class="comment">#Cgroups 类型</span></span><br><span class="line"><span class="attr">Plugins:</span> <span class="comment">#插件</span></span><br><span class="line"><span class="attr">Volume:</span> <span class="string">local</span> <span class="comment">#卷</span></span><br><span class="line"><span class="attr">Network:</span> <span class="string">bridge</span> <span class="string">host</span> <span class="string">macvlan</span> <span class="literal">null</span> <span class="string">overlay</span> <span class="comment"># overlay 夸主机通信</span></span><br><span class="line"><span class="attr">Log:</span> <span class="string">awslogs</span> <span class="string">fluentd</span> <span class="string">gcplogs</span> <span class="string">gelf</span> <span class="string">journald</span> <span class="string">json-file</span> <span class="string">local</span> <span class="string">logentries</span> <span class="string">splunk</span> <span class="string">syslog</span> <span class="comment">#日</span></span><br><span class="line"><span class="string">志类型</span></span><br><span class="line"><span class="attr">Swarm:</span> <span class="string">inactive</span> <span class="comment">#是否支持 swarm</span></span><br><span class="line"><span class="attr">Runtimes:</span> <span class="string">runc</span> <span class="comment">#已安装的容器运行时</span></span><br><span class="line"><span class="string">Default</span> <span class="attr">Runtime:</span> <span class="string">runc</span> <span class="comment">#默认使用的容器运行时</span></span><br><span class="line"><span class="string">Init</span> <span class="attr">Binary:</span> <span class="string">docker-init</span> <span class="comment">#初始化容器的守护进程，即 pid 为 1 的进程</span></span><br><span class="line"><span class="string">containerd</span> <span class="attr">version:</span> <span class="number">894</span><span class="string">b81a4b802e4eb2a91d1ce216b8817763c29fb</span> <span class="comment">#版本</span></span><br><span class="line"><span class="string">runc</span> <span class="attr">version:</span> <span class="number">425e105</span><span class="string">d5a03fabd737a126ad93d62a9eeede87f</span> <span class="comment"># runc 版本</span></span><br><span class="line"><span class="string">init</span> <span class="attr">version:</span> <span class="string">fec3683</span> <span class="comment">#init 版本</span></span><br><span class="line"><span class="string">Security</span> <span class="attr">Options:</span> <span class="comment">#安全选项</span></span><br><span class="line"><span class="string">Apparmor</span> <span class="comment">#安全模块， https://docs.docker.com/engine/security/apparmor/</span></span><br><span class="line"><span class="string">seccomp</span> <span class="comment">#审计(操作)， https://docs.docker.com/engine/security/seccomp/</span></span><br><span class="line"><span class="attr">Profile:</span> <span class="string">default</span> <span class="comment">#默认的配置文件</span></span><br><span class="line"><span class="string">Kernel</span> <span class="attr">Version:</span> <span class="number">4.15</span><span class="number">.0</span><span class="bullet">-55</span><span class="bullet">-generic</span> <span class="comment">#宿主机内核版本</span></span><br><span class="line"><span class="string">Operating</span> <span class="attr">System:</span> <span class="string">Ubuntu</span> <span class="number">18.04</span><span class="number">.3</span> <span class="string">LTS</span> <span class="comment">#宿主机操作系统</span></span><br><span class="line"><span class="attr">OSType:</span> <span class="string">linux</span> <span class="comment">#宿主机操作系统类型</span></span><br><span class="line"><span class="attr">Architecture:</span> <span class="string">x86_64</span> <span class="comment">#宿主机架构</span></span><br><span class="line"><span class="attr">CPUs:</span> <span class="number">2</span> <span class="comment">#宿主机 CPU 数量</span></span><br><span class="line"><span class="string">Total</span> <span class="attr">Memory:</span> <span class="number">3.83</span><span class="string">GiB</span> <span class="comment">#宿主机总内存</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">DockerUbuntu</span> <span class="comment">#宿主机 hostname</span></span><br><span class="line"><span class="attr">ID:</span> <span class="attr">ZFPD:UIA5:SR6E:Y6SS:52QL:5MPT:VDY3:ATVI:QMVG:HAFF:MN74:2HPD</span> <span class="comment">#宿主机</span></span><br><span class="line"><span class="string">ID</span></span><br><span class="line"><span class="string">Docker</span> <span class="string">Root</span> <span class="attr">Dir:</span> <span class="string">/var/lib/docker</span> <span class="comment">#宿主机数据保存目录</span></span><br><span class="line"><span class="string">Debug</span> <span class="string">Mode</span> <span class="string">(client):</span> <span class="literal">false</span> <span class="comment">#client 端是否开启 debug</span></span><br><span class="line"><span class="string">Debug</span> <span class="string">Mode</span> <span class="string">(server):</span> <span class="literal">false</span> <span class="comment">#server 端是否开启 debug</span></span><br><span class="line"><span class="attr">Registry:</span> <span class="attr">https://index.docker.io/v1/</span> <span class="comment">#镜像仓库</span></span><br><span class="line"><span class="attr">Labels:</span> <span class="comment">#其他标签</span></span><br><span class="line"><span class="attr">Experimental:</span> <span class="literal">false</span> <span class="comment">#是否测试版</span></span><br><span class="line"><span class="string">Insecure</span> <span class="attr">Registries:</span> <span class="comment">#非安全的镜像仓库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/8</span></span><br><span class="line"><span class="string">Live</span> <span class="string">Restore</span> <span class="attr">Enabled:</span> <span class="literal">false</span> <span class="comment">#是否开启活动重启(重启 docker-daemon 不关闭容器)</span></span><br><span class="line"><span class="string">Product</span> <span class="attr">License:</span> <span class="string">Community</span> <span class="string">Engine</span> <span class="comment">#产品许可信息</span></span><br></pre></td></tr></table></figure><p>在结尾可能会有类似<code>warning警报</code>,<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">WARNING: </span>No swap limit support</span><br></pre></td></tr></table></figure></p><p>这是提示说我们没有开启 swap 资源限制，这就需要我们通过修改内核参数，来限制swap资源的使用。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span><span class="keyword">default</span><span class="regexp">/grub</span></span><br></pre></td></tr></table></figure></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GRUB_CMDLINE_LINUX="net.ifnames=0</span> <span class="attr">biosdevname=0</span> <span class="attr">cgroup_enable=memory</span> <span class="attr">swapaccount=1"</span></span><br></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">update-grub</span></span><br><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重启生效。至此，docker工具部署就完成了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在企业生产应用中，docker容器技术及k8s的编排管理工具的使用率越来越高，这项技术甚至已经改变了很多企业的架构与框架流程，因为容器技术的出现，可以将应用以集装箱的方式打包交付，使应用在不同的团队中共享，通过镜像的方式应用可以部署于任何环境中。这样避免了各团队之间的协作问题的出现，成为企业实现DevOps目标的重要工具，而且以容器方式交付的Docker技术支持不断地开发迭代，提升了产品开发和交付速度，极大的方便了业务的横向扩容。&lt;br&gt;&amp;emsp;&amp;emsp;且与KVM虚拟化技术不同的是，Docker直接移植于Linux内核之上，通过运行Linux进程将底层设备虚拟隔离，这样系统性能的损耗也要比虚拟机低的多，几乎可以忽略。同时，Docker应用容器的启停非常高效，可以支持大规模的分布系统的水平扩展，真正给企业开发带来福音。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="Docker" scheme="https://wudihechao.github.io/tags/Docker/"/>
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="容器" scheme="https://wudihechao.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="虚拟化" scheme="https://wudihechao.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>KVM虚拟化</title>
    <link href="https://wudihechao.github.io//blog/f989902e.html"/>
    <id>https://wudihechao.github.io//blog/f989902e.html</id>
    <published>2019-11-29T14:28:35.000Z</published>
    <updated>2019-12-04T02:03:42.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;KVM 是Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中，KVM目前已成为学术界的主流 VMM (virtual machine monitor，虚拟机监视器，也称为hypervisor)之一。<br><a id="more"></a><br>&emsp;&emsp;可参考红帽官方对kvm的定义：<a href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM" rel="noopener" target="_blank">https://www.redhat.com/zh/topics/virtualization/what-is-KVM</a><br>&emsp;&emsp;KVM的虚拟化需要硬件支持（如Intel VT技术或者AMD V技术)，是基于硬件的完全虚拟化，而Xen早期则是基于软件模拟的半虚拟化，新版本则是支持基于硬件支持的完全虚拟化，但Xen本身有自己的进程调度器，存储管理模块等，所以代码较为庞大，广为流传的商业系统虚拟化软件VMware ESXI系列是Full-Virtualization，（IBM文档：<a href="http://www.ibm.com/developerworks/cn/linux/l-using-kvm/" rel="noopener" target="_blank">http://www.ibm.com/developerworks/cn/linux/l-using-kvm/</a> ）<br>&emsp;&emsp;简单地说，KVM就是基于硬件支持实现，将单台主机，分隔成多个互不干扰的虚拟主机的技术，不受困于底层操作系统，可以为每个主机提供单独的、所需的的运行环境，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191129111043897.png" alt="KVM示意图"><br>&emsp;&emsp;如果每个节点都是用共享存储如NAS，则可实现跨主机的虚拟机快速迁移，这也是我们在生产环境中经常采用的架构。本文将以下面架构，来具体展示KVM在实际生产中的应用。<br><img src="https://img-blog.csdnimg.cn/20191129142617354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="KVMweb负载均衡">&emsp;&emsp;三个主机，其中两个主机node1和node2上运行KVM，另一台是NAS共享存储服务器，通过10.0.0.0/16网段内网连接。在node1上的用KVM构建虚拟机H1和W1分别运行haproxy+keepalived服务和nginx服务，其中H1桥接方式到node1的两块网卡上，W1桥接到内网网卡eth1上。node2节点中也是如此。于是，将Client端请求通过haproxy反向代理只内网的web服务集群中，保证负载均衡和高可用，哪怕一个物理节点服务器down掉也不影响客户服务访问。<br>&emsp;&emsp;NAS服务器的搭建很容易，这里就先不详细介绍了，本文之后主要介绍KVM服务的配置及虚拟机集群的搭建。</p><h2 id="宿主机环境准备："><a href="#宿主机环境准备：" class="headerlink" title="宿主机环境准备："></a>宿主机环境准备：</h2><p>&emsp;&emsp;KVM需要宿主机CPU必须支持虚拟化功能，因此如果是在vmware workstation上使用虚拟机做宿主机，那么必须要在虚拟机配置界面的处理器选项中开启虚拟机化功能（VMware支持嵌套虚拟化，而KVM不支持，大部分云服务器如阿里云就是基于KVM技术二次研发制作的，所以云服务器都不支持从中再建虚拟机）。<br>&emsp;&emsp;KVM模块因为已经被集成到linux内核之中，所以我们只需要安装KVM管理工具就可以直接使用KVM创建虚拟机了。<br>&emsp;&emsp;可用命令验证是否开启虚拟化（也可通过lscpu命令,grep -o选项只看匹配词本身，也可以用egrep代替grep -E）<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep -Eo <span class="string">"vmx|svm"</span> /<span class="keyword">proc</span>/cpuinfo |<span class="title"> wc</span> -l</span><br><span class="line">vmx</span><br><span class="line">vmx</span><br></pre></td></tr></table></figure></p><h3 id="KVM软件包安装"><a href="#KVM软件包安装" class="headerlink" title="KVM软件包安装"></a>KVM软件包安装</h3><p>&emsp;&emsp;在Ubuntu 18.04中：<br>&emsp;&emsp;可参考官网<a href="https://ubuntu.com/server/docs/virtualization-libvirt" rel="noopener" target="_blank">https://ubuntu.com/server/docs/virtualization-libvirt</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apt <span class="keyword">install</span> qemu-kvm virt-manager libvirt-daemon-<span class="keyword">system</span></span><br><span class="line">kvm-ok <span class="comment">#验证是否支持kvm</span></span><br></pre></td></tr></table></figure></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">INFO:</span> <span class="meta-keyword">/dev/</span>kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CentOS 7.X：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> qemu-kvm qemu-kvm-tools libvirt libvirt-<span class="keyword">client</span> virt-manager virt-<span class="keyword">install</span></span><br></pre></td></tr></table></figure></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> libvirtd</span><br><span class="line">systemctl <span class="keyword">enable</span> libvirtd</span><br></pre></td></tr></table></figure><h3 id="网络环境配置"><a href="#网络环境配置" class="headerlink" title="网络环境配置"></a>网络环境配置</h3><p>&emsp;&emsp;为了让三个节点间虚拟机可以直接相互之间通信，需要将KVM上的虚拟机以桥接模式与宿主机的网卡连接，这就需要我们提前在宿主机上配置好网桥。<br>&emsp;&emsp;<strong>若宿主机为Ubuntu18.04：</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/netplan/<span class="number">01</span>-netcfg.yaml</span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="comment"># For more information, see netplan(5).</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line"><span class="attr">  version:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  renderer:</span> <span class="string">networkd</span></span><br><span class="line"><span class="attr">  ethernets:</span></span><br><span class="line"><span class="attr">    eth0:</span></span><br><span class="line"><span class="attr">      dhcp4:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">      dhcp6:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    eth1:</span></span><br><span class="line"><span class="attr">      dhcp4:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">      dhcp6:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">  bridges:</span></span><br><span class="line"><span class="attr">    br0:</span></span><br><span class="line"><span class="attr">      dhcp4:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">      dhcp6:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">      addresses:</span> <span class="string">[172.18.0.75/16]</span></span><br><span class="line"><span class="attr">      gateway4:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">      nameservers:</span></span><br><span class="line"><span class="attr">        addresses:</span> <span class="string">[180.76.76.76]</span></span><br><span class="line"><span class="attr">      interfaces:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">eth0</span></span><br><span class="line"><span class="attr">    br1:</span></span><br><span class="line"><span class="attr">      dhcp4:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">      dhcp6:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">      addresses:</span> <span class="string">[10.0.0.75/16]</span></span><br><span class="line"><span class="attr">      interfaces:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">eth1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改网卡配置后，使用<code>netplan apply</code>命令使配置文件的修改生效<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netplan <span class="built_in">apply</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>若宿主机为CentOS：</strong><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/</span></span><br></pre></td></tr></table></figure></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim</span> ifcfg-eh0</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TYPE</span>=Ethernet</span><br><span class="line"><span class="attr">BOOTPROTO</span>=static</span><br><span class="line"><span class="attr">NAME</span>=eth0</span><br><span class="line"><span class="attr">DEVICE</span>=eth0</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">BRIDGE</span>=br0</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim</span> ifcfg-eh1</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TYPE</span>=Ethernet</span><br><span class="line"><span class="attr">BOOTPROTO</span>=static</span><br><span class="line"><span class="attr">NAME</span>=eth1</span><br><span class="line"><span class="attr">DEVICE</span>=eth1</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">BRIDGE</span>=br1</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ifcfg-<span class="keyword">br</span><span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TYPE</span>=Bridge</span><br><span class="line"><span class="attr">BOOTPROTO</span>=static</span><br><span class="line"><span class="attr">NAME</span>=br0</span><br><span class="line"><span class="attr">DEVICE</span>=br0</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="number">172.18</span>.<span class="number">32.75</span></span><br><span class="line"><span class="attr">NETMASK</span>=<span class="number">255.255</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">GATEWAY</span>=<span class="number">172.18</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">DNS1</span>=<span class="number">180.76</span>.<span class="number">76.76</span></span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ifcfg-<span class="keyword">br</span><span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TYPE</span>=Bridge</span><br><span class="line"><span class="attr">BOOTPROTO</span>=static</span><br><span class="line"><span class="attr">NAME</span>=br1</span><br><span class="line"><span class="attr">DEVICE</span>=br1</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="number">10.0</span>.<span class="number">0.75</span></span><br><span class="line"><span class="attr">NETMASK</span>=<span class="number">255.255</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重启网络服务，生效配置<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart network</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>ip a</code>命令或<code>ifconfig</code>查看桥接网卡是否生效</p><h2 id="KVM虚拟机创建"><a href="#KVM虚拟机创建" class="headerlink" title="KVM虚拟机创建"></a>KVM虚拟机创建</h2><h3 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># ll /var/lib/libvirt/images/ #默认保存虚拟机磁盘的路径</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用<code>qemu-img create</code>命令可以创建磁盘,如果创建raw格式磁盘文件，则理解占据实际大小，若创建qcow2稀疏格式磁盘，则磁盘文件会随着使用的增大而增大<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f raw /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">CentOS7</span>.<span class="title">raw</span> 10<span class="title">G</span>建磁盘</span></span><br></pre></td></tr></table></figure></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll -h /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">CentOS7</span>.<span class="title">raw</span></span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">10</span>G Nov <span class="number">29</span> <span class="number">16</span>:<span class="number">34</span> /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">centos</span>.<span class="title">raw</span></span></span><br></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">CentOS7</span>.<span class="title">qcow2</span> 10<span class="title">G</span></span></span><br></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll -h /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">CentOS7</span>.<span class="title">qcow2</span></span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">193</span>K Nov <span class="number">29</span> <span class="number">16</span>:<span class="number">36</span> /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">centos</span>.<span class="title">qcow2</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们选用qcow2格式的磁盘，先创建H1虚拟机，<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/<span class="title">H1</span>.<span class="title">qcow2</span> 10<span class="title">G</span></span></span><br></pre></td></tr></table></figure></p><h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p>&emsp;&emsp;先导入ISO光盘镜像文件,可以使用共享存储上的ISO文件，也可本机导入，本机上传的话一般习惯性放到<code>/usr/local/src/</code>目录下<br>&emsp;&emsp;使用<code>virt-install</code>命令创建虚拟机，参数可<code>virt-install --help</code>查看帮助信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-<span class="keyword">install</span> <span class="comment">--help</span></span><br></pre></td></tr></table></figure></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">usage: virt-install <span class="params">--name</span> NAME <span class="params">--ram</span> RAM STORAGE INSTALL [options]</span><br><span class="line">使用指定安装介质新建虚拟机。</span><br><span class="line">optional arguments:</span><br><span class="line">-h, <span class="params">--help</span> show this <span class="keyword">help</span> message and exit</span><br><span class="line"><span class="params">--version</span> show program's <span class="keyword">version</span> number and exit</span><br><span class="line"><span class="params">--connect</span> URI 使用 libvirt URI 连接到 hypervisor</span><br><span class="line">通用选项:</span><br><span class="line">-n NAME, <span class="params">--name</span> NAME 客户端事件名称</span><br><span class="line"><span class="params">--memory</span> MEMORY 配置虚拟机内存分配。例如：</span><br><span class="line"><span class="params">--memory</span> 1024 <span class="params">(in MiB)</span></span><br><span class="line"><span class="params">--memory</span> 512,maxmemory=1024</span><br><span class="line"><span class="params">--vcpus</span> VCPUS 为虚拟机配置的 vcpus 数。例如：</span><br><span class="line"><span class="params">--vcpus</span> 5</span><br><span class="line"><span class="params">--vcpus</span> 5,maxcpus=10,cpuset=1-4,6,8</span><br><span class="line"><span class="params">--vcpus</span> sockets=2,cores=4,threads=2,</span><br><span class="line"><span class="params">--cpu</span> CPU CPU 型号及功能。例如：</span><br><span class="line"><span class="params">--cpu</span> coreduo,+x2apic</span><br><span class="line"><span class="params">--cpu</span> host</span><br><span class="line"><span class="params">--metadata</span> METADATA 配置虚拟机元数据。例如：</span><br><span class="line"><span class="params">--metadata</span> name=foo,title=<span class="string">"My pretty title"</span>,uuid=<span class="string">...</span></span><br><span class="line"><span class="params">--metadata</span> description=<span class="string">"My nice long description"</span></span><br><span class="line">安装方法选项:</span><br><span class="line"><span class="params">--cdrom</span> CDROM 光驱安装介质</span><br><span class="line">-l LOCATION, <span class="params">--location</span> LOCATION</span><br><span class="line">安装源<span class="params">(例如：nfs:host:/path、http://host/path</span></span><br><span class="line"><span class="params">ftp://host/path)</span></span><br><span class="line"><span class="params">--pxe</span> 使用 PXE 协议从网络引导</span><br><span class="line"><span class="params">--import</span> 在磁盘映像中构建虚拟机</span><br><span class="line"><span class="params">--livecd</span> 将光驱介质视为 Live CD</span><br><span class="line">-x EXTRA_ARGS, <span class="params">--extra-args</span> EXTRA_ARGS</span><br><span class="line">附加到使用 <span class="params">--location</span> 引导的内核的参数</span><br><span class="line"><span class="params">--initrd-inject</span> INITRD_INJECT</span><br><span class="line">使用 <span class="params">--location</span> 为 initrd 的 root</span><br><span class="line">添加给定文件</span><br><span class="line"><span class="params">--os-variant</span> DISTRO_VARIANT</span><br><span class="line">在其中安装 OS 变体的虚拟机，比如</span><br><span class="line">'fedora18'、'rhel6'、'winxp' 等等。</span><br><span class="line"><span class="params">--boot</span> BOOT 配置虚拟机引导设置。例如：</span><br><span class="line"><span class="params">--boot</span> hd,cdrom,menu=on</span><br><span class="line"><span class="params">--boot</span> init=<span class="string">/sbin/init</span> <span class="params">(for containers)</span></span><br><span class="line"><span class="params">--idmap</span> IDMAP 为 LXC 容器启用用户名称空间。例如：</span><br><span class="line"><span class="params">--idmap</span> uid_start=0,uid_target=1000,uid_count=10</span><br><span class="line">设备选项:</span><br><span class="line"><span class="params">--disk</span> DISK 使用不同选项指定存储。例如：</span><br><span class="line"><span class="params">--disk</span> size=10 <span class="params">(new 10GiB image in default location)</span></span><br><span class="line"><span class="params">--disk</span> <span class="string">/my/existing/disk</span>,cache=none</span><br><span class="line"><span class="params">--disk</span> device=cdrom,bus=scsi</span><br><span class="line"><span class="params">--disk=</span>?</span><br><span class="line">-w NETWORK, <span class="params">--network</span> NETWORK</span><br><span class="line">配置虚拟机网络接口。例如：</span><br><span class="line"><span class="params">--network</span> bridge=mybr0</span><br><span class="line"><span class="params">--network</span> network=my_libvirt_virtual_net</span><br><span class="line"><span class="params">--network</span> network=mynet,model=virtio,mac=00<span class="function">:11...</span></span><br><span class="line"><span class="params">--network</span> none</span><br><span class="line"><span class="params">--network</span> <span class="keyword">help</span></span><br><span class="line"><span class="params">--graphics</span> GRAPHICS 配置虚拟机显示设置。例如：</span><br><span class="line"><span class="params">--graphics</span> vnc</span><br><span class="line"><span class="params">--graphics</span> spice,port=5901,tlsport=5902</span><br><span class="line"><span class="params">--graphics</span> none</span><br><span class="line"><span class="params">--graphics</span> vnc,password=foobar,port=5910,keymap=ja</span><br><span class="line"><span class="params">--controller</span> CONTROLLER</span><br><span class="line">配置虚拟机控制程序设备。例如：</span><br><span class="line"><span class="params">--controller</span> type=usb,model=ich9-ehci1</span><br><span class="line"><span class="params">--input</span> INPUT 配置虚拟机输入设备。例如：</span><br><span class="line"><span class="params">--input</span> tablet</span><br><span class="line"><span class="params">--input</span> keyboard,bus=usb</span><br><span class="line"><span class="params">--serial</span> SERIAL 配置虚拟机串口设备</span><br><span class="line"><span class="params">--parallel</span> PARALLEL 配置虚拟机并口设备</span><br><span class="line"><span class="params">--channel</span> CHANNEL 配置虚拟机沟通频道</span><br><span class="line"><span class="params">--console</span> CONSOLE 配置虚拟机与主机之间的文本控制台连接</span><br><span class="line"><span class="params">--hostdev</span> HOSTDEV 将物理 USB/PCI/etc</span><br><span class="line">主机设备配置为与虚拟机共享</span><br><span class="line"><span class="params">--filesystem</span> FILESYSTEM</span><br><span class="line">将主机目录传递给虚拟机。例如：</span><br><span class="line"><span class="params">--filesystem</span> <span class="string">/my/source/dir</span>,<span class="string">/dir/in/guest</span></span><br><span class="line"><span class="params">--filesystem</span> template_name,/,type=template</span><br><span class="line"><span class="params">--sound</span> [SOUND] 配置虚拟机声音设备模拟</span><br><span class="line"><span class="params">--watchdog</span> WATCHDOG 配置虚拟机 watchdog 设备</span><br><span class="line"><span class="params">--video</span> VIDEO 配置虚拟机视频硬件。</span><br><span class="line"><span class="params">--smartcard</span> SMARTCARD</span><br><span class="line">配置虚拟机智能卡设备。例如：</span><br><span class="line"><span class="params">--smartcard</span> mode=passthrough</span><br><span class="line"><span class="params">--redirdev</span> REDIRDEV 配置虚拟机重定向设备。例如：</span><br><span class="line"><span class="params">--redirdev</span> usb,type=tcp,server=192.168.1.1<span class="function">:4000</span></span><br><span class="line"><span class="params">--memballoon</span> MEMBALLOON</span><br><span class="line">配置虚拟机 memballoon 设备。例如：</span><br><span class="line"><span class="params">--memballoon</span> model=virtio</span><br><span class="line"><span class="params">--tpm</span> TPM 配置虚拟机 TPM 设备。例如：</span><br><span class="line"><span class="params">--tpm</span> <span class="string">/dev/tpm</span></span><br><span class="line"><span class="params">--rng</span> RNG 配置虚拟机 RNG 设备。例如：</span><br><span class="line"><span class="params">--rng</span> <span class="string">/dev/random</span></span><br><span class="line"><span class="params">--panic</span> PANIC 配置虚拟机 panic 设备。例如：</span><br><span class="line"><span class="params">--panic</span> default</span><br><span class="line">虚拟机配置选项:</span><br><span class="line"><span class="params">--security</span> SECURITY 设定域安全驱动器配置。</span><br><span class="line"><span class="params">--numatune</span> NUMATUNE 为域进程调整 NUMA 策略。</span><br><span class="line"><span class="params">--memtune</span> MEMTUNE 为域进程调整内粗策略。</span><br><span class="line"><span class="params">--blkiotune</span> BLKIOTUNE</span><br><span class="line">为域进程调整 blkio 策略。</span><br><span class="line"><span class="params">--memorybacking</span> MEMORYBACKING</span><br><span class="line">为域进程设置内存后备策略。例如：</span><br><span class="line"><span class="params">--memorybacking</span> hugepages=on</span><br><span class="line"><span class="params">--features</span> FEATURES 设置域 &lt;features&gt; XML。例如：</span><br><span class="line"><span class="params">--features</span> acpi=off</span><br><span class="line"><span class="params">--features</span> apic=on,eoi=on</span><br><span class="line"><span class="params">--clock</span> CLOCK 设置域 &lt;clock&gt; XML。例如：</span><br><span class="line"><span class="params">--clock</span> offset=localtime,rtc_tickpolicy=catchup</span><br><span class="line"><span class="params">--pm</span> PM 配置 VM 电源管理功能</span><br><span class="line"><span class="params">--events</span> EVENTS 配置 VM 生命周期管理策略</span><br><span class="line"><span class="params">--resource</span> RESOURCE 配置 VM 资源分区（cgroups）</span><br><span class="line">虚拟化平台选项:</span><br><span class="line">-v, <span class="params">--hvm</span> 客户端应该是一个全虚拟客户端</span><br><span class="line">-p, <span class="params">--paravirt</span> 这个客户端一个是一个半虚拟客户端</span><br><span class="line"><span class="params">--container</span> 这台虚拟机需要一个容器客户端</span><br><span class="line"><span class="params">--virt-type</span> HV_TYPE 要使用的管理程序名称<span class="params">(kvm、qemu、xen</span></span><br><span class="line"><span class="params">等等)</span></span><br><span class="line"><span class="params">--arch</span> ARCH 模拟的 CPU 构架</span><br><span class="line"><span class="params">--machine</span> MACHINE 要模拟的机器类型</span><br><span class="line">其它选项:</span><br><span class="line"><span class="params">--autostart</span> 引导主机时自动启动域。</span><br><span class="line"><span class="params">--wait</span> WAIT 等待安装完成的分钟数。</span><br><span class="line"><span class="params">--noautoconsole</span> 不要自动尝试连接到客户端控制台</span><br><span class="line"><span class="params">--noreboot</span> 完成安装后不要引导虚拟机。</span><br><span class="line"><span class="params">--print-xml</span> [XMLONLY]</span><br><span class="line">输出所生成域 XML，而不是创建虚拟机。</span><br><span class="line"><span class="params">--dry-run</span> 完成安装步骤，但不要创建设备或者定义</span><br><span class="line">虚拟机。</span><br><span class="line"><span class="params">--check</span> CHECK 启用或禁用验证检查。例如：</span><br><span class="line"><span class="params">--check</span> path_in_use=off</span><br><span class="line"><span class="params">--check</span> all=off</span><br><span class="line">-q, <span class="params">--quiet</span> 禁止无错误输出</span><br><span class="line">-d, <span class="params">--debug</span> 输入故障排除信息</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们使用命令创建虚拟机(网卡配置选择default的话默认是nat模式)<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm \</span><br><span class="line">-<span class="ruby">-name H1 --ram <span class="number">1024</span> --vcpus <span class="number">2</span> \</span></span><br><span class="line"><span class="ruby">--cdrom=<span class="regexp">/usr/local</span><span class="regexp">/src/</span>CentOS-<span class="number">7</span>-x86_64-Minimal-<span class="number">1908</span>.iso \</span></span><br><span class="line"><span class="ruby">--disk=<span class="regexp">/var/lib</span><span class="regexp">/libvirt/images</span><span class="regexp">/H1.qcow2 \</span></span></span><br><span class="line"><span class="ruby">--network network=default \</span></span><br><span class="line"><span class="ruby">--graphics vnc,listen=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--noautoconsole</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;输入<code>virt-manage</code>r可开启xshellmanager的终端窗口如下图<img src="https://img-blog.csdnimg.cn/20191129164736147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="H"><br>&emsp;&emsp;双击图标打开，可以看到已经开始自动从光盘启动安装了，配置完毕，手动安装CentOS7系统。<br>如果输入<code>virt-manage</code>不能启动xmanager的窗口，检查一下项目</p><ul><li>确认已经安装xmanager</li><li>xshell文件—属性—连接—隧道—设置转发x11到xmanager</li><li>ssh服务配置文件是否开启X11Forwarding选项 设置为yes</li></ul><p>&emsp;&emsp;以上都没问题，建议重装xmanager，我就是配置都对，但是输入<code>virt-manage</code>命令没反应，重装了一下xmanager和xshell之后就可以正常使用了。</p><p>&emsp;&emsp;安装好CentOS7系统重启后，在vrit-manager的窗口中点击虚拟机info，给H1虚拟机添加一块网卡，并将两块网卡分别选择为主机的桥接网卡br0和br1，如下图所示<br><img src="https://img-blog.csdnimg.cn/20191129173237598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="H1net"><br>&emsp;&emsp;在虚拟机中配置两个网卡的IP，配置分别如下<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">TYPE=<span class="string">"Ethernet"</span></span><br><span class="line">BOOTPROTO=<span class="string">"static"</span></span><br><span class="line">IPADDR=<span class="string">"172.18.32.85"</span></span><br><span class="line">GATEWAY=<span class="string">"172.18.0.1"</span></span><br><span class="line">DNS1=<span class="string">"180.76.76.76"</span></span><br><span class="line">DEFROUTE=<span class="string">"yes"</span></span><br><span class="line">NAME=<span class="string">"eth0"</span></span><br><span class="line">DEVICE=<span class="string">"eth0"</span></span><br><span class="line">ONBOOT=<span class="string">"yes"</span></span><br></pre></td></tr></table></figure></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth1</span><br><span class="line">TYPE=<span class="string">"Ethernet"</span></span><br><span class="line">BOOTPROTO=<span class="string">"static"</span></span><br><span class="line">IPADDR=<span class="string">"10.0.0.85"</span></span><br><span class="line">DEFROUTE=<span class="string">"no"</span></span><br><span class="line">NAME=<span class="string">"eth1"</span></span><br><span class="line">DEVICE=<span class="string">"eth1"</span></span><br><span class="line">ONBOOT=<span class="string">"yes"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时H1的基本配置就算完成了。<br>&emsp;&emsp;查看<code>/var/lib/libvirt/images/</code>目录下，看到已经有一个镜像了了<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# ll /var/lib/libvirt/images/</span><br><span class="line">total <span class="number">1594308</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">1632632832</span> Nov <span class="number">29</span> <span class="number">18</span>:<span class="number">54</span> H1.qcow2</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以直接将此文件cp一份来当web1的磁盘文件<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/<span class="class"><span class="keyword">lib</span>/<span class="title">libvirt</span>/<span class="title">images</span>/</span></span><br><span class="line">cp H1.qcow2 W1.qcow2</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以在node2节点上的H2和web2虚拟机的磁盘文件。<br>我们直接拷贝改名后，执行<code>virt-install</code>命令，创建另外三个虚拟机。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm \</span><br><span class="line">-<span class="ruby">-name W1 --ram <span class="number">1024</span> --vcpus <span class="number">2</span> \</span></span><br><span class="line"><span class="ruby">--cdrom=<span class="regexp">/usr/local</span><span class="regexp">/src/</span>CentOS-<span class="number">7</span>-x86_64-Minimal-<span class="number">1908</span>.iso \</span></span><br><span class="line"><span class="ruby">--disk=<span class="regexp">/var/lib</span><span class="regexp">/libvirt/images</span><span class="regexp">/W1.qcow2 \</span></span></span><br><span class="line"><span class="ruby">--network network=default \</span></span><br><span class="line"><span class="ruby">--graphics vnc,listen=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--noautoconsole</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后将W1强制终止，因为第一次是默认从光驱启动的，我们已经有系统了，不需要重装，重启后就发现已经是装好的系统，与H1一模一样的。<br>&emsp;&emsp;然后修改主机名为web1，将网卡桥接在eth1上,修改网卡配置。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TYPE</span>=<span class="string">"Ethernet"</span></span><br><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">"static"</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="string">"10.0.0.175"</span></span><br><span class="line"><span class="attr">PREFIX</span>=<span class="string">"16"</span></span><br><span class="line"><span class="attr">DEFROUTE</span>=<span class="string">"yes"</span></span><br><span class="line"><span class="attr">NAME</span>=<span class="string">"eth0"</span></span><br><span class="line"><span class="attr">DEVICE</span>=<span class="string">"eth0"</span></span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="string">"yes"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对node2上的两个虚拟机采用同样方式创建。<br>&emsp;&emsp;之后分别通过脚本装HAProxy+keepadlived服务和nginx+PHP服务。<br>&emsp;&emsp;修改完几个服务的配置文件(可参考之前文章<a href="https://blog.csdn.net/MicePro/article/details/102901024" rel="noopener" target="_blank">企业级应用：负载均衡层——haproxy(一)</a>)之后，就可以将通过客户机就可以访问，后端web服务器了。</p><h2 id="附一键安装脚本"><a href="#附一键安装脚本" class="headerlink" title="附一键安装脚本"></a>附一键安装脚本</h2><h3 id="HAProxy一键安装脚本"><a href="#HAProxy一键安装脚本" class="headerlink" title="HAProxy一键安装脚本"></a>HAProxy一键安装脚本</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@HAProxy1 haproxy]</span># <span class="selector-tag">tree</span></span><br><span class="line">.</span><br><span class="line">├── <span class="selector-tag">haproxy-2</span><span class="selector-class">.0</span><span class="selector-class">.8</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">├── <span class="selector-tag">haproxy84</span><span class="selector-class">.cfg</span></span><br><span class="line">├── <span class="selector-tag">haproxy</span><span class="selector-class">.cfg</span></span><br><span class="line">├── <span class="selector-tag">haproxy</span><span class="selector-class">.service</span></span><br><span class="line">├── <span class="selector-tag">haproxy</span><span class="selector-class">.sh</span></span><br><span class="line">└── <span class="selector-tag">lua-5</span><span class="selector-class">.3</span><span class="selector-class">.5</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"></span><br><span class="line">0 <span class="selector-tag">directories</span>, 6 <span class="selector-tag">files</span></span><br><span class="line"><span class="selector-attr">[root@HAProxy1 haproxy]</span># <span class="selector-tag">bash</span> <span class="selector-tag">haproxy</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">DST=<span class="string">"/apps"</span></span><br><span class="line">[ -a haproxy.cfg ] || &#123; echo <span class="string">' the absence of haproxy.conf'</span> ;exit <span class="number">1</span>;&#125;</span><br><span class="line">[ -a haproxy-<span class="number">2.0</span>.<span class="number">8</span>.tar.gz ] || &#123; echo <span class="string">' the absence of haproxy-2.0.8.tar.gz'</span> ;exit <span class="number">1</span>;&#125;</span><br><span class="line">[ -a haproxy.service ] || &#123; echo <span class="string">' the absence of haproxy.service'</span> ;exit <span class="number">2</span>;&#125;</span><br><span class="line">[ -a /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">haproxy</span>.<span class="title">service</span> ] &amp;&amp; &#123; <span class="title">echo</span> ' <span class="title">haproxy</span> <span class="title">is</span> <span class="title">aready</span> <span class="title">installed</span>' ;</span>exit <span class="number">3</span>;&#125;</span><br><span class="line">id haproxy &amp;&gt;<span class="regexp">/dev/null</span> &amp;&amp; &#123; echo <span class="string">'user haproxy is exist'</span> ; exit <span class="number">4</span>;&#125; || useradd -r -s /sbin/nologin -u <span class="number">79</span> haproxy</span><br><span class="line">yum install -y libtermcap-devel ncurses-devel libevent-devel readline-devel gcc make</span><br><span class="line">[ -a lua-<span class="number">5.3</span>.<span class="number">5</span>.tar.gz ] || wget <span class="symbol">http:</span>/<span class="regexp">/www.lua.org/ftp</span><span class="regexp">/lua-5.3.5.tar.gz</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">tar xvf lua-5.3.5.tar.gz</span></span><br><span class="line"><span class="regexp">cd lua-5.3.5</span></span><br><span class="line"><span class="regexp">make linux test</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">yum install gcc gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel systemd-devel -y</span></span><br><span class="line"><span class="regexp">mkdir -p $DST/haproxy</span></span><br><span class="line"><span class="comment">#[ -a haproxy-2.0.8.tar.gz ] || wget http://www.haproxy.org/download/2.0/src/haproxy-2.0.8.tar.gz</span></span><br><span class="line">cd ..</span><br><span class="line">tar xvf haproxy-<span class="number">2.0</span>.<span class="number">8</span>.tar.gz</span><br><span class="line">sleep <span class="number">1</span></span><br><span class="line">cd haproxy-<span class="number">2.0</span>.<span class="number">8</span></span><br><span class="line"></span><br><span class="line">make ARCH=x86_64 \</span><br><span class="line">TARGET=linux-glibc USE_PCRE=<span class="number">1</span> \</span><br><span class="line">USE_OPENSSL=<span class="number">1</span> \</span><br><span class="line">USE_ZLIB=<span class="number">1</span> \</span><br><span class="line">USE_SYSTEMD=<span class="number">1</span> \</span><br><span class="line">USE_CPU_AFFINITY=<span class="number">1</span> \</span><br><span class="line">USE_LUA=<span class="number">1</span> \</span><br><span class="line">LUA_INC=../lua-<span class="number">5.3</span>.<span class="number">5</span>/src/ \</span><br><span class="line">LUA_LIB=../lua-<span class="number">5.3</span>.<span class="number">5</span>/src/ \</span><br><span class="line">PREFIX=$DST/haproxy</span><br><span class="line">make install PREFIX=$DST/haproxy</span><br><span class="line"></span><br><span class="line">cat &gt; <span class="regexp">/usr/lib</span><span class="regexp">/systemd/system</span><span class="regexp">/haproxy.service &lt;&lt; "END"</span></span><br><span class="line"><span class="regexp">[Unit]</span></span><br><span class="line"><span class="regexp">Description=HAProxy Load Balancer</span></span><br><span class="line"><span class="regexp">After=syslog.target network.target</span></span><br><span class="line"><span class="regexp">[Service]</span></span><br><span class="line"><span class="regexp">ExecStartPre=/usr</span><span class="regexp">/sbin/haproxy</span> -f /etc/haproxy/haproxy.cfg -c -q</span><br><span class="line">ExecStart=<span class="regexp">/usr/sbin</span><span class="regexp">/haproxy -Ws -f /etc</span><span class="regexp">/haproxy/haproxy</span>.cfg -p /var/<span class="class"><span class="keyword">lib</span>/<span class="title">haproxy</span>/<span class="title">haproxy</span>.<span class="title">pid</span></span></span><br><span class="line">ExecReload=<span class="regexp">/bin/kill</span> -USR2 $MAINPID</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target\</span><br><span class="line">END</span><br><span class="line">sed -i <span class="string">"s@/usr@$DST/haproxy@"</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">haproxy</span>.<span class="title">service</span></span></span><br><span class="line"></span><br><span class="line">mkdir -p /etc/haproxy</span><br><span class="line">cd ..</span><br><span class="line">cp haproxy.cfg /etc/haproxy/</span><br><span class="line">sed -i <span class="string">"s@chroot /apps/haproxy@chroot $DST/haproxy@"</span> /etc/haproxy/haproxy.cfg</span><br><span class="line">mkdir -p /var/<span class="class"><span class="keyword">lib</span>/<span class="title">haproxy</span></span></span><br><span class="line">chown <span class="number">99.99</span> /var/<span class="class"><span class="keyword">lib</span>/<span class="title">haproxy</span>/ -<span class="title">R</span></span></span><br><span class="line"></span><br><span class="line">cat &gt;&gt; <span class="regexp">/etc/sysctl</span>.conf &lt;&lt; END</span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line">net.ipv4.ip_nonlocal_bind = <span class="number">1</span></span><br><span class="line">END</span><br><span class="line">sysctl -p <span class="comment">#修改内核参数之后生效，systemctl daemon-reload 是重读启动脚本</span></span><br><span class="line"></span><br><span class="line">systemctl enable --now haproxy</span><br><span class="line">systemctl status haproxy</span><br></pre></td></tr></table></figure><h3 id="Nginx-PHP一键安装脚本"><a href="#Nginx-PHP一键安装脚本" class="headerlink" title="Nginx+PHP一键安装脚本"></a>Nginx+PHP一键安装脚本</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@Web1 web]</span># <span class="selector-tag">tree</span></span><br><span class="line">.</span><br><span class="line">├── <span class="selector-tag">nginx</span></span><br><span class="line">│   ├── <span class="selector-tag">nginx-1</span><span class="selector-class">.16</span><span class="selector-class">.1</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">│   ├── <span class="selector-tag">nginx</span><span class="selector-class">.conf</span></span><br><span class="line">│   ├── <span class="selector-tag">nginx</span><span class="selector-class">.service</span></span><br><span class="line">│   └── <span class="selector-tag">nginx</span><span class="selector-class">.sh</span></span><br><span class="line">├── <span class="selector-tag">php-fpm</span></span><br><span class="line">│   ├── <span class="selector-tag">php-7</span><span class="selector-class">.3</span><span class="selector-class">.10</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line">│   └── <span class="selector-tag">php-fpm</span><span class="selector-class">.sh</span></span><br><span class="line">└── <span class="selector-tag">web</span><span class="selector-class">.sh</span></span><br><span class="line"></span><br><span class="line">2 <span class="selector-tag">directories</span>, 7 <span class="selector-tag">files</span></span><br><span class="line"><span class="selector-attr">[root@Web1 web]</span># <span class="selector-tag">bash</span> <span class="selector-tag">web</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim web.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line">bash nginx.sh</span><br><span class="line"><span class="built_in">cd</span> ../php-fpm</span><br><span class="line">bash php-fpm.sh</span><br></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/nginx.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">DST=<span class="string">"/apps"</span></span><br><span class="line">[ -a nginx.conf ] || &#123; echo <span class="string">' the absence of nginx.conf'</span> ;exit <span class="number">1</span>;&#125;</span><br><span class="line">[ -a nginx.service ] || &#123; echo <span class="string">' the absence of nginx.service'</span> ;exit <span class="number">2</span>;&#125;</span><br><span class="line">[ -a /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">nginx</span>.<span class="title">service</span> ] &amp;&amp; &#123; <span class="title">echo</span> ' <span class="title">nginx</span> <span class="title">is</span> <span class="title">aready</span> <span class="title">installed</span>' ;</span>exit <span class="number">3</span>;&#125;</span><br><span class="line">id nginx &amp;&gt;<span class="regexp">/dev/null</span> &amp;&amp; &#123; echo <span class="string">'user nginx is exist'</span> ; exit <span class="number">4</span>;&#125; || useradd -r -s /sbin/nologin -u <span class="number">80</span> nginx</span><br><span class="line">yum install -y gcc gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel systemd-devel net-tools iotop bc zip unzip zlib-devel bash-completion nfs-utils automake libxml2 libxml2-devel libxslt libxslt-devel perl perl-ExtUtils-Embed   vim lrzsz tree psmisc wget || &#123; echo <span class="string">'Dependencies is not installed'</span>;exit <span class="number">5</span>;&#125;</span><br><span class="line"><span class="comment">#mkdir -p $DST/nginx</span></span><br><span class="line">mkdir -p /data/apps/nginx</span><br><span class="line">ln -s /data/apps/  <span class="regexp">/apps</span></span><br><span class="line"><span class="regexp">[ -a nginx-1.16.1.tar.gz ] || wget https:/</span><span class="regexp">/nginx.org/download</span><span class="regexp">/nginx-1.16.1.tar.gz</span></span><br><span class="line"><span class="regexp">tar xvf nginx-1.16.1.tar.gz</span></span><br><span class="line"><span class="regexp">cd nginx-1.16.1</span></span><br><span class="line"><span class="regexp">./configure</span> --prefix=$DST/nginx --user=nginx --group=nginx --<span class="keyword">with</span>-http_ssl_module --<span class="keyword">with</span>-http_v2_module --<span class="keyword">with</span>-http_realip_module --<span class="keyword">with</span>-http_stub_status_module --<span class="keyword">with</span>-http_gzip_static_module --<span class="keyword">with</span>-pcre --<span class="keyword">with</span>-stream --<span class="keyword">with</span>-stream_ssl_module --<span class="keyword">with</span>-stream_realip_module --<span class="keyword">with</span>-select_module --<span class="keyword">with</span>-file-aio</span><br><span class="line">make -j <span class="number">4</span> &amp;&amp; make install</span><br><span class="line">cp ../nginx.conf $DST/nginx/conf/</span><br><span class="line">cp ../nginx.service /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/</span></span><br><span class="line">systemctl enable --now nginx</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim nginx/nginx.service</span><br><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=The nginx HTTP <span class="keyword">and</span> reverse<span class="built_in"> proxy </span>server</span><br><span class="line"><span class="attribute">After</span>=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=forking</span><br><span class="line"><span class="attribute">PIDFile</span>=/apps/nginx/logs/nginx.pid</span><br><span class="line"><span class="comment"># Nginx will fail to start if /run/nginx.pid already exists but has the wrong</span></span><br><span class="line"><span class="comment"># SELinux context. This might happen when running `nginx -t` from the cmdline.</span></span><br><span class="line"><span class="comment"># https://bugzilla.redhat.com/show_bug.cgi?id=1268621</span></span><br><span class="line"><span class="attribute">ExecStartPre</span>=/usr/bin/rm -f /apps/nginx/logs/nginx.pid</span><br><span class="line"><span class="attribute">ExecStartPre</span>=/apps/nginx/sbin/nginx -t</span><br><span class="line"><span class="attribute">ExecStart</span>=/apps/nginx/sbin/nginx</span><br><span class="line"><span class="attribute">ExecReload</span>=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attribute">KillSignal</span>=SIGQUIT</span><br><span class="line"><span class="attribute">TimeoutStopSec</span>=5</span><br><span class="line"><span class="attribute">KillMode</span>=process</span><br><span class="line"><span class="attribute">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim</span> nginx/nginx.conf</span><br><span class="line">user  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">2</span>;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> <span class="number">0001</span> <span class="number">0010</span>;</span><br><span class="line"><span class="attribute">worker_priority</span> -<span class="number">10</span>;</span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</span><br><span class="line"><span class="attribute">error_log</span>  /apps/nginx/logs/error.log  <span class="literal">error</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">65536</span>;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">log_format</span> access_json <span class="string">'&#123;"<span class="variable">@timestamp</span>":"<span class="variable">$time_iso8601</span>",'</span></span><br><span class="line">        <span class="string">'"host":"<span class="variable">$server_addr</span>",'</span></span><br><span class="line">        <span class="string">'"clientip":"<span class="variable">$remote_addr</span>",'</span></span><br><span class="line">        <span class="string">'"size":<span class="variable">$body_bytes_sent</span>,'</span></span><br><span class="line">        <span class="string">'"responsetime":<span class="variable">$request_time</span>,'</span></span><br><span class="line">        <span class="string">'"upstreamtime":"<span class="variable">$upstream_response_time</span>",'</span></span><br><span class="line">        <span class="string">'"upstreamhost":"<span class="variable">$upstream_addr</span>",'</span></span><br><span class="line">        <span class="string">'"http_host":"<span class="variable">$host</span>",'</span></span><br><span class="line">        <span class="string">'"uri":"<span class="variable">$uri</span>",'</span></span><br><span class="line">        <span class="string">'"domain":"<span class="variable">$host</span>",'</span></span><br><span class="line">        <span class="string">'"xff":"<span class="variable">$http_x_forwarded_for</span>",'</span></span><br><span class="line">        <span class="string">'"referer":"<span class="variable">$http_referer</span>",'</span></span><br><span class="line">        <span class="string">'"tcp_xff":"<span class="variable">$proxy_protocol_addr</span>",'</span></span><br><span class="line">        <span class="string">'"http_user_agent":"<span class="variable">$http_user_agent</span>",'</span></span><br><span class="line">        <span class="string">'"status":"<span class="variable">$status</span>"&#125;'</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /apps/nginx/logs/access_json.log  access_json;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span> <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  www.example.net;</span><br><span class="line">        <span class="attribute">location</span> = / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ ^/(status|ping)$</span> &#123;</span><br><span class="line">             <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">             <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">             <span class="attribute">fastcgi_param</span> PATH_TRANSLATED <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">             <span class="attribute">fastcgi_hide_header</span> X-Powered-By;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">root</span>           html;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">            <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vim php-fpm/php-fpm.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DST=<span class="string">"/apps"</span></span><br><span class="line">[ -a php-*.tar.* ] || &#123; <span class="built_in">echo</span> <span class="string">' the absence of php-7.3.10.tar.xz'</span> ;<span class="built_in">exit</span> 1;&#125;</span><br><span class="line">[ -a /usr/lib/systemd/system/php-fpm.service ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">' php-fpm is aready installed'</span> ;<span class="built_in">exit</span> 2;&#125;</span><br><span class="line">[ -a <span class="variable">$DST</span>/php* ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">' php is aready installed'</span> ;<span class="built_in">exit</span> 2;&#125;</span><br><span class="line">mkdir -p <span class="variable">$DST</span>/php</span><br><span class="line">yum install libxml2-devel bzip2-devel libmcrypt-devel -y || &#123; <span class="built_in">echo</span> <span class="string">'Dependencies is not installed'</span>;<span class="built_in">exit</span> 5;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#wget https://www.php.net/distributions/php-7.3.10.tar.xz</span></span><br><span class="line">tar xvf php-*.tar.*</span><br><span class="line"><span class="built_in">cd</span> php-7.3.10</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=<span class="variable">$DST</span>/php \</span><br><span class="line">--<span class="built_in">enable</span>-mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir=/usr \</span><br><span class="line">--with-config-file-path=/etc \</span><br><span class="line">--with-config-file-scan-dir=/etc/php.d \</span><br><span class="line">--<span class="built_in">enable</span>-mbstring \</span><br><span class="line">--<span class="built_in">enable</span>-xml \</span><br><span class="line">--<span class="built_in">enable</span>-sockets \</span><br><span class="line">--<span class="built_in">enable</span>-fpm \</span><br><span class="line">--<span class="built_in">enable</span>-maintainer-zts \</span><br><span class="line">--<span class="built_in">disable</span>-fileinfo</span><br><span class="line"></span><br><span class="line"> make -j 4 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">cp php.ini-production  /etc/php.ini</span><br><span class="line">cp sapi/fpm/php-fpm.service /usr/lib/systemd/system/</span><br><span class="line"></span><br><span class="line">cp <span class="variable">$DST</span>/php/etc/php-fpm.conf.default  <span class="variable">$DST</span>/php/etc/php-fpm.conf</span><br><span class="line">cp <span class="variable">$DST</span>/php/etc/php-fpm.d/www.conf.default <span class="variable">$DST</span>/php/etc/php-fpm.d/www.conf</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s@nobody@nginx@g'</span> <span class="variable">$DST</span>/php/etc/php-fpm.d/www.conf</span><br><span class="line">sed -i <span class="string">'/#/!s@index  index.html index.htm@index index.php index.html index.htm@'</span> <span class="variable">$DST</span>/nginx/conf/nginx.conf</span><br><span class="line">sed -i <span class="string">'s@/scripts$fastcgi_script_name@$document_root$fastcgi_script_name@g'</span> <span class="variable">$DST</span>/nginx/conf/nginx.conf</span><br><span class="line"><span class="variable">$DST</span>/nginx/sbin/nginx -s reload</span><br><span class="line">systemctl <span class="built_in">enable</span> --now php-fpm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;KVM 是Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中，KVM目前已成为学术界的主流 VMM (virtual machine monitor，虚拟机监视器，也称为hypervisor)之一。&lt;br&gt;
    
    </summary>
    
      <category term="Cloud" scheme="https://wudihechao.github.io/categories/Cloud/"/>
    
    
      <category term="一键安装" scheme="https://wudihechao.github.io/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"/>
    
      <category term="负载均衡" scheme="https://wudihechao.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="KVM" scheme="https://wudihechao.github.io/tags/KVM/"/>
    
      <category term="虚拟化" scheme="https://wudihechao.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ubuntu" scheme="https://wudihechao.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>OpenVPN的搭建</title>
    <link href="https://wudihechao.github.io//blog/2c6b894f.html"/>
    <id>https://wudihechao.github.io//blog/2c6b894f.html</id>
    <published>2019-11-25T13:05:48.000Z</published>
    <updated>2019-12-21T12:05:28.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;企业中，必不可少的应用就是VPN了，它可以帮助员工在外网中访问公司内网，常见开源实现方案有OpenVPN和jumpserver。<br>&emsp;&emsp;OpenVPN是采用了端口转发的原理实现，是基于IP+端口的4层代理机制，一般是用于出差员工访问公司内部ERP系统等使用，而jumpserver是7层代理，所以功能更加强大却也更加复杂，一般适合运维人员管理维护企业内部服务器。对于中小公司日常使用，OpenVPN就已经完全足够了，当然，也可用于科学，你懂得。本文将对linux环境下（CentOS），OpenVPN的安装配置做一个详细的介绍。<br><a id="more"></a></p><h1 id="部署OpenVPN"><a href="#部署OpenVPN" class="headerlink" title="部署OpenVPN"></a>部署OpenVPN</h1><h2 id="部署OpenVPN服务器"><a href="#部署OpenVPN服务器" class="headerlink" title="部署OpenVPN服务器"></a>部署OpenVPN服务器</h2><h3 id="下载安装OpenVPN"><a href="#下载安装OpenVPN" class="headerlink" title="下载安装OpenVPN"></a>下载安装OpenVPN</h3><p>&emsp;&emsp;OpenVPN的rpm包可以在epel源中直接下载安装，所以我们需要先配置epel源，推荐选用阿里的epel源，<code>CentOS67</code>命令如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/aliyunepel.repo &lt;&lt; <span class="string">"END"</span></span><br><span class="line">[aliyun-epel]</span><br><span class="line">name=aliyun-epel</span><br><span class="line">baseurl=https://mirrors.aliyun.com/epel/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-$releasever</span><br><span class="line">enabled=1</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>CentOS8</code>路径有所变化，命令如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/aliyunepel.repo &lt;&lt; <span class="string">"END"</span></span><br><span class="line">[aliyun-epel]</span><br><span class="line">name=aliyun-epel</span><br><span class="line">baseurl=https://mirrors.aliyun.com/epel/$releasever/Everything/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-$releasever</span><br><span class="line">enabled=1</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;或者直接安装官方的epel源(6、7、8通用）。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> epel-<span class="keyword">release</span> -y</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;配置好epel源之后，直接yum安装服务器端软件和证书管理工具就可以了。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> openvpn -y <span class="comment">#openvpn服务端</span></span><br><span class="line">yum <span class="keyword">install</span> easy-rsa -y <span class="comment">#证书管理工具</span></span><br></pre></td></tr></table></figure></p><h3 id="OpenVPN配置"><a href="#OpenVPN配置" class="headerlink" title="OpenVPN配置"></a>OpenVPN配置</h3><p>&emsp;&emsp;将模版配置文件及证书管理工具复制到指定目录<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/doc/</span>openvpn<span class="number">-2.4</span><span class="number">.8</span><span class="meta-keyword">/sample/</span>sample-config-files/server.conf <span class="meta-keyword">/etc/</span>openvpn/  <span class="meta">#openvpn server 配置文件</span></span><br><span class="line">cp -r <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/easy-rsa/</span> <span class="meta-keyword">/etc/</span>openvpn/easyrsa-server <span class="meta">#证书管理工具</span></span><br><span class="line">cp <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/doc/</span>easy-rsa<span class="number">-3.0</span><span class="number">.6</span>/vars.example <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/easyrsa-server/</span><span class="number">3</span>/vars</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;配置文件模版如果没有，那可能是在路径为<code>/usr/share/doc/openvpn/sample/sample-config-files/server.conf</code>，easy-rsa如果CentOS8yum安装不上，只能去github上<code>https://github.com/OpenVPN/easy-rsa</code>下载，将里面的easyrsa3目录复制出来就是证书管理工具,并且不需要复制<code>vars.example</code>文件，里面已经有了,改个名字就可以。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> -r easyrsa3 /etc/openvpn/easyrsa-server</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;先进入证书管理工具目录（若github上下载的则是<code>cd /etc/openvpn/easyrsa-server/</code>，之后则都没有3的子目录，或者也创建一个3的子目录保持一致性）<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;若easyrsa为github下载的话，目录结果如下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@aws-host easyrsa-server]#tree</span><br><span class="line">.</span><br><span class="line">├── easyrsa</span><br><span class="line">├── openssl-easyrsa.cnf</span><br><span class="line">├── vars.example</span><br><span class="line">└── x509-types</span><br><span class="line">    ├── ca</span><br><span class="line">    ├── client</span><br><span class="line">    ├── code-signing</span><br><span class="line">    ├── COMMON</span><br><span class="line">    ├── email</span><br><span class="line">    ├── server</span><br><span class="line">    └── serverClient</span><br><span class="line"></span><br><span class="line">1 directory, 10 files</span><br><span class="line">[root@aws-host easyrsa-server]#</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;OpenVPN的server端配置文件如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/openvpn/server.conf</span><br><span class="line">local <span class="number">172.18</span><span class="number">.200</span><span class="number">.101</span> #本机监听IP,写公网IP</span><br><span class="line">port <span class="number">1194</span> #端口</span><br><span class="line"># TCP or UDP server?</span><br><span class="line">proto tcp #协议，指定OpenVPN创建的通信隧道类型</span><br><span class="line">#proto udp</span><br><span class="line">#dev tap：创建一个以太网隧道，以太网使用tap</span><br><span class="line">dev tun：创建一个路由IP隧道，互联网使用tun一个TUN设备大多时候，被用于基于IP协议的通讯。一个TAP设备允许完整的以太网帧通过Openvpn隧道，因此提供非ip协议的支持，比如IPX协议和AppleTalk协议</span><br><span class="line">#dev-node MyTap #TAP-Win32适配器。非windows不需要</span><br><span class="line">#topology subnet #网络拓扑，不需要配置</span><br><span class="line">server <span class="number">10.8</span><span class="number">.0</span><span class="number">.0</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> #客户端连接后分配IP的地址池，服务器默认会占用第一个IP <span class="number">10.8</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">#ifconfig-pool-persist ipp.txt #为客户端分配固定IP，不需要配置</span><br><span class="line">#server-bridge <span class="number">10.8</span><span class="number">.0</span><span class="number">.4</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> <span class="number">10.8</span><span class="number">.0</span><span class="number">.50</span> <span class="number">10.8</span><span class="number">.0</span><span class="number">.100</span> #配置网桥模式，不需要</span><br><span class="line">push <span class="string">"route 10.20.0.0 255.255.0.0"</span> #给客户端生成的静态路由表，下一跳为openvpn服务器的<span class="number">10.8</span><span class="number">.0</span><span class="number">.1</span>,地址段为openvpn服务器后的公司内部网络，可以是多个网段</span><br><span class="line">push <span class="string">"route 172.31.0.0 255.255.248.0"</span></span><br><span class="line">;client-config-dir ccd #为指定的客户端添加路由，改路由通常是客户端后面的内网网段而不是服务端的，也不需要设置</span><br><span class="line">;route <span class="number">192.168</span><span class="number">.40</span><span class="number">.128</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.248</span></span><br><span class="line">;client-config-dir ccd</span><br><span class="line">;route <span class="number">10.9</span><span class="number">.0</span><span class="number">.0</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.252</span></span><br><span class="line">;learn-address ./script #运行外部脚本，创建不同组的iptables 规则，不配置</span><br><span class="line">;push <span class="string">"redirect-gateway def1 bypass-dhcp"</span> #启用后，客户端所有流量都将通过VPN服务器，因此不需要配置</span><br><span class="line">#;push <span class="string">"dhcp-option DNS 208.67.222.222"</span> #推送DNS服务器，不需要配置</span><br><span class="line">#;push <span class="string">"dhcp-option DNS 208.67.220.220"</span></span><br><span class="line">#client-to-client #允许不同的client通过openvpn server直接通信，不开启</span><br><span class="line">#;duplicate-cn #多个用户共用一个账户，一般用于测试环境，生产环境都是一个用户一个证书</span><br><span class="line">keepalive <span class="number">10</span> <span class="number">120</span> #设置服务端检测的间隔和超时时间，默认为每 <span class="number">10</span> 秒 ping一次，如果 <span class="number">120</span> 秒没有回应则认为对方已经 down</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以最终配置如下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">local 172.18.32.71    #写公网IP，测试环境无所谓</span><br><span class="line">port 1194</span><br><span class="line">proto tcp</span><br><span class="line">dev tun</span><br><span class="line">ca /etc/openvpn/certs/ca.crt</span><br><span class="line">cert /etc/openvpn/certs/server.crt</span><br><span class="line">key /etc/openvpn/certs/server.key  # This file should be kept secret</span><br><span class="line">dh /etc/openvpn/certs/dh.pem</span><br><span class="line">server 10.8.0.0 255.255.255.0   #默认设置，不需要修改</span><br><span class="line">push <span class="string">"route 10.0.0.0 255.255.255.0"</span>    #内网网段，不需要修改，科学上网则为 push <span class="string">"redirect-gateway def1 bypass-dhcp"</span></span><br><span class="line">client-to-client</span><br><span class="line">keepalive 10 120</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">max-clients 100</span><br><span class="line">user nobody</span><br><span class="line">group nobody</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log</span><br><span class="line">log-append  /var/log/openvpn/openvpn.log</span><br><span class="line">verb 9</span><br><span class="line">mute 20</span><br></pre></td></tr></table></figure></p><h3 id="搭建CA并签发证书"><a href="#搭建CA并签发证书" class="headerlink" title="搭建CA并签发证书"></a>搭建CA并签发证书</h3><p>&emsp;&emsp;初始化pki环境<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./easyrsa</span> init-pki <span class="comment">#生成pki目录用于保存证书</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建CA签发机构，然后<code>直接回车</code><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa <span class="keyword">build-ca </span><span class="keyword">nopass </span>#创建ca并不使用密码</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建服务端证书(私钥)，<code>直接回车</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-req<span class="built_in"> server </span>nopass #生成server证书且不使用密码</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后使用自建ca签发服务器证书，即生成服务端crt公钥。crt公钥后期将用户发送给客户端，从而实现与openvpnserver端加密传输数据。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa sign<span class="built_in"> server server </span>#签发服务端证书，备注信息为server</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后输入<code>yes</code>输入。</p><h3 id="创建非对称秘钥对"><a href="#创建非对称秘钥对" class="headerlink" title="创建非对称秘钥对"></a>创建非对称秘钥对</h3><p>&emsp;&emsp;还在easyrsa-server目录下，生成秘钥，这可能会花费一段时间。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./easyrsa</span> gen-dh</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;到此服务端证书环境配置完成，下面是配置客户端证书配置</p><h3 id="创建客户端证书及配置文件"><a href="#创建客户端证书及配置文件" class="headerlink" title="创建客户端证书及配置文件"></a>创建客户端证书及配置文件</h3><p>&emsp;&emsp;证书还是使用easyrsa工具，（github下载的也还是那个目录<code>easyrsa3</code>，不需要复制<code>vars.example</code>文件,改个名字就可以）<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r <span class="regexp">/usr/</span>share<span class="regexp">/easy-rsa/</span> <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-client/</span></span><br><span class="line">cp <span class="regexp">/usr/</span>share<span class="regexp">/doc/</span>easy-rsa-<span class="number">3.0</span>.<span class="number">6</span><span class="regexp">/vars.example /</span>etc<span class="regexp">/openvpn/</span>easyrsa-client<span class="regexp">/3/</span>vars</span><br></pre></td></tr></table></figure></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/etc/openvpn/easyrsa-client/3</span></span><br><span class="line"><span class="string">./easyrsa</span> init-pki</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如员工为Mice，则创建名为Mice的证书<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./easyrsa</span> gen-req Mice nopass <span class="comment">#客户证书为Mice，没有设置密码</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后<code>直接回车</code>，便生成了Mice的证书申请和私钥。<strong>进入easyrsa的server目录中</strong>，(注意，<code>一定要进入easyrsa-server目录</code>，否则会报错)，导入证书申请并给客户端的证书请求签发证书,记得输入<code>yes</code>确认。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa import-req /etc/openvpn/easyrsa-client/3/pki/reqs/Mice.req Mice</span><br><span class="line">./easyrsa sign<span class="built_in"> client </span>Mice</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;复制证书到server目录：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/etc/</span>openvpn/certs</span><br><span class="line">cd <span class="regexp">/etc/</span>openvpn<span class="regexp">/certs/</span></span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span><span class="regexp">/pki/</span>dh.pem .</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span><span class="regexp">/pki/</span>ca.crt .</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span><span class="regexp">/pki/</span>issued/server.crt .</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span><span class="regexp">/pki/</span><span class="keyword">private</span>/server.key .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建客户端配置文件<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/client/</span>Mice/</span><br><span class="line">vim <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/client/</span>Mice/client.ovpn</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client #声明自己是个客户端</span><br><span class="line">dev tun #接口类型，必须和服务端保持一致</span><br><span class="line">proto tcp #使用的协议，必须和服务端保持一致</span><br><span class="line">remote <span class="number">172.18</span><span class="number">.32</span><span class="number">.71</span> <span class="number">1194</span> #server端的ip和端口，可以写域名但是需要可以解析成IP</span><br><span class="line">resolv-retry infinite #如果是写的server端的域名，那么就始终解析，如果域名发生变化，会重新连接到新&gt;的域名对应的IP</span><br><span class="line">nobind #本机不绑定监听端口，客户端是随机打开端口连接到服务端的<span class="number">1194</span></span><br><span class="line">persist-<span class="type">key</span> #</span><br><span class="line">persist-tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert Mice.crt</span><br><span class="line"><span class="type">key</span> Mice.<span class="type">key</span></span><br><span class="line">remote-cert-tls server #指定采用服务器校验方式</span><br><span class="line">#tls-auth ta.<span class="type">key</span> <span class="number">1</span></span><br><span class="line">cipher AES<span class="number">-256</span>-CBC</span><br><span class="line">verb <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对签发的客户端证书及配置文件进行归档,并打包发送给客户端主机。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/etc/</span>openvpn<span class="regexp">/client/</span>Mice/</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span><span class="regexp">/pki/</span>ca.crt .</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-server/</span><span class="number">3</span><span class="regexp">/pki/</span>issued/Mice.crt .</span><br><span class="line">cp <span class="regexp">/etc/</span>openvpn<span class="regexp">/easyrsa-client/</span><span class="number">3</span><span class="regexp">/pki/</span><span class="keyword">private</span>/Mice.key .</span><br><span class="line">tar czvf  Mice.tar.gz *</span><br></pre></td></tr></table></figure></p><h3 id="配置防火墙转发规则"><a href="#配置防火墙转发规则" class="headerlink" title="配置防火墙转发规则"></a>配置防火墙转发规则</h3><p>&emsp;&emsp;开启路由转发功能：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># sysctl -p</span></span><br><span class="line"><span class="attr">net.ipv4.ip_forward</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;先清除现有防火墙策略以免发生干扰，如果CentOS7/8或Redhat7/8没有iptables命令就<code>yum install -y iptables-services</code>安装一个，之后设置IP伪装需要用到。<br>&emsp;&emsp;清空已有规则<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-F</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-X</span><br><span class="line">iptables -t<span class="built_in"> nat </span>-Z</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建iptables 规则：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t<span class="built_in"> nat </span>-A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE #此IP是server端默认ip，不要改</span><br><span class="line">iptables -A INPUT -p TCP --dport 1194 -j ACCEPT</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;CentOS6/7的话可以用保存iptables规则（适用未安装iptables-services，俩方式选一个就好）:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service iptables save</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;显示OK说明保存成功<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables: Saving<span class="built_in"> firewall </span>rules <span class="keyword">to</span> /etc/sysconfig/iptables:[ OK ]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果用的services，则<code>systemctl enable --now iptables</code>（会自动从/etc/sysconfig/iptables文件中读取防火墙策略）</p><p>&emsp;&emsp;创建日志目录并授权：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /<span class="built_in">var</span>/<span class="built_in">log</span>/openvpn</span><br><span class="line">chown nobody.nobody /<span class="built_in">var</span>/<span class="built_in">log</span>/openvpn</span><br></pre></td></tr></table></figure></p><h3 id="启动OpenVPN服务"><a href="#启动OpenVPN服务" class="headerlink" title="启动OpenVPN服务"></a>启动OpenVPN服务</h3><p>&emsp;&emsp;启动openvpn服务<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl</span> enable --now openvpn<span class="variable">@server</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果没有<a href="mailto:openvpn@server.service" rel="noopener" target="_blank">openvpn@server.service</a>文件，那就自己编写一个吧<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">openvpn</span>@.<span class="title">service</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=OpenVPN Robust And Highly Flexible Tunneling Application <span class="literal">On</span> %I</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=notify</span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/sbin/openvpn --cd /etc/openvpn/ --config %i.conf</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;验证日志：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tail /var/log/openvpn/openvpn.log</span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> Socket Buffers: R=[<span class="number">87380</span>-&gt;<span class="number">87380</span>] S=[<span class="number">16384</span>-&gt;<span class="number">16384</span>]</span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> Listening <span class="keyword">for</span> incoming TCP connection on</span><br><span class="line">[AF_INET]<span class="number">172.18</span><span class="number">.32</span><span class="number">.71</span>:<span class="number">1194</span></span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> TCPv4_SERVER link local (bound):</span><br><span class="line">[AF_INET]<span class="number">172.18</span><span class="number">.32</span><span class="number">.71</span>:<span class="number">1194</span></span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> TCPv4_SERVER link remote: [AF_UNSPEC]</span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> GID <span class="keyword">set</span> to root</span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> UID <span class="keyword">set</span> to root</span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> MULTI: multi_init called, r=<span class="number">256</span> v=<span class="number">256</span></span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> IFCONFIG POOL: base=<span class="number">10.8</span><span class="number">.0</span><span class="number">.4</span> size=<span class="number">62</span>, ipv6=<span class="number">0</span></span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> MULTI: TCP INIT maxclients=<span class="number">4096</span> maxevents=<span class="number">4100</span></span><br><span class="line">Tue Nov <span class="number">19</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">27</span> <span class="number">2019</span> Initialization Sequence Completed</span><br></pre></td></tr></table></figure></p><h2 id="OpenVPN客户端"><a href="#OpenVPN客户端" class="headerlink" title="OpenVPN客户端"></a>OpenVPN客户端</h2><p>&emsp;&emsp;官方客户端下载地址： <a href="https://openvpn.net/community-downloads/" rel="noopener" target="_blank">https://openvpn.net/community-downloads/</a><br>&emsp;&emsp;非官方地址：<a href="https://sourceforge.net/projects/securepoint/files/" rel="noopener" target="_blank">https://sourceforge.net/projects/securepoint/files/</a><br>&emsp;&emsp;如果是默认安装路径的话，保存证书到openvpn 客户端安装目录：C:\Program Files\OpenVPN\config<br>&emsp;&emsp;之后就可以直接启动OpenVPN。此时就可以用浏览器直接访问内网IP或者直接ssh登陆内部服务器了。</p><hr><h1 id="关于科学上网"><a href="#关于科学上网" class="headerlink" title="关于科学上网"></a>关于科学上网</h1><p>&emsp;&emsp;经过本人尝试多次，使用OpenVPN做代理转发来实现科学上网，还是有点难度。理论上简单可行的东西，搞了好几次都没成功。<br>&emsp;&emsp;本人有亚马逊的海外云主机，在上面搭建了OpenVPN之后怎么也没法成功，甚至云主机都登陆不上了。开始以为是GW将数据包拦截了，导致云主机被封掉。后来使用其他海外主机直接连接均无法连接失联的云主机，使用端口检查工具发现，那个云主机的所有端口都被关闭了。猜测应该是被亚马逊给封掉了，无奈之下只能释放实例，重新搭建服务器。弄了数次发现，结局均以实例被封告终。猜测亚马逊应该是检查到异常流量，直接把实例的数据连接都断掉了（据说OpenVPN的收费版本不会被封掉），绝望之下，尝试了下UDP协议来代替TCP协议，将客户端设置和服务端设置都改为UPD，竟然发现可以访问外网了，而且服务器至今也平安无事~有需求的小伙伴可以尝试UDP协议。另外附上我云主机的server端配置,希望对大家有所帮助。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grep ^[a-Z] /etc/openvpn/server.conf</span><br><span class="line">local 0.0.0.0</span><br><span class="line">port 11094</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line">ca  /etc/openvpn/certs/ca.crt</span><br><span class="line">cert /etc/openvpn/certs/server.crt</span><br><span class="line">key /etc/openvpn/certs/server.key</span><br><span class="line">dh /etc/openvpn/certs/dh.pem</span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line">push <span class="string">"redirect-gateway def1 bypass-dhcp"</span></span><br><span class="line">push <span class="string">"dhcp-option DNS 8.8.8.8"</span></span><br><span class="line">keepalive 10 120</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">max-clients 10</span><br><span class="line">user openvpn</span><br><span class="line">group openvpn</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log</span><br><span class="line">log-append  /var/log/openvpn/openvpn.log</span><br><span class="line">verb 3</span><br><span class="line">mute 20</span><br><span class="line">explicit-exit-notify 1</span><br></pre></td></tr></table></figure></p><hr><p>&emsp;&emsp;本文写得很简略，发现有小伙伴对相关问题很有兴趣，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;企业中，必不可少的应用就是VPN了，它可以帮助员工在外网中访问公司内网，常见开源实现方案有OpenVPN和jumpserver。&lt;br&gt;&amp;emsp;&amp;emsp;OpenVPN是采用了端口转发的原理实现，是基于IP+端口的4层代理机制，一般是用于出差员工访问公司内部ERP系统等使用，而jumpserver是7层代理，所以功能更加强大却也更加复杂，一般适合运维人员管理维护企业内部服务器。对于中小公司日常使用，OpenVPN就已经完全足够了，当然，也可用于科学，你懂得。本文将对linux环境下（CentOS），OpenVPN的安装配置做一个详细的介绍。&lt;br&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="https://wudihechao.github.io/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="经验分享" scheme="https://wudihechao.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
      <category term="OpenVPN" scheme="https://wudihechao.github.io/tags/OpenVPN/"/>
    
      <category term="SSH" scheme="https://wudihechao.github.io/tags/SSH/"/>
    
      <category term="科学上网" scheme="https://wudihechao.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>tomcat集群的session共享</title>
    <link href="https://wudihechao.github.io//blog/6254cc16.html"/>
    <id>https://wudihechao.github.io//blog/6254cc16.html</id>
    <published>2019-11-22T13:50:11.000Z</published>
    <updated>2019-12-25T12:25:45.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;tomcat作为一个应用服务器，单机性能上都是无法满足生产中需要的，而想要解决高并发场景，光靠提升单机性能，成本与效果肯定都是无法让人接受的，而此时我们一般都采用tomcat集群的方式，用多台tomcat服务器来共同支撑我们的业务。<br>&emsp;&emsp;但这时就出现了一个新的问题，那就是会话保持。因为每台tomcat服务器的session是独立的，当客户端被调度到一个新的tomcat服务器时，他无法识别之前一台的tomcat服务器分配的sessionID，于是对于此次访问，之前的会话信息就都没有了，这表现在用户的客户端就相当于，点开一个新的链接，就发现需要重新登陆，或者之前的购物车里的商品都不见了等等。这样的客户访问体验绝对不是我们想要的，所以我们需要实现会话保持功能！<br><a id="more"></a></p><h2 id="会话保持实现"><a href="#会话保持实现" class="headerlink" title="会话保持实现"></a>会话保持实现</h2><p>&emsp;&emsp;一般tomcat的会话保持有三种方案实现：</p><ul><li>nginx、httpd或者haproxy的调度实现session绑定,一般是源地址哈希方式实现<br>优点:简单易配置<br>缺点：<br>①如果目标服务器故障后,没有做持久化的话就会丢失session;<br>②即便做了持久化,当服务器故障后,nginx或者haproxy会不得不重新分配一个tomcat服务器,而这时因为新的tomcat服务器上没有原来的sessionID,所以无法找到相应会话信息,会重新分配一个sessionID给客户端,就算原来的tomcat服务器重新上线,又被分配到原来的tomcat服务器中,可此时客户端已经有了新的sessionID,也不会去读取最开始的session信息,那些会话信息就相当于永远丢失了。</li><li>session复制集群,官方给出的tomcat会话共享解决方案<br>&emsp;&emsp;tomcat自己提供的多播集群，通过多播将任何一台的session同步到其他节点。<br>缺点：<br>①tomcat的同步节点不宜过多，互相即时通信session需要太多带宽；<br>②每一台tomcat服务器都拥有全部session信息，内存占用太多。</li><li>session server<br>&emsp;&emsp;session 共享服务器，一般使用memcached、redis做共享的session服务器。<br>目前最理想的解决方案，不过会需要额外的机器来配置共享服务器。<h3 id="反向代理的session绑定"><a href="#反向代理的session绑定" class="headerlink" title="反向代理的session绑定"></a>反向代理的session绑定</h3>&emsp;&emsp;这种实现session保持的方案，一般是使用的不多，一般用于公司内部中的会话保持场景。只需在haproxy或者nginx中的调度算法中，加入基于源地址hash即可（调度算法参考<a href="https://hewanyue.com/blog/5aeb7732.html#haproxy调度算法" rel="noopener" target="_blank">之前博客</a>）。于是，用户每次访问都会被调度到同一台tomcat服务器上，上面已有他的session信息，便实现了会话保持。<h4 id="配置实现"><a href="#配置实现" class="headerlink" title="配置实现"></a>配置实现</h4>&emsp;&emsp;我们用一台nginx服务器做反向代理，两台tomcat服务器来演示实现过程。</li></ul><p>&amp;gt nginx主机ip：192.168.32.207<br>&amp;gt tomcat主机1ip：192.168.32.231<br>&amp;gt tomcat主机2ip：192.168.32.232</p><p>&emsp;&emsp;将3台机子中的nginx或tomcat服务启动之后，分别检查80端口和8080端口是否都已监听，确保服务启动。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">iptables</span> <span class="string">-F</span></span><br><span class="line"><span class="attr">getenforce</span> <span class="string">0</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;确保防火墙和SELinux设置不会干扰我们几台主机间的相互通信。<br>&emsp;&emsp;nginx主机反向代理的配置<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat &#123;</span><br><span class="line">    #ip_hash; #先关闭原地址iphash，观察效果</span><br><span class="line">    server <span class="number">192.168</span><span class="number">.32</span><span class="number">.231</span>:<span class="number">8080</span> weight=<span class="number">1</span> fail_timeout=<span class="number">5</span>s max_fails=<span class="number">3</span>;</span><br><span class="line">    server <span class="number">192.168</span><span class="number">.32</span><span class="number">.232</span>:<span class="number">8080</span> weight=<span class="number">1</span> fail_timeout=<span class="number">5</span>s max_fails=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    index index.jsp</span><br><span class="line">#    server_name www.example.net;</span><br><span class="line">#    location ~* \.(jsp|<span class="keyword">do</span>)$ &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//tomcat;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可启用主机名，也可不启用直接用端口访问。用域名访问还需要改DNS或者hosts设置，比较麻烦，我们就直接通过IP+端口访问就可以了。<br>&emsp;&emsp;tomcat服务器中可以新建一个host，也可使用原先的localhost默认主机。我们这次不用之前的localhost，而是自己新创建一个host标签，指定appBase在/data/myapp目录下。两个tomcat服务器都要执行如下操作：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/apps/</span>tomcat<span class="regexp">/conf/</span>server.xml</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;找到<code>Engine标签</code>，将默认主机修改为<code>myapp</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ltEngine <span class="attribute">name</span>=<span class="string">"Catalina"</span> <span class="attribute">defaultHost</span>=<span class="string">"myapp"</span>&amp;gt</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;找到<code>localhost</code>的<code>&amp;lt/Host&amp;gt</code>标签，在下面创建新的主机<code>myapp</code>,指定appBase为/data/myapp<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;ltHost <span class="attribute">name</span>=<span class="string">"myapp"</span>  <span class="attribute">appBase</span>=<span class="string">"/data/myapp"</span></span><br><span class="line">      <span class="attribute">unpackWARs</span>=<span class="string">"true"</span> <span class="attribute">autoDeploy</span>=<span class="string">"true"</span>&amp;gt</span><br><span class="line">&amp;lt/Host&amp;gt</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;PS：Host name一般为主机域名，当一个tomcat中有多个host服务时，就是通过http报文请求头部的host信息来判断去访问哪个host服务的，当找不到对应的主机之后才访问<code>defaultHost</code>，我们这里因为只有启用了一个host，且为defaultHost，所以就无所谓，可以任意命名了，只需对应上就好。<br>&emsp;&emsp;之后我们要在/data/myapp目录下创建一个<code>ROOT</code>目录来作为tomcat访问的默认目录，注意<code>ROOT</code>是大写的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkdir</span> -p /<span class="class"><span class="keyword">data</span>/myapp/<span class="type">ROOT</span></span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;为了方便我们看到效果，我们编写index.jsp时，调用一些函数，方便我们看到我们访问的tomcat主机的IP和端口、sessionID、访问时间。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/data/my</span>app<span class="regexp">/ROOT/i</span>ndex.jsp</span><br></pre></td></tr></table></figure></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;lt</span>%@ <span class="meta">page</span> import=<span class="string">"java.util.*"</span> %<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lt</span>!DOCTYPE html<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lthtml</span> lang=<span class="string">"en"</span><span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lthead</span><span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;ltmeta</span> charset=<span class="string">"UTF-8"</span><span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lttitle</span><span class="variable">&amp;gtlbjsptest</span><span class="variable">&amp;lt</span>/<span class="meta">title</span><span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lt</span>/head<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;ltbody</span><span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;ltdiv</span><span class="variable">&amp;gtOn</span> <span class="variable">&amp;lt</span>%=request.getServerName() %<span class="variable">&amp;gt</span><span class="variable">&amp;lt</span>/div<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;ltdiv</span><span class="variable">&amp;gt</span><span class="variable">&amp;lt</span>%=request.getLoca<span class="meta">lAddr(</span>) + <span class="string">":"</span> + request.getLocalPort() %<span class="variable">&amp;gt</span><span class="variable">&amp;lt</span>/div<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;ltdiv</span><span class="variable">&amp;gtSessionID</span> = <span class="variable">&amp;ltspan</span> style=<span class="string">"color:blue"</span><span class="variable">&amp;gt</span><span class="variable">&amp;lt</span>%=session.getId() %<span class="variable">&amp;gt</span><span class="variable">&amp;lt</span>/span<span class="variable">&amp;gt</span><span class="variable">&amp;lt</span>/div<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lt</span>%=new<span class="meta"> Date(</span>)%<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lt</span>/body<span class="variable">&amp;gt</span></span><br><span class="line"><span class="variable">&amp;lt</span>/html<span class="variable">&amp;gt</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，我们访问nginx的80端口，就可以被反向代理到后端的两个tomcat服务器上去。而这时，是轮询的调度方式，也就是一边一次，可以看到访问的主机和sessionID都是一直在变化的。<br>效果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191122152145219.gif" alt="nginx轮询tomcat"></p><p>&emsp;&emsp;每一次的sessionID都没有重复过，这肯定不满足我们的需要。所以我们将nginx配置中#ip_hash;的#注释去掉，重启nginx服务，再看效果，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191122152346465.gif" alt="在这里插入图片描述"><br>&emsp;&emsp;可以看到，每次刷新，主机IP和sessionID都不再变化，说明绑定session成功。</p><h3 id="session复制集群"><a href="#session复制集群" class="headerlink" title="session复制集群"></a>session复制集群</h3><p>&emsp;&emsp;这是tomcat官方提供的解决方案，所有tomcat上都有全量的session，不过同步session信息会消耗带宽，而且所有服务器保存所有session信息也比较占用资源，对于tomcat这种本身就处于效率瓶颈的服务来说，高并发场景下超过若五个tomcat服务器，就不再建议使用。<br>&emsp;&emsp;配置详细可以参见<a href="https://tomcat.apache.org/tomcat-8.5-doc/cluster-howto.html" rel="noopener" target="_blank">官网配置说明</a>。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&amp;ltCluster <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.tcp.SimpleTcpCluster"</span></span><br><span class="line">         <span class="attribute">channelSendOptions</span>=<span class="string">"8"</span>&amp;gt</span><br><span class="line"></span><br><span class="line">  &amp;ltManager <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.session.DeltaManager"</span></span><br><span class="line">           <span class="attribute">expireSessionsOnShutdown</span>=<span class="string">"false"</span></span><br><span class="line">           <span class="attribute">notifyListenersOnReplication</span>=<span class="string">"true"</span>/&amp;gt</span><br><span class="line"></span><br><span class="line">  &amp;ltChannel <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.group.GroupChannel"</span>&amp;gt</span><br><span class="line">    &amp;ltMembership <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.membership.McastService"</span></span><br><span class="line">                <span class="attribute">address</span>=<span class="string">"228.0.0.4"</span></span><br><span class="line">                <span class="attribute">port</span>=<span class="string">"45564"</span></span><br><span class="line">                <span class="attribute">frequency</span>=<span class="string">"500"</span></span><br><span class="line">                <span class="attribute">dropTime</span>=<span class="string">"3000"</span>/&amp;gt</span><br><span class="line">    &amp;ltReceiver <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.transport.nio.NioReceiver"</span></span><br><span class="line">              <span class="attribute">address</span>=<span class="string">"auto"</span></span><br><span class="line">              <span class="attribute">port</span>=<span class="string">"4000"</span></span><br><span class="line">              <span class="attribute">autoBind</span>=<span class="string">"100"</span></span><br><span class="line">              <span class="attribute">selectorTimeout</span>=<span class="string">"5000"</span></span><br><span class="line">              <span class="attribute">maxThreads</span>=<span class="string">"6"</span>/&amp;gt</span><br><span class="line"></span><br><span class="line">    &amp;ltSender <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.transport.ReplicationTransmitter"</span>&amp;gt</span><br><span class="line">      &amp;ltTransport <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.transport.nio.PooledParallelSender"</span>/&amp;gt</span><br><span class="line">    &amp;lt/Sender&amp;gt</span><br><span class="line">    &amp;ltInterceptor <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"</span>/&amp;gt</span><br><span class="line">    &amp;ltInterceptor <span class="attribute">className</span>=<span class="string">"org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"</span>/&amp;gt</span><br><span class="line">  &amp;lt/Channel&amp;gt</span><br><span class="line"></span><br><span class="line">  &amp;ltValve <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.tcp.ReplicationValve"</span></span><br><span class="line">         <span class="attribute">filter</span>=<span class="string">""</span>/&amp;gt</span><br><span class="line">  &amp;ltValve <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.session.JvmRouteBinderValve"</span>/&amp;gt</span><br><span class="line"></span><br><span class="line">  &amp;ltDeployer <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.deploy.FarmWarDeployer"</span></span><br><span class="line">            <span class="attribute">tempDir</span>=<span class="string">"/tmp/war-temp/"</span></span><br><span class="line">            <span class="attribute">deployDir</span>=<span class="string">"/tmp/war-deploy/"</span></span><br><span class="line">            <span class="attribute">watchDir</span>=<span class="string">"/tmp/war-listen/"</span></span><br><span class="line">            <span class="attribute">watchEnabled</span>=<span class="string">"false"</span>/&amp;gt</span><br><span class="line"></span><br><span class="line">  &amp;ltClusterListener <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.session.ClusterSessionListener"</span>/&amp;gt</span><br><span class="line">&amp;lt/Cluster&amp;gt</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;将官网上的这段集群配置，插入到两个tomcat服务器中我们创建的host标签中（也可插入引擎标签中，就相当于所有主机都生效），即<code>&amp;ltHost name</code>标签与<code>&amp;lt/Host&amp;gt</code>标签的中间。<br>&emsp;&emsp;配置说明：<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Cluster</span> <span class="string">集群配置</span></span><br><span class="line"><span class="attr">Manager</span> <span class="string">会话管理器配置</span></span><br><span class="line"><span class="attr">Channel</span> <span class="string">信道配置</span></span><br><span class="line">        <span class="attr">Membership</span> <span class="string">成员判定。使用什么多播地址、端口多少、间隔时长ms、超时时长ms。同一个多播地址和端口认为同属一个组。使用时修改这个多播地址，以防冲突</span></span><br><span class="line">        <span class="attr">Receiver</span> <span class="string">接收器，多线程接收多个其他节点的心跳、会话信息。默认会从4000到4100依次尝试可用端口。</span></span><br><span class="line">        <span class="attr">address</span>=<span class="string">"auto"，auto可能绑定到127.0.0.1上，所以一定要改为可以用的IP上去</span></span><br><span class="line">        <span class="attr">Sender</span> <span class="string">多线程发送器，内部使用了tcp连接池。</span></span><br><span class="line">        <span class="attr">Interceptor</span> <span class="string">拦截器</span></span><br><span class="line"><span class="attr">ReplicationValve</span> <span class="string">检测哪些请求需要检测Session，Session数据是否有了变化，需要启动复制过程</span></span><br><span class="line"><span class="attr">ClusterSessionListener</span> <span class="string">集群session侦听器</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;复制完官方文档里的配置，我们还需要修改接收器的ip为本机ip，不能使用<code>auto</code>，否则会无法同步session信息。<br>&emsp;&emsp;此外，还需要在应用的web.xml文件中最后一行<code>&amp;lt/web-app&amp;gt</code>标签的上面一行插入子标签<code>&amp;ltdistributable/&amp;gt</code>表示可分配。<br>&emsp;&emsp;操作如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/data/</span>myapp<span class="regexp">/ROOT/</span>WEB-INF</span><br><span class="line">cp <span class="regexp">/apps/</span>tomcat<span class="regexp">/conf/</span>web.xml <span class="regexp">/data/</span>myapp<span class="regexp">/ROOT/</span>WEB-INF/</span><br><span class="line">sed -i <span class="string">'/&amp;lt\/web-app&amp;gt/i&amp;ltdistributable/&amp;gt'</span> <span class="regexp">/data/</span>myapp<span class="regexp">/ROOT/</span>WEB-INF/web.xml</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时，如果我们将前端Nginx或者其他反向代理服务器中的源地址hash去掉，我们就可以看到，虽然访问的tomcat服务器在变化（服务器ip变化），而sessionID却是不变的，因为每个tomcat服务器上都有全量的相同的session信息。<br><img src="https://img-blog.csdnimg.cn/2019112217482979.gif" alt="集群tomcat"></p><h3 id="session-共享服务器"><a href="#session-共享服务器" class="headerlink" title="session 共享服务器"></a>session 共享服务器</h3><p>&emsp;&emsp;这种实现方式其实才是本文标题中真正的session共享，毕竟共享经济炒的很热，我们都知道，所谓共享，共用才叫共享，前面提到的那种tomcat集群里会话信息人手一份可不能称作是共享。于是乎，我们想到用将session放到外部存储，所有的tomcat服务器都去外部存储中去查找sessionID。<br>&emsp;&emsp;储存session信息肯定不能存储在磁盘文件中，这样的读取写入性能都会很慢，放在mysql数据库中或者以硬盘文件的方式保存，高并发场景下的读取写入速度都将会大打折扣。所以我们要使用类似memcached或者redis这种Key/Value的非关系型数据库里，也被称作NoSQL。<br>&emsp;&emsp;memcached和redis这种键值对型数据库的数据信息都是存储在内存中的，读写效率都很高，而且由于没有复杂的表关系，采用的是哈希算法，他们对于信息的查找都是O(1)，而不是类似mysql等数据库的O(n)，意思就是说耗时/耗空间与总数据量大小无关，不会随着数据量的增大导致查找时间几何倍数的增长。<br>&emsp;&emsp;但也因为memcached和redis的数据都是储存在内存中的，而且memcached还不支持持久化，所以我们一定要做好高可用，一旦发生故障，会话信息将立即丢失，几乎没有恢复的可能。<br>&emsp;&emsp;要实现tomcat共享session服务器，首先，我们要让tomcat将session储存到memcached或者redis等外部存储上，这就需要我们对tomcat进行配置，其次我们要将session信息序列化为变为字节流以便能储存在session服务器中，还要能将session服务器中的数据反序列化为可以识别的session信息，最后，当然我们还需要一个客户端来跟后端的session服务器通信，才能将数据写入和读取。<br>&emsp;&emsp;这想实现确实也比较复杂，不过在github已有开源解决方案（网址是<a href="https://github.com/magro/memcached-session-manager" rel="noopener" target="_blank">https://github.com/magro/memcached-session-manager</a>），memcached-session-manager，简称msm，后端采用memcached或者redis都可以（之前只支持memcached，因而得名msm，后来支持redis后，人们还是习惯叫它msm），且已经完成了对tomcat的session共享的配置支持（支持tomcat6.X、7.X、8.X、9.X），我们直接去下载对应版本的去使用就可以了。<br>&emsp;&emsp;根据项目的介绍文档，我们知道，想实现tomcat的session共享，我们至少需要配套的工具有：</p><ul><li>tomcat的session管理工具 memcached-session-manager</li><li>与session服务器通信的客户端<br>如果是memcached，则建议使用spymemcached.jar<br>如果是redis，则建议使用jedis.jar</li><li>将session信息序列化的工具，作者推荐使用kryo。</li></ul><p>&emsp;&emsp;这些工具官网上也都提供了下载链接，我们直接下载下来即可。<br>&emsp;&emsp;kryo如下图所示<br><img src="https://img-blog.csdnimg.cn/20191122212611125.png" alt="kryo"><br>&emsp;&emsp;其他工具包如下图所示<br><img src="https://img-blog.csdnimg.cn/20191122212642803.png" alt="msm"><br>&emsp;&emsp;将这些jar包统统拷贝到tomcat服务器的lib目录下（改变lib目录下的jar包需重启tomcat服务才能生效）<br>&emsp;&emsp;使用msm搭建session共享服务器，如果后端为memcached，则有两种模式可以选，分别是sticky模式和non-sticky模式，后端为redis，则使用类似non-sticky模式。</p><h4 id="sticky模式"><a href="#sticky模式" class="headerlink" title="sticky模式"></a>sticky模式</h4><p>&emsp;&emsp;以两台服务器为例，将tomcat1和memcached1部署在一台服务器上（简称为t1、m1），tomcat2和memcached2部署在另一台服务器上（简称为t2、m2）为例，结构图如下图所示。<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;ltt1</span><span class="variable">&amp;gt</span>   <span class="variable">&amp;ltt2</span><span class="variable">&amp;gt</span></span><br><span class="line">  . \ / .</span><br><span class="line">  .  <span class="meta">X</span>  .</span><br><span class="line">  . / \ .</span><br><span class="line"><span class="variable">&amp;ltm1</span><span class="variable">&amp;gt</span>   <span class="variable">&amp;ltm2</span><span class="variable">&amp;gt</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;实现原理：当请求结束时Tomcat的session会送给memcached备份。即Tomcat session为主session，memcached session为备session，使用memcached相当于备份了一份Session。查询Session时Tomcat会优先使用自己内存的Session，Tomcat通过jvmRoute发现不是自己的Session，便从memcached中找到该Session，更新本机Session，请求完成后更新memcached。<br>&emsp;&emsp;可能有的朋友看的一头雾水，这到底是个什么结构。其实很简单，sticky模式就是t1的session信息还是储存在t1上，不过以m2为备用数据库，t2的session信息也是放在t2中储存，以m1服务器为备用服务器。这就意味着，用户在访问t1时，是从t1获取session信息，当t1挂掉或者整个节点1服务器挂掉之后，用户会被调度到t2上，而t2本地中没有session信息时，就会去m2中上找相关sessionID，而m2因为是t1的备用存储，所以有跟t1完全相同的session信息，于是用户的sessionID就可以被t2识别；而当m2备用存储服务挂掉之后，t1服务会通过检测发现自己没有备用存储，就会自动将m1也指定为自己的备用存储，将备份信息也同步至m1中，于是用户若再从t2访问时，虽然因为m2挂掉，其中的数据都无法访问，但t2就可以从m1上读取到对应的sessionID并同步到t2本身的存储中，也可以保持之前的会话信息。<br>&emsp;&emsp;修改的配置也很简单，依照官网说明，将下面的代码标签插入<code>/conf/context.xml</code>文件中的<code>context标签</code>结尾就可以了<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;ltManager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span><br><span class="line">memcachedNodes=<span class="string">"n1:192.168.32.231:11211,n2:192.168.32.232:11211"</span></span><br><span class="line">failoverNodes=<span class="string">"n1"</span></span><br><span class="line">requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span></span><br><span class="line">/&amp;gt</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;n1、n2只是memcached的节点别名，可以重新命名。<br>failoverNodes是指故障转移节点，也就是发生故障之后的备用节点，所以在n1节点上，n1是备用节点，n2是主存储节点。另一台Tomcat中配置将failoverNodes改为n2，意思是其主节点是n1，备用节点是n2。<br>若配置成功，在/apps/tomcat/log/catalina.out文件中看到如下信息。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n <span class="number">20</span> /apps/tomcat/logs/catalina.<span class="keyword">out</span></span><br></pre></td></tr></table></figure></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">23-Nov-2019 13:35:54.187 INFO [myapp-startStop-1] de.javakaffee.web.msm.MemcachedSessionService.startInternal --------</span><br><span class="line"><span class="bullet">-  </span>finished initialization:</span><br><span class="line"><span class="bullet">- </span>sticky: true</span><br><span class="line"><span class="bullet">- </span>operation timeout: 1000</span><br><span class="line"><span class="bullet">- </span>node ids: [n1]</span><br><span class="line"><span class="bullet">- </span>failover node ids: [n2]</span><br><span class="line"><span class="bullet">- </span>storage key prefix: null</span><br><span class="line"><span class="bullet">- </span>locking mode: null (expiration: 5s)</span><br><span class="line">--------</span><br></pre></td></tr></table></figure><p>此时在访问我们的前端代理（取消ipHASH绑定）就会看到下面界面，将节点2 关机，可以看到访问ip固定为192.168.32.231，而使用的memcached变成了n1节点。<br><img src="https://img-blog.csdnimg.cn/20191123194433405.gif" alt="tomcatsticky"></p><h4 id="non-sticky模式"><a href="#non-sticky模式" class="headerlink" title="non-sticky模式"></a>non-sticky模式</h4><p>&emsp;&emsp;从msm 1.4.0之后开始支持non-sticky模式。<br>Tomcat session为中转Session，如果n1为主session，n2为备session，则产生的新的Session会发送给主、备memcached，并清除本地Session，也就是说tomcat本身不储存session信息，只负责产生session。<br>&emsp;&emsp;需要注意的是，如果n1下线，n2转换为主节点。n1再次上线，n2依然是主Session存储节点。<br>&emsp;&emsp;配置方法与sticky大致相同，不过在<code>/conf/context.xml</code>文件中的<code>context标签</code>结尾插入代码略有不同，具体代码如下<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;ltManager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span><br><span class="line">memcachedNodes=<span class="string">"n1:192.168.32.231:11211,n2:192.168.32.232:11211"</span></span><br><span class="line">sticky=<span class="string">"false"</span></span><br><span class="line">sessionBackupAsync=<span class="string">"false"</span></span><br><span class="line">lockingMode=<span class="string">"uriPattern:/path1|/path2"</span></span><br><span class="line">requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span></span><br><span class="line">/&amp;gt</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;重启tomcat服务后生效。此时在/apps/tomcat/log/catalina.out文件中看到如下信息。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n <span class="number">20</span> /apps/tomcat/logs/catalina.<span class="keyword">out</span></span><br></pre></td></tr></table></figure></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">23-Nov-2019 13:43:05.863 INFO [myapp-startStop-1] de.javakaffee.web.msm.MemcachedSessionService.startInternal --------</span><br><span class="line"><span class="bullet">-  </span>finished initialization:</span><br><span class="line"><span class="bullet">- </span>sticky: false</span><br><span class="line"><span class="bullet">- </span>operation timeout: 1000</span><br><span class="line"><span class="bullet">- </span>node ids: [n1, n2]</span><br><span class="line"><span class="bullet">- </span>failover node ids: []</span><br><span class="line"><span class="bullet">- </span>storage key prefix: null</span><br><span class="line"><span class="bullet">- </span>locking mode: uriPattern:/path1|/path2 (expiration: 5s)</span><br><span class="line">--------</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次尝试访问负载代理服务器，发现同样实现了访问tomcatIP变化，sessionID不变，说明配置成功。<br>&emsp;&emsp;而后端使用redis作为session共享服务器时，仅支持non-stricky模式。建议用另外的服务器安装redis服务，并修改监听IP后启动，tomcat服务器中将<code>jedis.jar</code>jar包拷贝至tomcat安装路径下<code>lib目录</code>，同样在<code>/conf/context.xml</code>文件中的<code>context标签</code>结尾插入下面的代码即可（例如redis服务器IP端口为192.168.32.233:6379，可配置redis集群，可参考我之前博客<a href="https://hewanyue.com/blog/14b8983d.html" rel="noopener" target="_blank">redis高可用配置</a>）。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;ltManager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span><br><span class="line">memcachedNodes=<span class="string">"redis://192.168.32.233:6379"</span></span><br><span class="line">sticky=<span class="string">"false"</span></span><br><span class="line">sessionBackupAsync=<span class="string">"false"</span></span><br><span class="line">lockingMode=<span class="string">"uriPattern:/path1|/path2"</span></span><br><span class="line">requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span></span><br><span class="line">/&amp;gt</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;tomcat作为一个应用服务器，单机性能上都是无法满足生产中需要的，而想要解决高并发场景，光靠提升单机性能，成本与效果肯定都是无法让人接受的，而此时我们一般都采用tomcat集群的方式，用多台tomcat服务器来共同支撑我们的业务。&lt;br&gt;&amp;emsp;&amp;emsp;但这时就出现了一个新的问题，那就是会话保持。因为每台tomcat服务器的session是独立的，当客户端被调度到一个新的tomcat服务器时，他无法识别之前一台的tomcat服务器分配的sessionID，于是对于此次访问，之前的会话信息就都没有了，这表现在用户的客户端就相当于，点开一个新的链接，就发现需要重新登陆，或者之前的购物车里的商品都不见了等等。这样的客户访问体验绝对不是我们想要的，所以我们需要实现会话保持功能！&lt;br&gt;
    
    </summary>
    
      <category term="tomcat" scheme="https://wudihechao.github.io/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="https://wudihechao.github.io/tags/tomcat/"/>
    
      <category term="redis" scheme="https://wudihechao.github.io/tags/redis/"/>
    
      <category term="集群" scheme="https://wudihechao.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="MSM" scheme="https://wudihechao.github.io/tags/MSM/"/>
    
      <category term="session" scheme="https://wudihechao.github.io/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>linux上部署与配置tomcat</title>
    <link href="https://wudihechao.github.io//blog/b365780e.html"/>
    <id>https://wudihechao.github.io//blog/b365780e.html</id>
    <published>2019-11-21T10:58:03.000Z</published>
    <updated>2019-11-22T01:54:03.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。本文将详细讲解tomcat在linux环境(以CentOS为例)中的安装与配置。<br><a id="more"></a></p><h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><p>&emsp;&emsp;JDK是java Development Kit的缩写，即java语言的软件开发包，是javac、javap、jdb等开发、调试、编译工具。<br>&emsp;&emsp;OpenJDK是Sun公司采用GPL v2协议发布的JDK开源版本，可以用于商业用途，于2009年正式发布。它是基于JDK7的beta版开发，但为了也将java SE 6开源，从OpenJDK7的b20构建反向分之开发，从中剥离了不符合java SE 6规范的代码，发布了OpenJDK 6。所以OpenJDK6和JDK6没有关系。<br>&emsp;&emsp;在CentOS中，可以选择yum安装openjdk<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java<span class="number">-1.8</span><span class="number">.0</span>-openjdk</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过<code>java -version</code>可以看到版本信息为<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="string">"1.8.0_212"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8,0_212-b04)</span><br><span class="line">OpenJDK 64-Bit<span class="built_in"> Server </span>VM (build 25.212-b04,mixed mode)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以去Oracle官网下载JDK 8的rpm包安装（需要注册）<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jdk<span class="number">-8</span>u191-linux-x64,rpm</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;而通过<code>java -version</code>看到版本信息为<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  java -version</span><br><span class="line">java version <span class="string">"1.8.0_231"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_231-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 25.231-b11, mixed mode)</span><br></pre></td></tr></table></figure></p><h3 id="部署tomcat"><a href="#部署tomcat" class="headerlink" title="部署tomcat"></a>部署tomcat</h3><p>&emsp;&emsp;确定JDK版本之后，我们就可以准备开始部署tomcat了。<br>&emsp;&emsp;首先要去<a href="https://tomcat.apache.org/" rel="noopener" target="_blank">官网</a>下载源码包，国内用的是清华大学的镜像下载地址，下载速度还是可以接受的。<br>&emsp;&emsp;生产中我们一般不会选用最新版的tomcat9，而是选用tomcat8更为稳妥。tomcat8的下载链接是<a href="http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.47/bin/apache-tomcat-8.5.47.tar.gz" rel="noopener" target="_blank">http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.47/bin/apache-tomcat-8.5.47.tar.gz</a><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/apache/</span>tomcat<span class="regexp">/tomcat-8/</span>v8.<span class="number">5.47</span><span class="regexp">/bin/</span>apache-tomcat-<span class="number">8.5</span>.<span class="number">47</span>.tar.gz</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;解压到想要安装的任意指定目录，例如<code>/apps/tomcat/</code>目录<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf apache-tomcat-<span class="number">8.5</span>.<span class="number">47</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span> -C /apps/</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;更改目录名称(也可以用软连接方式)。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /apps/apache-tomcat<span class="number">-8.5</span><span class="number">.47</span> /apps/tomcat</span><br></pre></td></tr></table></figure></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>&emsp;&emsp;jdk需要配置环境变量才可以找到，否则会无法访问jsp文件。<br>&emsp;&emsp;需要在环境变量配置文件中加入<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/usr/java/default</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;于是，运行下面命令即可<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/profile.d/jdk.sh &lt;&lt;<span class="string">"END"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/usr/java/default</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>/bin:$PATH</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;运行命令使环境变量生效<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. /etc/<span class="keyword">profile</span>.d/jdk.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p><h3 id="修改进程属主"><a href="#修改进程属主" class="headerlink" title="修改进程属主"></a>修改进程属主</h3><p>&emsp;&emsp;一般来说，tomcat服务如果以root身份启动，风险还是很高的，因为tomcat本身bug还是有不少的，如果被别有用心之人加以利用，入侵进来，就可以获得root权限，这造成的后果绝对是灾难级的，这甚至会威胁到其他服务器的安全。为了规避这一风险，我们一般都会将tomcat服务以一个系统用户的身份启动，例如java用户。<br>&emsp;&emsp;创建java用户<code>useradd -r java</code><br>&emsp;&emsp;更改服务目录的属主属组<code>chown -R tomcat/*</code><br>&emsp;&emsp;启动服务时，我们使用命令<code>su - java -c &#39;/apps/tomcat/bin/startup.sh&#39;</code>来启动，就可以以java用户的身份来启动进程了。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>&emsp;&emsp;tomcat中配置文件目录在tomcat/conf/server.xml,其中需要注意的是：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server <span class="attribute">port</span>=<span class="string">"8005"</span> <span class="attribute">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这代表管理端监听在8005端口，向管理端发送<code>SHUTDOWN</code>指令就会是tomcat直接终止，而且这是不需要密码权限控制的。如果在生产环境中，如果有任何人有意或者无意向tomcat服务器的8005端口发送了SHUTDOWN指令，整个服务都会被终止掉，，而且还不需要密码验证，这对我们的影响无疑是巨大的，所以我们通常都会将此处的管理监听端口改掉，或将shutdown指令设为别的复杂口令，让别人无法轻易或不小心将我们的服务器shutdown~<br>&emsp;&emsp;可采取MD5值的方式，选任一文件做MD5运算后得到的随机数值即为口令。<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s@SHUTDOWN@`md5sum /root/.ssh/authorized_keys |cut -d' ' -f1`@"</span> tomcat/conf/server.xml</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时，就可以通过安装目录下的<code>tomcat/bin/startup.sh</code>来启动tomcat服务了。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">su</span> - java -c <span class="string">' /apps/tomcat/bin/startup.sh'</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后查看端口<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ss -tanl</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;即可看到8080端口已经处于监听状态了<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# ss -tanl</span><br><span class="line">State       Recv-Q Send-Q                     Local Address:Port                                    Peer Address:Port              </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">128</span>                                    *:<span class="number">22</span>                                                 *:*                  </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">100</span>                            <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">25</span>                                                 *:*                  </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">100</span>                                   :::<span class="number">8009</span>                                              :::*                  </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">100</span>                                   :::<span class="number">8080</span>                                              :::*                  </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">128</span>                                   :::<span class="number">22</span>                                                :::*                  </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">100</span>                                  ::<span class="number">1</span>:<span class="number">25</span>                                                :::*                  </span><br><span class="line">LISTEN      <span class="number">0</span>      <span class="number">1</span>                       ::ffff:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8005</span>                                              :::*                  </span><br><span class="line">[<span class="symbol">root@</span>localhost ~]#</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;访问tomcat服务器的ip的8080端口，可看到如下图所示界面，即表示tomcat安装成功。<br><img src="https://img-blog.csdnimg.cn/20191121170929214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;不过，想使用tomcat自带的Manager App及Host Manager工具，还需要做一些额外的配置,此时如果直接访问会显示403权限拒绝，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20191121192147674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="修改应用访问控制"><a href="#修改应用访问控制" class="headerlink" title="修改应用访问控制"></a>修改应用访问控制</h4><p>&emsp;&emsp;错误提示说明已经说得很明白了，首先确保已经修改了应用的反问控制权限，，如果还没有，you’ll need to edit the Manager’s <code>context.xml</code> file。<br>&emsp;&emsp;那这个context.xml在哪里呢？它是指应用的上下文设置文件，路径就是tomcat目录下的<code>webapps/manager/META-INF/context.xml</code>文件，另一个应用Host Manager的路径就是tomcat目录下的<code>webapps/host-manager/META-INF/context.xml</code><br>&emsp;&emsp;所以我们要修改这两个配置文件中的访问控制，将我们的访问IP加到里面，这样我们的访问IP才有权限去访问这两个管理应用。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context <span class="attribute">antiResourceLocking</span>=<span class="string">"false"</span> <span class="attribute">privileged</span>=<span class="string">"true"</span> &gt;</span><br><span class="line">  &lt;Valve <span class="attribute">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span></span><br><span class="line">         <span class="attribute">allow</span>=<span class="string">"127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|172.18.*|192.168.32.*"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在<code>allow=</code>标签后面，加上我们的ip，支持通配符写法和PCRE格式的正则表达式写法，用<code>|</code>隔开。两个应用的配置文件都要修改。</p><h4 id="创建权限角色"><a href="#创建权限角色" class="headerlink" title="创建权限角色"></a>创建权限角色</h4><p>光将我们的来访IP加入许可白名单还是不够的，我们还需要一个有权限的账户才可以访问这些管理工具<br>路径是tomcat目录下的<code>conf/tomcat-users.xml</code>文件。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;tomcat-users <span class="attribute">xmlns</span>=<span class="string">"http://tomcat.apache.org/xml"</span></span><br><span class="line">              xmlns:<span class="attribute">xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">              xsi:<span class="attribute">schemaLocation</span>=<span class="string">"http://tomcat.apache.org/xml tomcat-users.xsd"</span></span><br><span class="line">              <span class="attribute">version</span>=<span class="string">"1.0"</span>&gt;</span><br><span class="line">    &lt;role <span class="attribute">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span><br><span class="line">    &lt;role <span class="attribute">rolename</span>=<span class="string">"admin-gui"</span>/&gt;</span><br><span class="line">    &lt;user <span class="attribute">username</span>=<span class="string">"admin"</span> <span class="attribute">password</span>=<span class="string">"123456"</span> <span class="attribute">roles</span>=<span class="string">"manager-gui,admin-gui"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在下面加入后三行，先创建角色<code>&quot;manager-gui&quot;</code>和<code>&quot;admin-gui&quot;</code>,分别是Manager App的管理员和Host Manager的管理员。然后设置用户名密码及其所处的角色，也可以设置两个不同的用户来分别充当这两个角色。用户名密码可自行设置。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;role <span class="attribute">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span><br><span class="line">&lt;role <span class="attribute">rolename</span>=<span class="string">"admin-gui"</span>/&gt;</span><br><span class="line">&lt;user <span class="attribute">username</span>=<span class="string">"admin"</span> <span class="attribute">password</span>=<span class="string">"123456"</span> <span class="attribute">roles</span>=<span class="string">"manager-gui,admin-gui"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;有了管理员权限的账户，在被允许的客户端上就可以访问<code>Manager App</code>和<code>Host Manager</code>这两个工具了。点击图标访问，出现如下图所示的提示输入用户名密码弹窗，说明配置正确。<br><img src="https://img-blog.csdnimg.cn/20191121185100783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2VQcm8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="附-一键部署tomcat脚本"><a href="#附-一键部署tomcat脚本" class="headerlink" title="附:一键部署tomcat脚本"></a>附:一键部署tomcat脚本</h3><p>&emsp;&emsp;附上我自己用的tomcat脚本供大家参考(未配置管理工具)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DST=<span class="string">"/apps"</span></span><br><span class="line">[ -a jdk-8u231-linux-x64.rpm ] || &#123; <span class="built_in">echo</span> <span class="string">' the absence of jdk'</span> ;<span class="built_in">exit</span> 1;&#125;</span><br><span class="line">[ -d <span class="variable">$DST</span>/*tomcat* ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"tomcat is aready installed into <span class="variable">$DST</span>/tomcat"</span> ;<span class="built_in">exit</span> 2;&#125;</span><br><span class="line">id java &amp;&gt;/dev/null &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">'user java is exist,redis is aready installed'</span> ; <span class="built_in">exit</span> 3;&#125;</span><br><span class="line">iptables -F</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">sed -i <span class="string">'@SELINUX=enforcing@SELINUX=disabled@'</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line">mkdir -p /data<span class="variable">$DST</span></span><br><span class="line"><span class="comment">#mkdir -p $DST</span></span><br><span class="line">ln -s /data<span class="variable">$DST</span> <span class="variable">$DST</span></span><br><span class="line">yum install jdk-8u231-linux-x64.rpm</span><br><span class="line">tar xf *tomcat-*.tar.* -C <span class="variable">$DST</span>/</span><br><span class="line">mv <span class="variable">$DST</span>/*tomcat-* <span class="variable">$DST</span>/tomcat</span><br><span class="line">sed -i <span class="string">"s@SHUTDOWN@`md5sum /root/.ssh/authorized_keys |cut -d' ' -f1`@"</span> <span class="variable">$DST</span>/tomcat/conf/server.xml</span><br><span class="line">cat &gt; /etc/profile.d/jdk.sh &lt;&lt;<span class="string">"END"</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/default</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">END</span><br><span class="line">. /etc/profile.d/jdk.sh</span><br><span class="line">useradd -r java</span><br><span class="line">chown -R java.java <span class="variable">$DST</span>/tomcat/*</span><br><span class="line">su - java -c <span class="string">'$DST/tomcat/bin/startup.sh'</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。本文将详细讲解tomcat在linux环境(以CentOS为例)中的安装与配置。&lt;br&gt;
    
    </summary>
    
      <category term="tomcat" scheme="https://wudihechao.github.io/categories/tomcat/"/>
    
    
      <category term="linux" scheme="https://wudihechao.github.io/tags/linux/"/>
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="tomcat" scheme="https://wudihechao.github.io/tags/tomcat/"/>
    
      <category term="一键安装" scheme="https://wudihechao.github.io/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"/>
    
      <category term="JAVA" scheme="https://wudihechao.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>redis高可用配置</title>
    <link href="https://wudihechao.github.io//blog/14b8983d.html"/>
    <id>https://wudihechao.github.io//blog/14b8983d.html</id>
    <published>2019-11-15T08:19:19.000Z</published>
    <updated>2019-12-04T02:03:05.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;redis高可用一般有两种方式实现：哨兵和集群。在哨兵 sentinel 机制中，可以解决 redis 高可用的问题， 即当 master 故障后可以自动将 slave 提升为 master 从而可以保证 redis 服务的正常使用，但是无法解决 redis 单机写入的瓶颈问题， 即单机的 redis 写入性能受限于单机的内存大小、 并发数量、 网卡速率等因素。<br>&emsp;&emsp;redis 官方在 redis 3.0 版本之后推出了无中心架构的 redis cluster机制， 在无中心的 redis 集群当中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接， 特点如下：<br><a id="more"></a><br>&emsp;&emsp;1：所有 Redis 节点使用(PING 机制)互联。<br>&emsp;&emsp;2：集群中某个节点的失效， 是整个集群中超过半数的节点监测都失效才算真正的失效（类似Sdown和Odown） 。<br>&emsp;&emsp;3：客户端不需要 proxy 即可直接连接 redis， 应用程序需要写全部的 redis 服务器 IP。<br>&emsp;&emsp;4：redis cluster 把所有的 redis node 映射到 0-16383 个槽位(slot)上， 读写需要到指定的 redis node 上进行操作，因此有多少个 reids node 相当于 redis 并发扩展了多少倍。<br>&emsp;&emsp;5：Redis cluster 预先分配 16384 个(slot)槽位，当需要在 redis 集群中写入一个 key -value 的时候，会使用 CRC16(key) mod 16384 之后的值，决定将 key 写入值哪一个槽位从而决定写入哪一个 Redis 节点上， 从而有效解决单机瓶颈。</p><h3 id="Sentinel-哨兵"><a href="#Sentinel-哨兵" class="headerlink" title="Sentinel(哨兵)"></a>Sentinel(哨兵)</h3><h4 id="手动配置主从"><a href="#手动配置主从" class="headerlink" title="手动配置主从"></a>手动配置主从</h4><p>&emsp;&emsp;需要手动先指定某一台 Redis 服务器为 master，然后将其他 slave 服务器修改配置文件或使用命令配置为 master 服务器的 slave。哨兵的前提是已经手动实现了一个 redis master-slave 的运行环境。<br>&emsp;&emsp;例如我们将192.168.32.81上的redis服务设置为master，192.168.32.82、192.168.32.83设置为slave，192.168.32.81中配置文件masterauth 设置为123456<br>&emsp;&emsp;在192.168.32.82上设置主节点信息<code>SLAVEOF 192.168.32.81 6379</code>(redis5版本命令为<code>REPLICAOF 192.168.7.101 6379</code>)<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.82:6379&gt; SLAVEOF 192.168.32.81 6379</span><br><span class="line">OK</span><br><span class="line">192.168.32.82:6379&gt;<span class="built_in"> CONFIG </span><span class="builtin-name">SET</span> masterauth <span class="string">"123456"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;同样,192.168.32.83也要设置主节点信息及密码<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.7.103:6379&gt; SLAVEOF 192.168.7.101 6379</span><br><span class="line">OK</span><br><span class="line">192.168.7.103:6379&gt;<span class="built_in"> CONFIG </span><span class="builtin-name">SET</span> masterauth <span class="string">"123456"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;此时通过<code>info Replication</code>命令，在两个从节点上可以看到角色已变更为slave,且<code>master_link_status</code>状态要为up，说明主从结构配置完成。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; info Replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:<span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span></span><br><span class="line">master_port:<span class="number">6379</span></span><br><span class="line">master_link_status:up</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的是：不同的 redis 版本之间存在兼容性问题， 因此各 master 和 slave 之间必须保持版本一致，且redis slave 也要开启持久化并设置和 master 同样的连接密码，此外，如果开启了安全模式，未设置密码的话也会导致主从无法连接。</p><h4 id="配置Sentinel"><a href="#配置Sentinel" class="headerlink" title="配置Sentinel"></a>配置Sentinel</h4><p>&emsp;&emsp;哨兵可以不和 Redis 服务器部署在一起。可以使用另外不同的机子，一般采用单数个哨兵（至少3个）。不过为了节约服务器，我们还是和redis服务器部署到一起。<br>&emsp;&emsp;3个机子都手动添加Sentinel配置文件<br>&emsp;&emsp;<code>vim /apps/redis/etc/sentinel.conf</code><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"redis-sentinel.pid"</span></span><br><span class="line">logfile <span class="string">"sentinel_26379.log"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis"</span></span><br><span class="line">sentinel monitor mymaster <span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span> <span class="number">6379</span> <span class="number">2</span> #法定人数限制(quorum)，即有几个slave 认为 master down 了就进行故障转移</span><br><span class="line">sentinel auth-pass mymaster <span class="number">123456</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span> #(SDOWN)主观下线的时间</span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span> #发生故障转移时候同时向新 master 同步数据的slave 数量， 数字越小总同步时间越长</span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span> #所有 slaves 指向新的 master 所需的超时时间</span><br><span class="line">sentinel deny-scripts-reconfig yes #禁止修改脚本</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过<code>/apps/redis/bin/redis-sentinel /apps/redis/etc/sentinel.conf</code>命令指定配置文件，启动哨兵，此时通过<code>ss -tanl</code>命令可以看到已监听26379端口，说明哨兵服务已启动。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>CentOS8 ~]# redis-cli -h <span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span> -p <span class="number">26379</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="number">26379</span>&gt; info Sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:<span class="number">1</span></span><br><span class="line">sentinel_tilt:<span class="number">0</span></span><br><span class="line">sentinel_running_scripts:<span class="number">0</span></span><br><span class="line">sentinel_scripts_queue_length:<span class="number">0</span></span><br><span class="line">sentinel_simulate_failure_flags:<span class="number">0</span></span><br><span class="line">master0:name=mymaster,status=ok,address=<span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="number">6379</span>,slaves=<span class="number">2</span>,sentinels=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以通过<code>redis-cli</code>指定26379端口连接哨兵服务器，<code>info Sentinel</code>查看哨兵状态，显示<code>status=ok，slaves=2，sentinels=3</code>，与我们之前设计的相同，说明哨兵服务正常。<br>&emsp;&emsp;此时，当master故障后，哨兵会通过投票机制，选举一个slave作为新的master，继续实现主从结构，而程序应用也会在主从切换的时候收到通知，Jedis 会进行连接的切换（在 JedisPool 中添加了 Sentinel 和MasterName 参数， JRedis Sentinel 底层基于 Redis 订阅实现 Redis 主从服务的切换通知， 当 Reids 发生主从切换时， Sentinel 会发送通知主动通知 Jedis 进行连接的切换， JedisSentinelPool 在每次从连接池中获取链接对象的时候,都要对连接对象进行检测,如果此链接和 Sentinel 的 Master 服务连接参数不一致,则会关闭此连接,重新获取新的 Jedis 连接对象。），实现redis的高可用。</p><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>&emsp;&emsp;在哨兵 sentinel 机制中，可以解决 redis 高可用的问题， 即当 master 故障后可以自动将 slave 提升为 master 从而可以保证 redis 服务的正常使用，但是无法解决 redis 单机写入的瓶颈问题， 即单机的 redis 写入性能受限于单机的内存大小、 并发数量、 网卡速率等因素，所以Redis自带的Cluster就是很好的一个解决方案。</p><h4 id="集群前提"><a href="#集群前提" class="headerlink" title="集群前提"></a>集群前提</h4><p>&emsp;&emsp;1.每个 redis node 节点采用相同的硬件配置、相同的密码、 相同的 redis 版本。<br>&emsp;&emsp;2.每个节点必须开启的参数<br>cluster-enabled yes #必须开启集群状态， 开启后 redis 进程会有 cluster 显示cluster-config-file nodes-6380.conf #此文件有 redis cluster 集群自动创建和维护，不需<br>要任何手动操作<br>&emsp;&emsp;3.所有 redis 服务器必须没有任何数据<br>&emsp;&emsp;4.先启动为单机 redis 且没有任何 key value</p><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><h5 id="Redis-3、4"><a href="#Redis-3、4" class="headerlink" title="Redis 3、4"></a>Redis 3、4</h5><p>&emsp;&emsp;Redis 3 和 4 版本需要使用到集群管理工具 redis-trib.rb，这个工具是 redis 官方推出的管理 redis 集群的工具，集成在 redis 的源码 src 目录下，是基于 redis 提供的集群命令封装成简单、便捷、实用的操作工具， redis-trib.rb 是 redis 作者用 ruby 开发完成的。所以需要有ruby环境，如果系统自带的ruby版本较低（需要Ruby version &gt;= 2.3.0），那就需要重新编译安装更高版本。</p><h6 id="编译安装ruby"><a href="#编译安装ruby" class="headerlink" title="编译安装ruby"></a>编译安装ruby</h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> yum <span class="built_in">remove</span> <span class="keyword">ruby</span> rubygems -<span class="keyword">y</span></span><br><span class="line">wget http<span class="variable">s:</span>//cache.<span class="keyword">ruby</span>-lang.org/pub/<span class="keyword">ruby</span>/<span class="number">2.5</span>/<span class="keyword">ruby</span>-<span class="number">2.5</span>.<span class="number">5</span>.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xf ruby<span class="number">-2.5</span><span class="number">.5</span>.tar.gz</span><br><span class="line">cd ruby<span class="number">-2.5</span><span class="number">.5</span></span><br><span class="line">./configure</span><br><span class="line"> make -j <span class="number">4</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;安装redis的gem包（Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 <a href="http://rubygems.org/" rel="noopener" target="_blank">http://rubygems.org/</a> ）源来查找、安装、升级和卸载软件包，非常的便捷）。<br> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> redis</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;之后就可以使用<code>redis-trib.rb</code>命令来创建管理集群了。</p><h6 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h6><p>&emsp;&emsp;通过命令<code>redis-trib.rb create</code>来创建集群，选项–replicas <arg> 指定 master 的slave数量.<br>&emsp;&emsp;需要注意的是，集群至少也需要3台master，（–replicas 指定的slave数量可以为0，不过一般不建议），如果指定slave数量为2的话就至少需要9个redis服务器了（3主6从），比较浪费资源，所以我们一般设置replicas数值为1。<br>&emsp;&emsp;如果设置<strong>slave数量为0</strong>，则所有的6个服务器均为master，无法实现高可，集群信息如下图所示：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; cluster nodes</span><br><span class="line">c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 <span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573794294000</span> <span class="number">3</span> connected <span class="number">5461</span><span class="number">-8191</span></span><br><span class="line">a13d711b6b54909e5aed44cc8f75195915bbfb95 <span class="number">192.168</span><span class="number">.32</span><span class="number">.85</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573794293235</span> <span class="number">6</span> connected <span class="number">13653</span><span class="number">-16383</span></span><br><span class="line"><span class="number">5</span>d614e18da36f9d7b3536566205281743adc95c5 <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="symbol">6379@</span><span class="number">16379</span> myself,master - <span class="number">0</span> <span class="number">1573794294000</span> <span class="number">1</span> connected <span class="number">0</span><span class="number">-2730</span></span><br><span class="line"><span class="number">6fe42</span>df7ea9c4dbb00d9bae6f7e4238367b1089b <span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573794292212</span> <span class="number">2</span> connected <span class="number">2731</span><span class="number">-5460</span></span><br><span class="line">e3beb9f45b73b265050499ee093ed1a473a3d566 <span class="number">192.168</span><span class="number">.32</span><span class="number">.83</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573794295286</span> <span class="number">4</span> connected <span class="number">8192</span><span class="number">-10922</span></span><br><span class="line"><span class="number">8</span>ae323030e3ae28519a27058c6592b94d1aae734 <span class="number">192.168</span><span class="number">.32</span><span class="number">.84</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573794295000</span> <span class="number">5</span> connected <span class="number">10923</span><span class="number">-13652</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure></arg></p><p>&emsp;&emsp;如果设置slave数量为2，若创建集群是加入的服务器数量不够9台，则<strong>会报错：</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>CentOS8 ~]#redis-trib.rb create --replicas <span class="number">2</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.83</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.84</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.85</span>:<span class="number">6379</span></span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">*** ERROR: Invalid configuration <span class="keyword">for</span> cluster creation.</span><br><span class="line">*** Redis Cluster requires at least <span class="number">3</span> master nodes.</span><br><span class="line">*** This <span class="keyword">is</span> <span class="keyword">not</span> possible with <span class="number">6</span> nodes <span class="keyword">and</span> <span class="number">2</span> replicas per node.</span><br><span class="line">*** At least <span class="number">9</span> nodes are required.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;若之前有创建集群失败的一些操作，或集群中有的redis服务器中有数据信息的话，也是无法创建成功的。会报类似如下如下信息：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/share/gems/gems/redis-<span class="number">4.1</span>.<span class="number">3</span>/<span class="class"><span class="keyword">lib</span>/<span class="title">redis</span>/<span class="title">client</span>.<span class="title">rb</span>:126:<span class="title">in</span> `<span class="title">call</span>': <span class="title">ERR</span> <span class="title">Slot</span> 2823 <span class="title">is</span> <span class="title">already</span> <span class="title">busy</span> (<span class="title">Redis::CommandError</span>)</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以我们一般在创建集群之前，先连上redis服务器清空数据，并重置集群关系，确保所有的redis服务器都没有数据且都为单机master。<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLUSHALL</span><br><span class="line"><span class="keyword">cluster</span> <span class="keyword">reset</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后执行创建集群命令<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas <span class="number">1</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.83</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.84</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.85</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;即可成功创建集群。连接redis，登陆，即可看到集群主从关系。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>CentOS8 ~]#redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; cluster nodes</span><br><span class="line">NOAUTH Authentication required.</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; auth <span class="number">123456</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; cluster nodes</span><br><span class="line">c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 <span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573798716854</span> <span class="number">3</span> connected <span class="number">10923</span><span class="number">-16383</span></span><br><span class="line">a13d711b6b54909e5aed44cc8f75195915bbfb95 <span class="number">192.168</span><span class="number">.32</span><span class="number">.85</span>:<span class="symbol">6379@</span><span class="number">16379</span> slave <span class="number">6fe42</span>df7ea9c4dbb00d9bae6f7e4238367b1089b <span class="number">0</span> <span class="number">1573798715000</span> <span class="number">6</span> connected</span><br><span class="line"><span class="number">5</span>d614e18da36f9d7b3536566205281743adc95c5 <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="symbol">6379@</span><span class="number">16379</span> myself,master - <span class="number">0</span> <span class="number">1573798716000</span> <span class="number">1</span> connected <span class="number">0</span><span class="number">-5460</span></span><br><span class="line"><span class="number">6fe42</span>df7ea9c4dbb00d9bae6f7e4238367b1089b <span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="symbol">6379@</span><span class="number">16379</span> master - <span class="number">0</span> <span class="number">1573798717877</span> <span class="number">2</span> connected <span class="number">5461</span><span class="number">-10922</span></span><br><span class="line"><span class="number">8</span>ae323030e3ae28519a27058c6592b94d1aae734 <span class="number">192.168</span><span class="number">.32</span><span class="number">.84</span>:<span class="symbol">6379@</span><span class="number">16379</span> slave <span class="number">5</span>d614e18da36f9d7b3536566205281743adc95c5 <span class="number">0</span> <span class="number">1573798715834</span> <span class="number">5</span> connected</span><br><span class="line">e3beb9f45b73b265050499ee093ed1a473a3d566 <span class="number">192.168</span><span class="number">.32</span><span class="number">.83</span>:<span class="symbol">6379@</span><span class="number">16379</span> slave c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308 <span class="number">0</span> <span class="number">1573798716000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;监控集群状态<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb<span class="built_in"> check </span>192.168.32.8:6379</span><br></pre></td></tr></table></figure></p><h5 id="Redis-5"><a href="#Redis-5" class="headerlink" title="Redis 5"></a>Redis 5</h5><p>&emsp;&emsp;Redis 5 版本可以直接用redis-cli客户端命令加各种命令参数来管理创建集群(配置文件中如果已配置正确的密码，则不需要-a 选项，-a选项会有warning警告)。<br>&emsp;&emsp;创建集群<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">123456</span> --cluster create --cluster-replicas <span class="number">1</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.83</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.84</span>:<span class="number">6379</span> \</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.85</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;监控集群状态<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 123456 --cluster<span class="built_in"> check </span>192.168.32.8:6379</span><br></pre></td></tr></table></figure></p><h4 id="集群管理维护"><a href="#集群管理维护" class="headerlink" title="集群管理维护"></a>集群管理维护</h4><p>&emsp;&emsp;集群运行时间长久之后，难免由于硬件故障、网络规划、 业务增长等原因对已有集群进行相应的调整， 比如增加 Redis node 节点、 减少节点、 节点迁移、更换服务器等。</p><h5 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h5><p>&emsp;&emsp;同步之前 Redis node 的配置文件到 192.168.32.86 Redis 编译安装目录， 注意修改配置文件的监听 IP。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp redis.conf <span class="number">192.168</span>.<span class="number">32.86</span><span class="symbol">:/apps/redis/etc/</span></span><br><span class="line">scp redis_638<span class="number">0</span>.conf <span class="number">192.168</span>.<span class="number">32.86</span><span class="symbol">:/apps/redis/etc/</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对预备加入的redis服务器清除数据并执行集群重置<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLUSHALL</span><br><span class="line"><span class="keyword">cluster</span> <span class="keyword">reset</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>redis3、4</strong> 中添加节点（Adding node 192.168.32.87:6379 to cluster 192.168.32.8:6379）<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb<span class="built_in"> add-node </span>192.168.32.87:6379 192.168.32.8:6379</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>redis5</strong> 中添加节点（Adding node 192.168.32.87:6379 to cluster 192.168.32.8:6379）<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>192.168.32.87:6379 192.168.32.8:6379</span><br></pre></td></tr></table></figure></p><h5 id="重新分配槽位"><a href="#重新分配槽位" class="headerlink" title="重新分配槽位"></a>重新分配槽位</h5><p>&emsp;&emsp;集群槽位迁移时，迁出的服务器中不能有数据，否则会迁移失败并终止，且<strong>需要修复集群</strong>，才可以进行第二次迁移。<br>&emsp;&emsp;<strong>redis3、4</strong> 中对新加的主机重新分配槽位(后可跟集群中任意主机ip:port):<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis-trib</span><span class="selector-class">.rb</span> <span class="selector-tag">reshard</span> 192<span class="selector-class">.168</span><span class="selector-class">.32</span><span class="selector-class">.8</span><span class="selector-pseudo">:6379</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>redis5</strong> 对新加的主机重新分配槽位(后可跟集群中任意主机ip:port):<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;输入命令后根据提示输入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">How many slots <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">move</span> (<span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">16384</span>)? <span class="number">4096</span>  <span class="comment">#需要迁移多少槽位</span></span><br><span class="line">What <span class="keyword">is</span> the receiving node <span class="keyword">ID</span>? <span class="number">5</span>d614e18da36f9d7b3536566205281743adc95c5 <span class="comment">#选择迁移到哪个redis主机</span></span><br><span class="line">What <span class="keyword">is</span> the receiving node <span class="keyword">ID</span>? <span class="number">6</span>bffc0037eea959f0dcc11aca657f928d86cfc75</span><br><span class="line">Please enter <span class="keyword">all</span> the <span class="keyword">source</span> node IDs.</span><br><span class="line">  <span class="keyword">Type</span> <span class="string">'all'</span> <span class="keyword">to</span> <span class="keyword">use</span> <span class="keyword">all</span> the nodes <span class="keyword">as</span> <span class="keyword">source</span> nodes <span class="keyword">for</span> the <span class="keyword">hash</span> slots.</span><br><span class="line">  <span class="keyword">Type</span> <span class="string">'done'</span> once you entered <span class="keyword">all</span> the <span class="keyword">source</span> nodes IDs.</span><br><span class="line"><span class="keyword">Source</span> node <span class="comment">#1:6bffc0037eea959f0dcc11aca657f928d86cfc75   #选择从哪个主机迁出</span></span><br><span class="line"><span class="keyword">Source</span> node <span class="comment">#2:done             #输入done结束选择</span></span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> proceed <span class="keyword">with</span> the proposed reshard plan (yes/<span class="keyword">no</span>)? yes  <span class="comment">#是否执行，yes确认，之后就会迁移完毕</span></span><br></pre></td></tr></table></figure></p><h5 id="修复集群"><a href="#修复集群" class="headerlink" title="修复集群"></a>修复集群</h5><p>&emsp;&emsp;如果迁移失败，则需要修复集群。</p><p>&emsp;&emsp;<strong>redis3、4</strong> 中对对报错redis服务器进行单独修复(后跟需要修复的主机ip:port):<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis-trib</span><span class="selector-class">.rb</span> <span class="selector-tag">fix</span> 192<span class="selector-class">.168</span><span class="selector-class">.32</span><span class="selector-class">.82</span><span class="selector-pseudo">:6379</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>redis5</strong> 中对对报错redis服务器进行单独修复(后跟需要修复的主机ip:port):<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster fix <span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure></p><h5 id="配置主从关系"><a href="#配置主从关系" class="headerlink" title="配置主从关系"></a>配置主从关系</h5><p>&emsp;&emsp;在整个 Redis cluster 集群中，每个 master 至少有一个 slave。也可以有多个，但是至少要有一个提供数据备份和服务高可用。<br>&emsp;&emsp;<code>redis-trib.rb info 192.168.32.8:6379</code><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>CentOS8 ~]#redis-trib.rb info <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span> (<span class="number">5</span>d614e18...) -&gt; <span class="number">0</span> keys | <span class="number">4096</span> slots | <span class="number">1</span> slaves.</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.82</span>:<span class="number">6379</span> (c65ab2a5...) -&gt; <span class="number">0</span> keys | <span class="number">4096</span> slots | <span class="number">0</span> slaves.</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.81</span>:<span class="number">6379</span> (<span class="number">6fe42</span>df7...) -&gt; <span class="number">0</span> keys | <span class="number">4096</span> slots | <span class="number">1</span> slaves.</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.87</span>:<span class="number">6379</span> (<span class="number">6</span>bffc003...) -&gt; <span class="number">0</span> keys | <span class="number">4096</span> slots | <span class="number">1</span> slaves.</span><br><span class="line"><span class="number">192.168</span><span class="number">.32</span><span class="number">.86</span>:<span class="number">6379</span> (e06732b2...) -&gt; <span class="number">0</span> keys | <span class="number">0</span> slots | <span class="number">0</span> slaves.</span><br><span class="line">[OK] <span class="number">0</span> keys <span class="keyword">in</span> <span class="number">5</span> masters.</span><br><span class="line"><span class="number">0.00</span> keys per slot on average.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们看到之前的3主3从结构因为我们加了两个服务器变成了5主3从，新加的两个服务器，我们需要将它们设置为一主一从来实现高可用。于是我们要将192.168.32.86变为192.168.32.82的slave。<br>&emsp;&emsp;连接登陆192.168.32.86上的redis服务器，先查好192.168。32.82的ID为c65ab2a5e9d8a9435d54f0ef7db302c62b6f9308，执行<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate <span class="keyword">c</span><span class="number">65</span>ab<span class="number">2</span>a<span class="number">5e9</span>d<span class="number">8</span>a<span class="number">9435</span>d<span class="number">54</span>f<span class="number">0</span>ef<span class="number">7</span>db<span class="number">302</span><span class="keyword">c</span><span class="number">62</span>b<span class="number">6</span>f<span class="number">9308</span></span><br></pre></td></tr></table></figure></p><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>&emsp;&emsp;<strong>删除节点，需要先将redis主机上的槽位都迁移到其他主机上才可以操作。</strong><br>&emsp;&emsp;迁移完成后，<strong>redis3、4</strong> 删除节点（要删除的redis主机要写节点号，集群可以写集群中任意主机ip+port）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>CentOS8 ~]#redis-trib.rb del-node <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span> <span class="number">6</span>bffc0037eea959f0dcc11aca657f928d86cfc75</span><br><span class="line">&gt;&gt;&gt; Removing node <span class="number">6</span>bffc0037eea959f0dcc11aca657f928d86cfc75 <span class="keyword">from</span> cluster <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span></span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; SHUTDOWN the node.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>redis5</strong> 删除节点<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node <span class="number">192.168</span><span class="number">.32</span><span class="number">.8</span>:<span class="number">6379</span> <span class="number">6</span>bffc0037eea959f0dcc11aca657f928d86cfc75</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;主节点被删除之后，其之前它的 slave 自动称为了 Redis 集群中其他 master的 slave，此节点如果不需要也可以一并删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;redis高可用一般有两种方式实现：哨兵和集群。在哨兵 sentinel 机制中，可以解决 redis 高可用的问题， 即当 master 故障后可以自动将 slave 提升为 master 从而可以保证 redis 服务的正常使用，但是无法解决 redis 单机写入的瓶颈问题， 即单机的 redis 写入性能受限于单机的内存大小、 并发数量、 网卡速率等因素。&lt;br&gt;&amp;emsp;&amp;emsp;redis 官方在 redis 3.0 版本之后推出了无中心架构的 redis cluster机制， 在无中心的 redis 集群当中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接， 特点如下：&lt;br&gt;
    
    </summary>
    
      <category term="NotOnlySQL" scheme="https://wudihechao.github.io/categories/NotOnlySQL/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="高可用" scheme="https://wudihechao.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="redis" scheme="https://wudihechao.github.io/tags/redis/"/>
    
      <category term="集群" scheme="https://wudihechao.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="Sentinel" scheme="https://wudihechao.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>一键源码编译安装redis</title>
    <link href="https://wudihechao.github.io//blog/f2c1a89e.html"/>
    <id>https://wudihechao.github.io//blog/f2c1a89e.html</id>
    <published>2019-11-13T03:06:46.000Z</published>
    <updated>2019-12-04T02:02:46.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;Redis 和 Memcached 是非关系型数据库也称为 NoSQL 数据库， MySQL、 Mariadb、 SQLServer、 PostgreSQL、 Oracle 数据库属于关系型数据(RDBMS, Relational Database Management System)。<br>&emsp;&emsp;Redis(Remote Dictionary Server)在 2009 年发布， 开发者 Salvatore Sanfilippo 是意大利开发者， 他本想为自己的公司开发一个用于替换 MySQL 的产品 Redis， 但是没有想到他把 Redis 开源后大受欢迎，短短几年， Redis 就有了很大的用户群体，目前国内外使用的公司有知乎&gt;网、新浪微博、 GitHub 等。<br>&emsp;&emsp;redis 是一个开源的、 遵循 BSD 协议的、 基于内存的而且目前比较流行的键值数据库(key-value database)，是一个非关系型数据库，redis 提供将内存通过网络远程共享的一种服务，提供类似功能的还有 memcache，但相比 memcache， redis 还提供了易扩展、高性能、 具备数据持久性等功能。<br>&emsp;&emsp;Redis 在高并发、低延迟环境要求比较高的环境使用量非常广泛， 目前 redis 在 DBEngine 月排行榜 <a href="https://db-engines.com/en/ranking" rel="noopener" target="_blank">https://db-engines.com/en/ranking</a> 中一直比较靠前，而且一直是键值型存储类的首位。<br><a id="more"></a></p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>&emsp;&emsp;redis在centos版本自带的yum源中版本比较低，一般都需要我们编译安装更高版本的redis。</p><h4 id="准备源码包"><a href="#准备源码包" class="headerlink" title="准备源码包"></a>准备源码包</h4><p>&emsp;&emsp;可以先用下载工具去官网下载好源码包，下载链接为 <a href="https://db-engines.com/en/ranking" rel="noopener" target="_blank">https://db-engines.com/en/ranking</a>  。<br>&emsp;&emsp;出于稳定性要求，一般来说实际生产中不会选用最新版的redis，避免因为漏洞造成服务器的安全隐患，所以本次演示，我们选用目前redis4的最新版本，redis-4.0.14来安装。</p><h4 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h4><p>&emsp;&emsp;<code>tar xf redis-4.0.14..tar.gz</code><br>&emsp;&emsp;<code>cd redis-4.0.14</code><br>&emsp;&emsp;编译安装redis的依赖包不多，有make和gcc就够了。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> make gcc -y</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果是最小化安装的新系统，忘记安装gcc的话直接去尝试编译安装redis，就会遇到报错：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make[<span class="number">3</span>]: Entering directory <span class="string">'/root/redis-4.0.14/deps/hiredis'</span></span><br><span class="line">gcc -std=c99 -pedantic -c -O3 -fPIC  -Wall -W -Wstrict-prototypes -Wwrite-<span class="built_in">string</span>s -g -ggdb  net.c</span><br><span class="line">make[<span class="number">3</span>]: gcc: Command <span class="keyword">not</span> found</span><br><span class="line">make[<span class="number">3</span>]: *** [Makefile:<span class="number">156</span>: net.o] Error <span class="number">127</span></span><br><span class="line">make[<span class="number">3</span>]: Leaving directory <span class="string">'/root/redis-4.0.14/deps/hiredis'</span></span><br><span class="line">make[<span class="number">2</span>]: *** [Makefile:<span class="number">46</span>: hiredis] Error <span class="number">2</span></span><br><span class="line">make[<span class="number">2</span>]: Leaving directory <span class="string">'/root/redis-4.0.14/deps'</span></span><br><span class="line">make[<span class="number">1</span>]: [Makefile:<span class="number">180</span>: persist-settings] Error <span class="number">2</span> (ignored)</span><br><span class="line">    CC adlist.o</span><br><span class="line">/bin/sh: cc: command <span class="keyword">not</span> found</span><br><span class="line">make[<span class="number">1</span>]: *** [Makefile:<span class="number">228</span>: adlist.o] Error <span class="number">127</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving directory <span class="string">'/root/redis-4.0.14/src'</span></span><br><span class="line">make: *** [Makefile:<span class="number">9</span>: install] Error <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;提示没装gcc，再回头补上,<code>yum install gcc -y</code>，也还是会报错的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS8 redis-4.0.14]<span class="comment">#make PREFIX=/apps/redis install</span></span><br><span class="line">cd src &amp;&amp; make <span class="keyword">install</span></span><br><span class="line">make[<span class="number">1</span>]: Entering <span class="keyword">directory</span> <span class="string">'/root/redis-4.0.14/src'</span></span><br><span class="line">    CC adlist.o</span><br><span class="line"><span class="keyword">In</span> <span class="keyword">file</span> included <span class="keyword">from</span> adlist.c:<span class="number">34</span>:</span><br><span class="line">zmalloc.h:<span class="number">50</span>:<span class="number">10</span>: fatal <span class="keyword">error</span>: jemalloc/jemalloc.h: <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> <span class="keyword">directory</span></span><br><span class="line"> <span class="comment">#include &lt;jemalloc/jemalloc.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">make[<span class="number">1</span>]: *** [Makefile:<span class="number">228</span>: adlist.o] <span class="keyword">Error</span> <span class="number">1</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving <span class="keyword">directory</span> <span class="string">'/root/redis-4.0.14/src'</span></span><br><span class="line">make: *** [Makefile:<span class="number">9</span>: <span class="keyword">install</span>] <span class="keyword">Error</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这是因为上次的编译失败，有残留的文件，我们需要清理下，<code>make distclean</code>，然后重新编译就可以了，<code>make PREFIX=/apps/redis install</code>。<br>&emsp;&emsp;网上也有说可以通过加选项make MALLOC=libc来解决，不过其实是有一些隐患的。首先我们要知道redis 需要使用内存分配器的， 默认是指定内存分配器为 jemalloc ，make MALLOC=libc 就是指定内存分配器为 libc ，而jemalloc 内存分配器在实践中处理内存碎片是要比libc 好的，而且在README.md 文档也说明到了，jemalloc内存分配器也是包含在源码包里面的，可以在deps 目录下看到 jemalloc 目录。<br>&emsp;&emsp;编译完成后，接下来我们还需要几步操作。<br>&emsp;&emsp;创建目录结构<code>mkdir /apps/redis/{etc,logs,data,run}</code><br>&emsp;&emsp;从源码包中复制配置文件<code>cp redis.conf /apps/redis/etc/</code><br>&emsp;&emsp;创建systemctl服务启动脚本，为了避免安全隐患，我们还要将redis服务设为以redis身份启动，所以还要修改目录权限<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/redis.service &lt;&lt;<span class="string">"END"</span></span><br><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=Redis persistent key-value database</span><br><span class="line"><span class="attribute">After</span>=network.target</span><br><span class="line"><span class="attribute">After</span>=network-online.target</span><br><span class="line"><span class="attribute">Wants</span>=network-online.target</span><br><span class="line">[Service]</span><br><span class="line"><span class="comment">#ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd</span></span><br><span class="line"><span class="attribute">ExecStart</span>=/apps/redis/bin/redis-server /apps/redis/etc/redis.conf --supervised systemd</span><br><span class="line"><span class="attribute">ExecReload</span>=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attribute">ExecStop</span>=/bin/kill -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attribute">Type</span>=notify</span><br><span class="line"><span class="attribute">User</span>=redis</span><br><span class="line"><span class="attribute">Group</span>=redis</span><br><span class="line"><span class="attribute">RuntimeDirectory</span>=redis</span><br><span class="line"><span class="attribute">RuntimeDirectoryMode</span>=0755</span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建redis用户，并修改redis目录属主属组。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g <span class="number">379</span> redis &amp;&amp; useradd -u <span class="number">379</span> -g <span class="number">379</span> redis -s /sbin/nologin</span><br><span class="line">chown redis.redis -R /apps/redis</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改PATH变量或者直接用软链接的方式(用一个即可，效果一样)，方便执行redis命令。<br>&emsp;&emsp;<code>ln -sv /apps/redis/bin/* /usr/local/bin/</code>(软链接)<br>&emsp;&emsp;<code>echo &quot;PATH=/apps/redis/bin:$PATH&quot; &gt; /etc/profile.d/redis.sh；. /etc/profile.d/redis.sh</code>(改PATH变量)</p><h3 id="修改内核参数"><a href="#修改内核参数" class="headerlink" title="修改内核参数"></a>修改内核参数</h3><p>&emsp;&emsp;这时redis服务就其实已经搭建完成了，已经可以通过服务脚本进行启动了。可是如果直接启动会有一些[warning]信息，而且很有可能在高并发的时候导致redis崩溃。<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13636</span>:M <span class="number">13</span> Nov <span class="number">10</span>:<span class="number">37</span>:<span class="number">06.195</span> # WARNING: The TCP backlog setting of <span class="number">511</span> cannot be enforced because /<span class="keyword">proc</span>/sys/net/core/somaxconn<span class="title"> is</span> set<span class="title"> to</span> the<span class="title"> lower</span> value<span class="title"> of</span> 128.</span><br><span class="line">13636:M 13<span class="title"> Nov</span> 10:37:06.195 #<span class="title"> Server</span> initialized</span><br><span class="line">13636:M 13<span class="title"> Nov</span> 10:37:06.195 #<span class="title"> WARNING</span> overcommit_memory<span class="title"> is</span> set<span class="title"> to</span> 0!<span class="title"> Background</span> save<span class="title"> may</span> fail<span class="title"> under</span> low<span class="title"> memory</span> condition.<span class="title"> To</span> fix<span class="title"> this</span> issue<span class="title"> add</span> 'vm.overcommit_memory = 1'<span class="title"> to</span> /etc/sysctl.conf<span class="title"> and</span> then<span class="title"> reboot</span> or<span class="title"> run</span> the<span class="title"> command</span> 'sysctl<span class="title"> vm.overcommit_memory=1'</span> for<span class="title"> this</span> to<span class="title"> take</span> effect.</span><br><span class="line">13636:M 13<span class="title"> Nov</span> 10:37:06.195 #<span class="title"> WARNING</span> you<span class="title"> have</span> Transparent<span class="title"> Huge</span> Pages (THP)<span class="title"> support</span> enabled<span class="title"> in</span> your<span class="title"> kernel.</span> This<span class="title"> will</span> create<span class="title"> latency</span> and<span class="title"> memory</span> usage<span class="title"> issues</span> with<span class="title"> Redis.</span> To<span class="title"> fix</span> this<span class="title"> issue</span> run<span class="title"> the</span> command 'echo<span class="title"> never</span> &gt; /sys/kernel/mm/transparent_hugepage/enabled'<span class="title"> as</span> root,<span class="title"> and</span> add<span class="title"> it</span> to<span class="title"> your</span> /etc/rc.local<span class="title"> in</span> order<span class="title"> to</span> retain<span class="title"> the</span> setting<span class="title"> after</span> a<span class="title"> reboot.</span> Redis<span class="title"> must</span> be<span class="title"> restarted</span> after<span class="title"> THP</span> is<span class="title"> disabled.</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以通过修改一些内核参数来避免这一风险。</p><ul><li>TCP backlog 参数控制的是三次握手的时候 server 端收到 client ack 确认号之后的队列值，redis默认为511。我们需要将内核的net.core.somaxconn值(系统默认128)更改为大于511，或将redis的队列之修改小于128.</li><li>将vm.overcommit_memory值改为1<br>0、表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br>1、表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2、表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>transparent hugepage：<br>开启大页内存动态分配，需要关闭让 redis 负责内存管理。</li></ul><p>&emsp;&emsp;所以，我们执行下面操作<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/sysctl<span class="selector-class">.conf</span> &lt;&lt; END</span><br><span class="line">net<span class="selector-class">.core</span><span class="selector-class">.somaxconn</span> = <span class="number">512</span></span><br><span class="line">vm<span class="selector-class">.overcommit_memory</span> = <span class="number">1</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/mm/</span>transparent_hugepage<span class="regexp">/enabled</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，redis就正式调试完成，可以正常使用了。</p><h3 id="附：一键编译安装redis脚本"><a href="#附：一键编译安装redis脚本" class="headerlink" title="附：一键编译安装redis脚本"></a>附：一键编译安装redis脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DST=<span class="string">"/apps"</span></span><br><span class="line"><span class="comment">#[ -d $DST ] || &#123; echo "install into $DST fail,No such file or directory" ;exit 10;&#125;</span></span><br><span class="line">[ -a redis-*.tar.* ] || &#123; <span class="built_in">echo</span> <span class="string">' the absence of redis.tar.gz'</span> ;<span class="built_in">exit</span> 1;&#125;</span><br><span class="line">[ -a /usr/lib/systemd/system/redis.service ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">'redis.service is exist,redis is aready installed'</span> ;<span class="built_in">exit</span> 2;&#125;</span><br><span class="line">[ -d <span class="variable">$DST</span>/redis* ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"redis is aready installed into <span class="variable">$DST</span>/redis"</span> ;<span class="built_in">exit</span> 3;&#125;</span><br><span class="line">id redis &amp;&gt;/dev/null &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">'user redis is exist,redis is aready installed'</span> ; <span class="built_in">exit</span> 4;&#125; || &#123; groupadd -g 379 redis &amp;&amp; useradd -u 379 -g 379 redis -s /sbin/nologin || &#123; <span class="built_in">echo</span> user 379 is exist ;<span class="built_in">exit</span> 5; &#125; &#125;</span><br><span class="line">mkdir -p <span class="variable">$DST</span>/redis</span><br><span class="line">yum  install  -y make gcc</span><br><span class="line"><span class="comment">#yum  install  -y make gcc wget</span></span><br><span class="line"><span class="comment">#wget http://download.redis.io/releases/redis-4.0.14.tar.gz</span></span><br><span class="line">tar xf redis-*.tar.*</span><br><span class="line">PTH=`find . -name <span class="string">"redis*"</span> -<span class="built_in">type</span> d |head -n1`</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$PTH</span></span><br><span class="line">make PREFIX=<span class="variable">$DST</span>/redis install</span><br><span class="line">mkdir <span class="variable">$DST</span>/redis/&#123;etc,logs,data,run&#125;</span><br><span class="line">cp redis.conf /apps/redis/etc/</span><br><span class="line">chown redis.redis -R /apps/redis</span><br><span class="line">cat &gt; /usr/lib/systemd/system/redis.service &lt;&lt; END</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line"><span class="comment">#ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd</span></span><br><span class="line">ExecStart=<span class="variable">$DST</span>/redis/bin/redis-server <span class="variable">$DST</span>/redis/etc/redis.conf --supervised systemd</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP \<span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -s QUIT \<span class="variable">$MAINPID</span></span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">ln -sv <span class="variable">$DST</span>/redis/bin/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /etc/sysctl.conf &lt;&lt; END</span><br><span class="line">net.core.somaxconn = 512</span><br><span class="line">vm.overcommit_memory = 1</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> --now redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Redis 和 Memcached 是非关系型数据库也称为 NoSQL 数据库， MySQL、 Mariadb、 SQLServer、 PostgreSQL、 Oracle 数据库属于关系型数据(RDBMS, Relational Database Management System)。&lt;br&gt;&amp;emsp;&amp;emsp;Redis(Remote Dictionary Server)在 2009 年发布， 开发者 Salvatore Sanfilippo 是意大利开发者， 他本想为自己的公司开发一个用于替换 MySQL 的产品 Redis， 但是没有想到他把 Redis 开源后大受欢迎，短短几年， Redis 就有了很大的用户群体，目前国内外使用的公司有知乎&amp;gt;网、新浪微博、 GitHub 等。&lt;br&gt;&amp;emsp;&amp;emsp;redis 是一个开源的、 遵循 BSD 协议的、 基于内存的而且目前比较流行的键值数据库(key-value database)，是一个非关系型数据库，redis 提供将内存通过网络远程共享的一种服务，提供类似功能的还有 memcache，但相比 memcache， redis 还提供了易扩展、高性能、 具备数据持久性等功能。&lt;br&gt;&amp;emsp;&amp;emsp;Redis 在高并发、低延迟环境要求比较高的环境使用量非常广泛， 目前 redis 在 DBEngine 月排行榜 &lt;a href=&quot;https://db-engines.com/en/ranking&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://db-engines.com/en/ranking&lt;/a&gt; 中一直比较靠前，而且一直是键值型存储类的首位。&lt;br&gt;
    
    </summary>
    
      <category term="NotOnlySQL" scheme="https://wudihechao.github.io/categories/NotOnlySQL/"/>
    
    
      <category term="企业级应用" scheme="https://wudihechao.github.io/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    
      <category term="一键安装" scheme="https://wudihechao.github.io/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"/>
    
      <category term="redis" scheme="https://wudihechao.github.io/tags/redis/"/>
    
      <category term="源码编译" scheme="https://wudihechao.github.io/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    
      <category term="内核参数" scheme="https://wudihechao.github.io/tags/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
</feed>
